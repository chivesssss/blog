<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="https://cdn.jsdelivr.net/gh/chivesssss/picture-store@master/uPic/favicon.svg">
  <link rel="icon" type="image/png" sizes="32x32" href="https://cdn.jsdelivr.net/gh/chivesssss/picture-store@master/uPic/favicon.svg">
  <link rel="icon" type="image/png" sizes="16x16" href="https://cdn.jsdelivr.net/gh/chivesssss/picture-store@master/uPic/favicon.svg">
  <link rel="mask-icon" href="https://cdn.jsdelivr.net/gh/chivesssss/picture-store@master/uPic/favicon.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7Csource+code+pro:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"chivesssss.github.io","root":"/blog/","images":"/blog/images","scheme":"Gemini","darkmode":true,"version":"8.8.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/blog/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/blog/js/config.js"></script>
<meta name="description" content="原始类型、引用类型原始类型：undefined、null、boolean、 string、 number、 symbol typeof null &#x3D;&#x3D;&#x3D; &#39;object&#39; 是一个历史悠久的 bug，因为 000 开始表示对象， null 也是全零 原始类型存储的是值，引用类型存储的是指针 typeof 可以判断除了 null 以外的原始类型。 instanceof 可以判对象的正确">
<meta property="og:type" content="article">
<meta property="og:title" content="知识点梳理">
<meta property="og:url" content="https://chivesssss.github.io/blog/interviews-interview-formatted/">
<meta property="og:site_name" content="牧野の自留地">
<meta property="og:description" content="原始类型、引用类型原始类型：undefined、null、boolean、 string、 number、 symbol typeof null &#x3D;&#x3D;&#x3D; &#39;object&#39; 是一个历史悠久的 bug，因为 000 开始表示对象， null 也是全零 原始类型存储的是值，引用类型存储的是指针 typeof 可以判断除了 null 以外的原始类型。 instanceof 可以判对象的正确">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/chivesssss/picture-store@master/uPic/2021/03/28/13/27/CUIOOY.png">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2017/11/29/16007be6f64ff7f7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2017/11/29/16007d1c835d5461?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="article:published_time" content="2021-05-27T22:22:05.000Z">
<meta property="article:modified_time" content="2021-11-08T03:26:39.357Z">
<meta property="article:author" content="牧野ξ">
<meta property="article:tag" content="Javascript">
<meta property="article:tag" content="Interview">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/chivesssss/picture-store@master/uPic/2021/03/28/13/27/CUIOOY.png">


<link rel="canonical" href="https://chivesssss.github.io/blog/interviews-interview-formatted/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://chivesssss.github.io/blog/interviews-interview-formatted/","path":"interviews-interview-formatted/","title":"知识点梳理"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>知识点梳理 | 牧野の自留地</title>
  




  <noscript>
    <link rel="stylesheet" href="/blog/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">牧野の自留地</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">凡是过往 皆为序章</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/blog/./" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/blog/./about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/blog/./tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/blog/./categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/blog/./archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%E3%80%81%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.</span> <span class="nav-text">原始类型、引用类型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.</span> <span class="nav-text">类型转换</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#this"><span class="nav-number">3.</span> <span class="nav-text">this</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%97%AD%E5%8C%85"><span class="nav-number">4.</span> <span class="nav-text">闭包</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="nav-number">5.</span> <span class="nav-text">深浅拷贝</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B%E5%8F%8A%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="nav-number">6.</span> <span class="nav-text">原型及原型链</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%8F%8A%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="nav-number">7.</span> <span class="nav-text">作用域及作用域链</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF%E5%92%8C-Class-%E7%BB%A7%E6%89%BF"><span class="nav-number">8.</span> <span class="nav-text">原型继承和 Class 继承</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="nav-number">9.</span> <span class="nav-text">模块化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Proxy"><span class="nav-number">10.</span> <span class="nav-text">Proxy</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Reflect"><span class="nav-number">11.</span> <span class="nav-text">Reflect</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="nav-number">12.</span> <span class="nav-text">回调函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Generator"><span class="nav-number">13.</span> <span class="nav-text">Generator</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Promise"><span class="nav-number">14.</span> <span class="nav-text">Promise</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#async-await"><span class="nav-number">15.</span> <span class="nav-text">async &#x2F; await</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-number">16.</span> <span class="nav-text">定时器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-Event-Loop"><span class="nav-number">17.</span> <span class="nav-text">事件循环 (Event Loop)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%89%8B%E5%86%99-apply-%E3%80%81-call-%E3%80%81-bind-%E5%87%BD%E6%95%B0"><span class="nav-number">18.</span> <span class="nav-text">手写 apply 、 call 、 bind 函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#new"><span class="nav-number">19.</span> <span class="nav-text">new</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#instanceof-%E5%8E%9F%E7%90%86"><span class="nav-number">20.</span> <span class="nav-text">instanceof 原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6"><span class="nav-number">21.</span> <span class="nav-text">事件机制</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B7%A8%E5%9F%9F"><span class="nav-number">22.</span> <span class="nav-text">跨域</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="nav-number">23.</span> <span class="nav-text">浏览器缓存机制</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86"><span class="nav-number">24.</span> <span class="nav-text">浏览器渲染原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="nav-number">25.</span> <span class="nav-text">性能优化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Webpack-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="nav-number">26.</span> <span class="nav-text">Webpack 性能优化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%8E%E8%BE%93%E5%85%A5-URL-%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93"><span class="nav-number">27.</span> <span class="nav-text">从输入 URL 到页面渲染</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="牧野ξ"
      src="/blog/uploads/images/avatar.png">
  <p class="site-author-name" itemprop="name">牧野ξ</p>
  <div class="site-description" itemprop="description">自留地，前端笔记，日记，日常记录</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/blog/./archives/">
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/blog/./categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/blog/./tags/">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/chivesssss" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;chivesssss" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:ismartgoo@gmail.com" title="E-Mail → mailto:ismartgoo@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.tcmiao.com/" title="https:&#x2F;&#x2F;www.tcmiao.com" rel="noopener" target="_blank">tcmiao</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://hentaizhou.github.io/z-blog" title="https:&#x2F;&#x2F;hentaizhou.github.io&#x2F;z-blog" rel="noopener" target="_blank">collie Z</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://chivesssss.github.io/docsify/notes" title="https:&#x2F;&#x2F;chivesssss.github.io&#x2F;docsify&#x2F;notes">notes</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chivesssss.github.io/blog/interviews-interview-formatted/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/uploads/images/avatar.png">
      <meta itemprop="name" content="牧野ξ">
      <meta itemprop="description" content="自留地，前端笔记，日记，日常记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="牧野の自留地">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          知识点梳理
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-05-27 22:22:05" itemprop="dateCreated datePublished" datetime="2021-05-27T22:22:05+00:00">2021-05-27</time>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="原始类型、引用类型"><a href="#原始类型、引用类型" class="headerlink" title="原始类型、引用类型"></a>原始类型、引用类型</h1><p>原始类型：<code>undefined</code>、<code>null</code>、<code>boolean</code>、 <code>string</code>、 <code>number</code>、 <code>symbol</code></p>
<p><code>typeof null === &#39;object&#39;</code> 是一个历史悠久的 bug，因为 <code>000</code> 开始表示对象， <code>null</code> 也是全零</p>
<p>原始类型存储的是值，引用类型存储的是指针</p>
<p><code>typeof</code> 可以判断除了 <code>null</code> 以外的原始类型。 <code>instanceof</code> 可以判对象的正确类型，但是不能判断原始类型，因为它是通过<code>原型链</code>去判断的。</p>
<span id="more"></span>

<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><p>略，详见掘金小册</p>
<h1 id="this"><a href="#this" class="headerlink" title="this"></a>this</h1><ol>
<li>定义一个函数 <code>foo()</code>，如果直接调用 <code>foo</code> ，不管 <code>foo</code> 函数放在了什么地方， <code>this</code> 一定是 <code>window</code></li>
<li>对于 <code>obj.foo()</code> 等情形，谁调用了函数，谁就是 <code>this</code> 。这里 <code>this</code> 就是 <code>obj</code> 对象</li>
<li>对于 <code>const f = new foo()</code> 的方式来说， <code>this</code> 永远指向 <code>f</code> ，不会有任何改变</li>
<li>箭头函数是没有 <code>this</code> 的，箭头函数的 <code>this</code> 取决于包裹箭头函数的第一个普通函数的 <code>this</code> 。另外，箭头函数使用 <code>bind</code> 、 <code>new</code> 这类函数是无效的</li>
<li>对于 <code>bind</code> 这些改变上下文的 API， <code>this</code> 只取决于第一个参数，如果第一个参数为空，那么就是 <code>window</code> 。注意，一个函数无论我们 <code>bind</code> 几次， <code>this</code> 永远由第一次 bind 决定</li>
</ol>
<pre><code class="javascript">const a = &#123;&#125;
const fn = function () &#123;
  console.log(this)
&#125;
fn.bind().bind(a)()

// 换种写法
const fn2 = function () &#123;
  return function () &#123;
    return fn.apply()
  &#125;.apply(a)
&#125;
</code></pre>
<ol start="6">
<li>综上： <strong><code>new</code> 的方式优先级最高，其次 <code>bind</code> 等函数，然后是 <code>obj.foo()</code> 这种方式的调用，最后是 <code>直接调用</code>。同时，箭头函数的 <code>this</code> 一旦绑定，就不会再改变了</strong></li>
</ol>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>定义：函数和 <code>声明</code> 这个函数时的作用域结合起来，就是闭包</p>
<pre><code class="js">;(function () &#123;
  var a = 1
  function add() &#123;
    var b = 2
    var sum = b + a
    console.log(sum) // 3
  &#125;
  add()
&#125;)()
</code></pre>
<p><code>add</code> 函数本身，以及其内部可访问的变量，即 <code>a = 1</code> ，这两个组合在⼀起就被称为闭包，仅此⽽已。</p>
<p>闭包最⼤的作⽤就是<strong>隐藏变量</strong>，闭包的⼀⼤特性就是<strong>内部函数总是可以访问其所在的外部函数中声明的参数和变量</strong>，即使在其外部函数被返回（寿命终结）了之后也可以访问。</p>
<p>基于此特性，JavaScript 可以实现<strong>私有变量</strong>、<strong>特权变量</strong>、<strong>储存变量</strong>等</p>
<p>我们就以<strong>私有变量</strong>举例，私有变量的实现⽅法很多，有靠约定的（变量名前加<code>_</code>）,有靠 <code>Proxy</code> 代理的，也有靠 <code>Symbol</code> 这种新数据类型的。</p>
<p>但是真正⼴泛流⾏的其实是使⽤闭包。</p>
<pre><code class="js">function Person() &#123;
  var name = &#39;Jim&#39;
  this.getName = function () &#123;
    return name
  &#125;
  this.setName = function (value) &#123;
    name = value
  &#125;
&#125;
const Jim = new Person()
console.log(Jim.getName()) // Jim
Jim.setName(&#39;Tom&#39;)
console.log(Jim.getName()) // Tom
console.log(name) //name is not defined
</code></pre>
<p>其他例子</p>
<pre><code class="javascript">// 第一题
;(function () &#123;
  function createIncrement() &#123;
    let count = 0
    function increment() &#123;
      count++
    &#125;

    let message = `Count is $&#123;count&#125;`
    function log() &#123;
      console.log(message)
    &#125;

    return [increment, log]
  &#125;

  const [increment, log] = createIncrement()
  increment()
  increment()
  increment()
  log() // =&gt; ?
&#125;)()

// 第二题
;(function () &#123;
  function fn() &#123;
    a = 0
    return function (b) &#123;
      return b + a++
    &#125;
  &#125;
  var f = fn()
  console.log(f(5)) // 5
  console.log(fn()(5)) // 5
  console.log(f(5)) // 6
  console.log(a) // 2
&#125;)()
</code></pre>
<h1 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h1><p>浅拷贝： <code>Object.assign</code> ， <code>&#123;...someObject&#125;</code></p>
<p>深拷贝： <code>JSON.parse(JSON.stringfy(object))</code> ，但是也有局限性</p>
<ul>
<li>会忽略 <code>undefined</code></li>
<li>会忽略 <code>symbol</code></li>
<li>不能序列化函数</li>
<li>不能解决循环引用的对象</li>
</ul>
<pre><code class="javascript">/**
 * 简易版深拷贝函数
 */
const deepClone = obj =&gt; &#123;
  if (typeof obj !== &#39;object&#39;) &#123;
    throw new Error(&#39;发生错误&#39;)
  &#125;

  const newObj = obj instanceof Array ? [] : &#123;&#125;

  for (const key in obj) &#123;
    if (Object.hasOwnProperty.call(obj, key)) &#123;
      const value = obj[key]
      newObj[key] = typeof value === &#39;object&#39; ? deepClone(value) : value
    &#125;
  &#125;
  return newObj
&#125;
</code></pre>
<h1 id="原型及原型链"><a href="#原型及原型链" class="headerlink" title="原型及原型链"></a>原型及原型链</h1><p>当我们创建一个<strong>实例</strong>时 <code>let person = new Person(&#39;Jim&#39;, &#39;25&#39;, &#39;football player&#39;)</code> ，我们可以发现能使用很多种函数，但是我们明明没有定义过它们，对于这种情况你是否有过疑惑？</p>
<p>当我们在浏览器中打印 <code>person</code> 时你会发现，在 <code>person</code> 上居然还有一个 <code>__proto__</code> 属性。其实每个 JS 对象都有 <code>__proto__</code> 属性，这个属性指向了该对象 <code>Person</code> 的原型 <code>Person.prototype</code>。</p>
<p>原型也是一个对象，并且这个对象中包含了很多函数，所以我们可以得出一个结论：对于 <code>person</code> 来说，可以通过 <code>__proto__</code> 找到一个原型对象，在该对象中定义了很多函数让我们来使用。</p>
<p>在 <code>__proto__</code> 对象中还有一个 <code>constructor</code> 属性，也就是构造函数。打开 <code>constructor</code> 属性我们又可以发现其中还有一个 <code>prototype</code> 属性，并且这个属性对应的值和先前我们在 <code>__proto__</code> 中看到的一模一样。所以我们又可以得出一个结论：原型的 <code>constructor</code> 属性指向构造函数，构造函数又通过 <code>prototype</code> 属性指回原型，但是并不是所有函数都具有这个属性，<code>Function.prototype.bind()</code> 就没有这个属性。</p>
<p><img src="https://cdn.jsdelivr.net/gh/chivesssss/picture-store@master/uPic/2021/03/28/13/27/CUIOOY.png" alt="示意图"></p>
<p>总结：</p>
<ul>
<li><code>Object</code> 是所有对象的爸爸，所有对象都可以通过 <code>__proto__</code> 找到它</li>
<li><code>Function</code> 是所有函数的爸爸，所有函数都可以通过 <code>__proto__</code> 找到它</li>
<li>函数的 prototype 是一个对象</li>
<li>对象的 <code>__proto__</code> 属性指向原型， <code>__proto__</code> 将对象和原型连接起来组成了原型链</li>
</ul>
<h1 id="作用域及作用域链"><a href="#作用域及作用域链" class="headerlink" title="作用域及作用域链"></a>作用域及作用域链</h1><p>作用域就是一个<strong>独立的地盘</strong>，最大的用处就是<strong>隔离变量</strong>，不同作用域下同名变量不会有冲突。</p>
<p><code>ES6</code> 之前 <code>JavaScript</code> 没有块级作用域，只有全局作用域和函数作用域。<code>ES6</code>的到来，为我们提供了<code>块级作用域</code>，可通过新增命令 <code>let</code> 和 <code>const</code> 来体现。</p>
<p>全局作用域</p>
<ul>
<li>最外层函数 和在最外层函数外面定义的变量拥有全局作用域</li>
<li>所有末定义直接赋值的变量自动声明为拥有全局作用域</li>
<li>所有 window 对象的属性拥有全局作用域</li>
</ul>
<p>块级作用域</p>
<p>块级作用域可通过新增命令 let 和 const 声明，所声明的变量在指定块的作用域外无法被访问。块级作用域在如下情况被创建：</p>
<ul>
<li>在一个函数内部</li>
<li>在一个代码块（由一对花括号包裹）内部</li>
</ul>
<p>块级作用域有以下几个特点：</p>
<ul>
<li>声明变量不会提升到代码块顶部，所以会暂时性锁区</li>
<li>禁止重复声明</li>
</ul>
<p>作用域链</p>
<p>当在当前作用域中取值失败时，就要到<strong>创建</strong>这个函数的那个作用域中取值，这里强调的是“创建”，而不是“调用”。如果还是取值失败，继续往上，形成的链条，就叫作用域链。</p>
<p>什么是变量提升</p>
<p>JavaScript 引擎的⼯作⽅式是，先解析代码，获取所有被声明的变量，然后再⼀⾏⼀⾏地运⾏。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。存在提升的原因：解决函数之间的相互调用。</p>
<pre><code class="javascript">console.log(a) // undefined
var a = 1
function b() &#123;
  console.log(a)
&#125;
b() // 1
</code></pre>
<p>上⾯的代码实际执⾏顺序是这样的:</p>
<p>第⼀步： 引擎将 <code>var a = 1</code> 拆解为 <code>var a = undefined</code> 和 <code>a = 1</code> ，并将 <code>var a = undefined</code> 放到最顶端， <code>a = 1</code> 还在原来的位置，这样⼀来代码就是这样:</p>
<pre><code class="javascript">var a = undefined
console.log(a) // undefined
a = 1
function b() &#123;
  console.log(a)
&#125;
b() // 1
</code></pre>
<p>第⼆步就是执⾏，因此 js 引擎⼀⾏⼀⾏从上往下执⾏就造成了当前的结果，这就叫变量提升。</p>
<blockquote>
<p>函数提升优于变量提升，函数提升会把 <code>整个函数</code> 挪到作用域顶部，变量提升只会把 <code>变量声明</code> 挪到作用域顶部</p>
</blockquote>
<p>var、let 及 const</p>
<ul>
<li><code>var</code> 存在提升，我们能在声明之前使用。 <code>let</code> <code>、const</code> 因为暂时性死区，不能在声明之前使用</li>
<li>全局作用域下使用 <code>let</code> 和 <code>const</code> 声明变量，变量不会被挂载到 <code>window</code> 上，这和 <code>var</code> 不一样</li>
<li><code>let</code> 和 <code>const</code> 作用基本一致，但是后者声明的变量不能再次赋值</li>
</ul>
<h1 id="原型继承和-Class-继承"><a href="#原型继承和-Class-继承" class="headerlink" title="原型继承和 Class 继承"></a>原型继承和 Class 继承</h1><pre><code class="javascript">/**
 * 组合继承：子类的构造函数中通过 Parent.call(this) 继承父类的属性，
 * 然后改变子类的原型为 new Parent() 来继承父类的函数
 */
function Parent(value) &#123;
  this.value = value
&#125;

Parent.prototype.getValue = function () &#123;
  console.log(this.value)
&#125;

function Child(value) &#123;
  Parent.call(this, value) // 构造函数可以传参，不会与父类引用属性共享
&#125;

Child.prototype = new Parent() // 可以复用父类的函数，但是子类原型上多了不需要的父类的属性

const child = new Child(1)

child.getValue() // 1

child instanceof Parent // true
</code></pre>
<pre><code class="javascript">/**
 * Class 继承，关键点在于 extends、super
 */
class Parent &#123;
  constructor(value) &#123;
    this.value = value
  &#125;

  getValue() &#123;
    console.log(this.value)
  &#125;
&#125;

class Child extends Parent &#123;
  constructor(value) &#123;
    super(value)
    this.value = value
  &#125;
&#125;

const child = new Child(1)

child.getValue() // 1

child instanceof Parent // true
</code></pre>
<h1 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h1><h1 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h1><p><code>Proxy</code> 可以理解成，在目标对象之前架设一层<code>“拦截”</code>，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</p>
<pre><code class="javascript">let proxy = new Proxy(target, handler)
</code></pre>
<ul>
<li><code>target</code> —— 是要包装的<code>对象</code>，可以是任何东西，包括函数。</li>
<li><code>handler</code> —— 代理配置：带有“钩子”（“traps”，即拦截操作的方法）的<code>对象</code>。比如 <code>get</code> 钩子用于读取 <code>target</code> 属性， <code>set</code> 钩子写入 <code>target</code> 属性等等。</li>
</ul>
<blockquote>
<p>对 <code>proxy</code> 进行操作，如果在 <code>handler</code> 中存在相应的钩子，则它将运行，并且 <code>Proxy</code> 有机会对其进行处理，否则将直接对 <code>target</code> 进行处理。</p>
</blockquote>
<p>Handler 对象包含的方法：<code>get</code> 、 <code>set</code> 、 <code>has</code> （in 运算符） 、 <code>deleteProperty</code> （delete 操作） 、 <code>apply</code> （proxy 对象作为函数被调用）、 <code>construct</code> （new 操作）、 <code>defineProperty</code></p>
<pre><code class="javascript">/**
 * 通过自定义 set 和 get 函数的方式，在原本的逻辑中插入了我们的函数
 * 逻辑（回调函数），实现了在对对象任何属性进行读写时发出通知
 */
let obj = &#123; a: 1 &#125;

let onWatch = (target, setCallback, getCallback) =&gt; &#123;
  return new Proxy(target, &#123;
    set(target, key, value, receiver) &#123;
      setCallback(key, value)
      return Reflect.set(target, key, value, receiver)
    &#125;,
    get(target, key, receiver) &#123;
      getCallback(target, key)

      // return target[key]
      return Reflect.get(target, key, receiver)
    &#125;,
  &#125;)
&#125;

let p = onWtch(
  obj,
  (k, v) =&gt; &#123;
    // 数据变化，响应式监听
    console.log(`监测到属性$&#123;k&#125;改变为$&#123;v&#125;`)
  &#125;,
  (t, k) =&gt; &#123;
    // 数据读取，响应式派发
    console.log(`&#39;$&#123;k&#125;&#39; = $&#123;t[k]&#125;`)
  &#125;
)

p.a = 3 // 监测到属性a改变为3
p.a // &#39;a&#39; = 3
</code></pre>
<p>Proxy 有一些局限：</p>
<ul>
<li>内置对象（<code>Map</code>、<code>Set</code>、<code>Promise</code>、<code>Date</code>）具有“内部插槽”，对这些对象的访问无法被代理。</li>
<li>私有类字段也是如此，因为它们是在内部使用插槽实现的。因此，代理方法的调用必须具有目标对象 this 才能访问它们</li>
<li>对象相等性测试 === 不能被拦截</li>
<li>性能：基准测试取决于引擎，但通常使用最简单的代理访问属性所需的时间要长几倍。实际上，这仅对某些“瓶颈”对象重要</li>
</ul>
<h1 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h1><ol>
<li>将 <code>Object</code> 对象的一些明显属于语言内部的方法（比如 <code>Object.defineProperty</code> ），放到 <code>Reflect</code> 对象上。现阶段，某些方法同时在 <code>Object</code> 和 <code>Reflect</code> 对象上部署，未来的新方法将只部署在 <code>Reflect</code> 对象上</li>
<li>修改某些 <code>Object</code> 方法的返回结果，让其变得更合理。比如，<code>Object.defineProperty(obj, name, desc)</code> 在无法定义属性时，会抛出一个错误，而 <code>Reflect.defineProperty(obj, name, desc)</code> 则会返回 <code>false</code> 。</li>
<li>让 <code>Object</code> 操作都变成函数行为。某些 <code>Object</code> 操作是命令式，比如 <code>name in obj</code> 和 <code>delete obj[name]</code>，而 <code>Reflect.has(obj, name)</code> 和 <code>Reflect.deleteProperty(obj, name)</code> 让它们变成了函数行为</li>
<li><code>Reflect</code> 对象的方法与 <code>Proxy</code> 对象的方法一一对应，只要是 <code>Proxy</code> 对象的方法，就能在 <code>Reflect</code> 对象上找到对应的方法。这就让 <code>Proxy</code> 对象可以方便地调用对应的 <code>Reflect</code> 方法，完成<strong>原始对象的默认行为</strong>，作为修改行为的基础。也就是说，不管 <code>Proxy</code> 怎么修改默认行为（e.g. <code>set()、get()</code>），你总可以在 <code>Reflect</code> 上获取原始对象的默认行为。</li>
</ol>
<blockquote>
<p>在大多数情况下，我们可以不使用 <code>Reflect</code> 完成相同的事情，例如，使用 <code>Reflect.get(target, prop, receiver)</code> 读取属性可以替换为 <code>target[prop]</code> 。尽管有一些细微的差别。</p>
</blockquote>
<pre><code class="javascript">let user = &#123;
  _name: &#39;Guest&#39;,
  get name() &#123;
    return this._name
  &#125;,
&#125;

let userProxy = new Proxy(user, &#123;
  get(target, prop, receiver) &#123;
    return target[prop]
  &#125;,
&#125;)

console.log(userProxy.name) // Guest
</code></pre>
<p>该 <code>get</code> 钩子在这里是“ <code>透明的</code> ”，它返回原来的属性，不会做别的任何事情。对于我们的示例而言，这就足够了。</p>
<p>但是对象 <code>admin</code> 从 <code>user</code> 继承后，我们可以观察到错误的行为</p>
<pre><code class="javascript">let user = &#123;
  _name: &#39;Guest&#39;,
  get name() &#123;
    return this._name
  &#125;,
&#125;

let userProxy = new Proxy(user, &#123;
  get(target, prop, receiver) &#123;
    return target[prop] // (*) target = user
  &#125;,
&#125;)

let admin = &#123;
  __proto__: userProxy,
  _name: &#39;Admin&#39;,
&#125;

// Expected: Admin
alert(admin.name) // 输出：Guest （？！？）
</code></pre>
<p>问题实际上出在代理中，在 <code>(*)</code> 行</p>
<ol>
<li>当我们读取 <code>admin.name</code> ，由于 <code>admin</code> 对象自身没有对应的的属性，搜索将转到其原型</li>
<li>原型是 <code>userProxy</code></li>
<li>从代理读取 <code>name</code> 属性时， <code>get</code> 钩子会触发并从原始对象返回 <code>target[prop]</code> 属性，在 <code>(*)</code> 行当调用 <code>target[prop]</code> 时，若 <code>prop</code> 是一个 <code>getter</code> ，它将在 <code>this=target</code> 上下文中运行其代码。因此，结果是来自原始对象 <code>target</code> 的 <code>this._name</code> 即来自 <code>user</code> 。</li>
</ol>
<p>更正后的变体</p>
<pre><code class="javascript">let user = &#123;
  _name: &#39;Guest&#39;,
  get name() &#123;
    return this._name
  &#125;,
&#125;

let userProxy = new Proxy(user, &#123;
  get(target, prop, receiver) &#123;
    // receiver = admin
    return Reflect.get(target, prop, receiver) // (*)
    // return Reflect.get(...arguments)
  &#125;,
&#125;)

let admin = &#123;
  __proto__: userProxy,
  _name: &#39;Admin&#39;,
&#125;

alert(admin.name) // Admin
</code></pre>
<h1 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h1><p>回调地狱：</p>
<ul>
<li>嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身</li>
<li>嵌套函数一多，就很难处理错误</li>
</ul>
<h1 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h1><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>特点：</p>
<ul>
<li>三种状态（ <code>pending</code> 、 <code>resolved</code> 、 <code>rejected</code> ），状态一旦切换，不能改变</li>
<li><code>new Promise</code> 立即执行</li>
<li>链式调用，<code>.then</code> 都是返回一个全新的 <code>Promise</code> 对象</li>
<li>解决了回调地狱</li>
</ul>
<p>缺点：</p>
<ul>
<li><code>Promise</code> 无法取消</li>
<li>错误只能在回调函数里面捕获</li>
</ul>
<pre><code class="javascript">/**
 * 手写 Promise
 * 作用：1、消灭嵌套调用；2、合并多个任务的请求结果
 * API： Promise.resolve, Promise.reject, Promise.prototype.catch,
 * Promise.prototype.finally, Promise.all, Promise.race
 */
const PENDING = &#39;pending&#39;
const RESOLVED = &#39;resolved&#39;
const REJECTED = &#39;rejected&#39;
function MyPromise(executor) &#123;
  this.status = PENDING
  this.value = undefined
  this.reason = undefined

  this.onResolvedCallbacks = []
  this.onRejectedCallbacks = []

  const resolve = value =&gt; &#123;
    if (this.status === PENDING) &#123;
      this.value = value
      this.status = RESOLVED

      this.onResolvedCallbacks.forEach(fn =&gt; fn())
    &#125;
  &#125;

  const reject = reason =&gt; &#123;
    if (this.status === PENDING) &#123;
      this.reason = reason
      this.status = REJECTED

      this.onRejectedCallbacks.forEach(fn =&gt; fn())
    &#125;
  &#125;

  try &#123;
    executor(resolve, reject)
  &#125; catch (error) &#123;
    reject(error)
  &#125;
&#125;

MyPromise.prototype.then = function (onResolved, onRejected) &#123;
  onResolved = typeof onResolved === &#39;function&#39; ? onResolved : v =&gt; v
  onRejected =
    typeof onRejected === &#39;function&#39;
      ? onRejected
      : err =&gt; &#123;
          throw err
        &#125;

  if (this.status === RESOLVED) &#123;
    onResolved(this.value)
  &#125;

  if (this.status === REJECTED) &#123;
    onRejected(this.reason)
  &#125;

  if (this.status === PENDING) &#123;
    this.onResolvedCallbacks.push(() =&gt; &#123;
      onResolved(this.value)
    &#125;)

    this.onRejectedCallbacks.push(() =&gt; &#123;
      onRejected(this.reason)
    &#125;)
  &#125;
&#125;
</code></pre>
<h1 id="async-await"><a href="#async-await" class="headerlink" title="async / await"></a>async / await</h1><p>async 函数，就是 Generator 函数的语法糖，它建⽴在 Promises 上，并且与所有现有的基于 Promise 的 API 兼容。</p>
<ol>
<li><code>async</code> 声明⼀个异步函数(async function someName(){…})</li>
<li>⾃动将常规函数转换成 Promise 函数，返回值也是⼀个 Promise 对象</li>
<li>只有 async 函数内部的异步操作执⾏完，才会执⾏ then ⽅法指定的回调函数</li>
<li>异步函数内部可以使⽤ await</li>
<li><code>await</code> 暂停异步的功能执⾏(var result = await someAsyncCall();)</li>
<li>放置在 Promise 调⽤之前，await 强制其他代码等待，直到 Promise 完成并返回结果</li>
<li>只能与 Promise ⼀起使⽤，不适⽤与回调</li>
<li>await 只能在 async 函数内部使⽤</li>
</ol>
<p>async/await 相⽐于 promise 的优势与劣势</p>
<ol>
<li>代码读起来更加同步，Promise 虽然摆脱了回调地狱，但是 then 的链式调⽤也会带来额外的阅读负担</li>
<li>Promise 传递中间值⾮常麻烦，⽽ async/await ⼏乎是同步的写法，⾮常优雅</li>
<li>错误处理友好，async/await 可以⽤成熟的 try/catch，Promise 的错误捕获⾮常冗余</li>
<li>调试友好，Promise 的调试很差，由于没有代码块，你不能在⼀个返回表达式的箭头函数中设置断点，如果你在⼀个 <code>.then</code> 代码块中使⽤调试器的步进(step-over)功能，调试器并不会进⼊后续的 <code>.then</code> 代码块，因为调试器只能跟踪同步代码的『每⼀步』</li>
<li>多个异步代码变为同步，浪费性能</li>
</ol>
<h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><p><code>setTimeout</code> 、 <code>setInterval</code> 、 <code>requestAnimationFrame</code>，其中前两者的时间并不准确。但是最后 <code>requestAnimationFrame</code> 自带函数节流功能，基本可以保证 16.6 毫秒只执行一次，并且该函数的定时效果是精确的，不会有定时器时间不准的问题。</p>
<pre><code class="javascript">function mySetInterval(callback, interval) &#123;
  let timer
  const now = Date.now
  let startTime = now()
  let endTime = startTime

  const loop = () =&gt; &#123;
    timer = window.requestAnimationFrame(loop)
    endTime = now()
    if (endTime - startTime &gt;= interval) &#123;
      startTime = endTime = now()
      callback(timer)
    &#125;
  &#125;

  timer = window.requestAnimationFrame(loop)
  return timer
&#125;

let a = 0
mySetInterval(timer =&gt; &#123;
  console.log(&#39;1&#39;)
  a++
  if (a === 3) &#123;
    window.cancelAnimationFrame(timer)
  &#125;
&#125;, 1000)
</code></pre>
<h1 id="事件循环-Event-Loop"><a href="#事件循环-Event-Loop" class="headerlink" title="事件循环 (Event Loop)"></a>事件循环 (Event Loop)</h1><p>渲染 Renderer 进程的主要线程</p>
<ul>
<li>GUI 渲染线程</li>
<li>JS 引擎线程</li>
<li>事件触发线程</li>
<li>定时触发器线程</li>
<li>异步 http 请求线程</li>
</ul>
<p>常见的宏任务(<code>macrotask</code>)</p>
<ul>
<li>主代码块 <code>script</code></li>
<li>setTimeout</li>
<li>setInterval</li>
<li>setImmediate - Node</li>
<li>requestAnimationFrame - 浏览器</li>
</ul>
<p>常见微任务(<code>microtask</code>)</p>
<ul>
<li>process.nextTick() - Node</li>
<li>Promise.then()</li>
<li>catch</li>
<li>finally</li>
<li>Object.observe</li>
<li>MutationObserver</li>
</ul>
<p>具体步骤</p>
<ul>
<li>首先，整体的<code>script</code>(作为第一个宏任务)开始执行之前，会把所有代码分为同步任务、异步任务两部分，其中异步任务会再分为宏任务和微任务</li>
<li>同步任务会直接进入主线程依次执行</li>
<li>当主线程内的任务执行完毕，主线程为空时，会检查微任务，如果有任务，就<code>全部执行</code></li>
<li>执行完微任务，就渲染页面</li>
<li>开始下一轮 Event Loop，执行<code>下一个宏任务</code>（异步代码： <code>setTimeout</code> 诸如此类）</li>
</ul>
<blockquote>
<p>PS: 我们可以看到 <code>setTimeout</code> 等宏任务的回调函数在主线程执行，因此，回调函数的执行上下文（<code>this</code>）为 <code>window</code></p>
</blockquote>
<pre><code class="javascript">/**
 * Event loop（执行一个宏任务，执行所有微任务，再继续如此循环）
 * log:1,4,8,7,3,9,6,5,2
 */
;(function () &#123;
  function test() &#123;
    console.log(1)
    setTimeout(function () &#123;
      console.log(2)
    &#125;, 1000)
  &#125;

  test()

  setTimeout(function () &#123;
    Promise.resolve().then(() =&gt; &#123;
      console.log(9)
    &#125;)
    console.log(3)
  &#125;)

  new Promise(function (resolve) &#123;
    console.log(4)
    setTimeout(function () &#123;
      console.log(5)
    &#125;, 100)
    resolve()
  &#125;).then(function () &#123;
    setTimeout(function () &#123;
      console.log(6)
    &#125;, 0)
    console.log(7)
  &#125;)

  console.log(8)
&#125;)()
</code></pre>
<h1 id="手写-apply-、-call-、-bind-函数"><a href="#手写-apply-、-call-、-bind-函数" class="headerlink" title="手写 apply 、 call 、 bind 函数"></a>手写 <code>apply</code> 、 <code>call</code> 、 <code>bind</code> 函数</h1><pre><code class="javascript">/**
 * apply、call 的模拟实现，这两个方法被调用时，函数会立即执行，并返回结果
 */
Function.prototype.myCall = function (context) &#123;
  const context = context || window
  context.fn = this
  const args = []
  for (let i = 1; i &lt; arguments.length; i++) &#123;
    args.push(&#39;arguments[&#39; + i + &#39;]&#39;) // 由于后面会使用 eval 表达式，所以不能直接 push 具体的值
  &#125;
  const result = eval(&#39;context.fn(&#39; + args + &#39;)&#39;)
  delete context.fn
  return result
&#125;

Function.prototype.myApply = function (context, arr) &#123;
  const context = Object(context) || window
  context.fn = this
  let result
  if (!arr) &#123;
    result = context.fn()
  &#125; else &#123;
    const args = []
    for (let i = 0; i &lt; arr.length; i++) &#123;
      args.push(&#39;arr[&#39; + i + &#39;]&#39;)
    &#125;
    result = eval(&#39;context.fn(&#39; + args + &#39;)&#39;)
  &#125;
  delete context.fn
  return result
&#125;
/**
 * bind 的模拟实现。bind 方法会创建一个新函数，这个函数并不会立即执行。当这个新函数被调用时，bind的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。
 */
Function.prototype.myBind = function (context) &#123;
  if (typeof this !== &#39;function&#39;) &#123;
    throw new Error(&#39;Function.prototype.bind - what is trying to be bound is not callable&#39;)
  &#125;

  const self = this
  const args = Array.prototype.slice.call(arguments, 1) // 此处的 arguments 为 bind 时传递的参数
  const fNOP = function () &#123;&#125;

  const fbound = function () &#123;
    /**
     * 当作为构造函数时，this 指向实例，self 指向绑定函数，因为下面修改了 fbound.prototype 为 绑定函数的
     * prototype，此时结果为 true，当结果为 true 的时候，this 指向实例。
     *
     * 当作为普通函数时，this 指向 window，self 指向绑定函数，此时结果为 false，当结果为 false 的时候，
     * this 指向绑定的 context。
     */
    self.apply(this instanceof self ? this : context, args.concat(Array.prototype.slice.call(arguments))) // 此处的 arguments 返回的函数执行时的参数,两处参数合并起来成为 bind 函数完整的参数
  &#125;

  fNOP.prototype = this.prototype // 空函数中转，防止改变 fbound 函数的 prototype 时改变了原来函数的原型
  fbound.prototype = new fNOP()

  return fbound
&#125;
</code></pre>
<h1 id="new"><a href="#new" class="headerlink" title="new"></a>new</h1><p>new 过程中发生的四件事儿</p>
<ol>
<li>创建了一个空对象</li>
<li>链接到原型</li>
<li>绑定 this</li>
<li>返回对象</li>
</ol>
<pre><code class="javascript">/**
 * 模拟实现 new 操作。e.g. myNew(Person,18)
 * @returns 新对象
 */
function myNew() &#123;
  const obj = new Object(), // 用new Object() 的方式新建了一个对象 obj
    Constructor = [].shift.call(arguments) // 取出第一个参数，就是我们要传入的构造函数。此外因为 shift 会修改原数组，所以 arguments 会被去除第一个参数

  obj.__proto__ = Constructor.prototype

  // function Person(name, age) &#123;
  //   this.strength = 60
  //   this.age = age

  //   return &#123;
  //     name: name,
  //     habit: &#39;Games&#39;,
  //   &#125;
  // &#125;

  // var person = new Person(&#39;Kevin&#39;, &#39;18&#39;)

  // console.log(person.name) // Kevin
  // console.log(person.habit) // Games
  // console.log(person.strength) // undefined
  // console.log(person.age) // undefined

  const result = Constructor.apply(obj, arguments)

  return typeof result === &#39;object&#39; ? result : obj // 构造函数返回值如果是一个对象，就返回这个对象，如果不是，就该返回什么就返回什么
&#125;
</code></pre>
<h1 id="instanceof-原理"><a href="#instanceof-原理" class="headerlink" title="instanceof 原理"></a>instanceof 原理</h1><p>通过判断对象（<code>左边</code>）的原型链（<code>__proto__</code>）是不是能找到类型（<code>右边</code>）的 <code>prototype</code></p>
<pre><code class="javascript">/**
 * 自定义instanceof函数
 */
function myInstanceof(left, right) &#123;
  const prototype = right.prototype
  let left = left.__proto__

  while (true) &#123;
    if (left === null || left === undefined) &#123;
      return false
    &#125;

    if (prototype === left) &#123;
      return true
    &#125;

    left = left.__proto__
  &#125;
&#125;
</code></pre>
<h1 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h1><p>事件触发过程：</p>
<ol>
<li><code>window</code> 往<code>事件触发处</code>（通常来说就是目标 dom 元素）传播，遇到注册的捕获事件会触发</li>
<li>传播到事件触发处时触发注册的事件</li>
<li>从事件触发处往 <code>window</code> 传播，遇到注册的冒泡事件会触发</li>
</ol>
<blockquote>
<p>默认注册的就是冒泡事件，所以目标元素的事件触发后应该阻止冒泡</p>
</blockquote>
<p>但是，<strong>如果给 <code>body</code> 中的子节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行</strong></p>
<pre><code class="javascript">// 以下会先打印冒泡然后是捕获
node.addEventListener(
  &#39;click&#39;,
  event =&gt; &#123;
    console.log(&#39;冒泡&#39;)
  &#125;,
  false
)

node.addEventListener(
  &#39;click&#39;,
  event =&gt; &#123;
    console.log(&#39;捕获&#39;)
  &#125;,
  true
)
</code></pre>
<p><code>addEventListener</code> 注册事件，第三个参数可以是 <code>boolean</code> 或者 <code>object</code> ， 默认为 <code>false</code> ，可以冒泡，但是阻止捕获。</p>
<p>事件代理</p>
<pre><code class="html">&lt;ul id=&quot;ul&quot;&gt;
  &lt;li&gt;1&lt;/li&gt;
  &lt;li&gt;2&lt;/li&gt;
  &lt;li&gt;3&lt;/li&gt;
  &lt;li&gt;4&lt;/li&gt;
  &lt;li&gt;5&lt;/li&gt;
&lt;/ul&gt;

&lt;script&gt;
  var ul = document.querySelector(&#39;#ul&#39;)
  ul.addEventListener(&#39;click&#39;,(event) =&gt; &#123;
    console.log(event.target) // li1、li2、li3等等
  &#125;)
&lt;script&gt;
</code></pre>
<p>优点：</p>
<ul>
<li>节省内存</li>
<li>不需要给子节点注销事件</li>
</ul>
<h1 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h1><p>JSONP</p>
<pre><code class="javascript">/**
 * url 链接返回的是：[callbackName](&#123;code:0, data:[], msg: &#39;&#39;&#125;)
 * 在执行栈这个函数会立即执行
 */
const jsonp = (url, callbackName, success) =&gt; &#123;
  let script = document.createElement(&#39;script&#39;)
  script.src = url
  script.async = true
  script.type = &#39;text/script&#39;
  window[callbackName] = function (data) &#123;
    success &amp;&amp; success(data)
  &#125;
  document.body.appendChild(script)
&#125;

jsonp(&#39;https://xxx&#39;, &#39;callback&#39;, function (value) &#123;
  console.log(value)
&#125;)
</code></pre>
<h1 id="浏览器缓存机制"><a href="#浏览器缓存机制" class="headerlink" title="浏览器缓存机制"></a>浏览器缓存机制</h1><p>我们认为览器存在一个缓存数据库，用于储存一些不经常变化的静态文件（图片、css、js 等）。我们将缓存分为强制缓存和协商缓存。</p>
<p>强制缓存</p>
<p>当缓存数据库中已有所请求的数据时。客户端直接从缓存数据库中获取数据。当缓存数据库中没有所请求的数据时，客户端的才会从服务端获取数据。</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/11/29/16007be6f64ff7f7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="强制缓存"></p>
<p>服务器响应的 header 中会用两个字段来表明进行强制缓存——Expires 和 Cache-Control 。</p>
<ul>
<li>Exprires 的值为服务端返回的数据到期时间。当再次请求时的请求时间小于返回的此时间，则直接使用缓存数据。但由于服务端时间和客户端时间可能有误差，这也将导致缓存命中的误差，另一方面，Expires 是 HTTP1.0 的产物，故现在大多数使用 Cache-Control 替代。</li>
<li>Cache-Control 有很多属性，不同的属性代表的意义也不同。<ul>
<li>private：客户端可以缓存</li>
<li>public：客户端和代理服务器都可以缓存</li>
<li>max-age=t：缓存内容将在 t 秒后失效</li>
<li>no-cache：需要使用协商缓存来验证缓存数据</li>
<li>no-store：所有内容都不会缓存。</li>
</ul>
</li>
</ul>
<p>协商缓存</p>
<p>又称对比缓存，客户端会先从缓存数据库中获取到一个缓存数据的标识，得到标识后请求服务端验证是否失效（新鲜），如果没有失效服务端会返回 304，此时客户端直接从缓存中获取所请求的数据，如果标识失效，服务端会返回更新后的数据。</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/11/29/16007d1c835d5461?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="协商缓存"></p>
<blockquote>
<p>两类缓存机制可以同时存在，强制缓存的优先级高于协商缓存，当执行强制缓存时，如若缓存命中，则直接使用缓存数据库数据，不在进行缓存协商。</p>
</blockquote>
<p>协商缓存需要进行对比判断是否可以使用缓存。浏览器第一次请求数据时，服务器会将缓存标识与数据一起响应给客户端，客户端将它们备份至缓存中。再次请求时，客户端会将缓存中的标识发送给服务器，服务器根据此标识判断。若未失效，返回 304 状态码，浏览器拿到此状态码就可以直接使用缓存数据了。<br>对于协商缓存来说，缓存标识我们需要着重理解一下，下面我们将着重介绍它的两种缓存方案。</p>
<p>Last-Modified</p>
<p>Last-Modified： 服务器在响应请求时，会告诉浏览器资源的最后修改时间。</p>
<p>if-Modified-Since:<br>浏览器再次请求服务器的时候，请求头会包含此字段，后面跟着在缓存中获得的最后修改时间。服务端收到此请求头发现有 if-Modified-Since，则与被请求资源的最后修改时间进行对比，如果一致则返回 304 和响应报文头，浏览器只需要从缓存中获取信息即可。从字面上看，就是说：从某个时间节点算起，是否文件被修改了</p>
<ol>
<li>如果真的被修改：那么开始传输响应一个整体，服务器返回：200 OK</li>
<li>如果没有被修改：那么只需传输响应 header，服务器返回：304 Not Modified</li>
</ol>
<p>if-Unmodified-Since:<br>从字面上看, 就是说: 从某个时间点算起, 是否文件没有被修改</p>
<ol>
<li>如果没有被修改:则开始’继续’传送文件: 服务器返回: 200 OK</li>
<li>如果文件被修改:则不传输,服务器返回: 412 Precondition failed (预处理错误)</li>
</ol>
<p>这两个的区别是一个是修改了才下载一个是没修改才下载。Last-Modified 说好却也不是特别好，因为如果在服务器上，一个资源被修改了，但其实际内容根本没发生改变，会因为 Last-Modified 时间匹配不上而返回了整个实体给客户端（即使客户端缓存里有个一模一样的资源）。为了解决这个问题，HTTP1.1 推出了 Etag。</p>
<p>Etag<br>Etag：服务器响应请求时，通过此字段告诉浏览器当前资源在服务器生成的唯一标识（生成规则由服务器决定）</p>
<p>If-None-Match：再次请求服务器时，浏览器的请求报文头部会包含此字段，后面的值为在缓存中获取的标识。服务器接收到次报文后发现 If-None-Match 则与被请求资源的唯一标识进行对比。</p>
<ol>
<li>不同，说明资源被改动过，则响应整个资源内容，返回状态码 200。</li>
<li>相同，说明资源无心修改，则响应 header，浏览器直接从缓存中获取数据信息。返回状态码 304。</li>
</ol>
<p>但是实际应用中由于 Etag 的计算是使用算法来得出的，而算法会占用服务端计算的资源，所有服务端的资源都是宝贵的，所以就很少使用 Etag 了。</p>
<p>缓存的优点</p>
<ol>
<li>减少了冗余的数据传递，节省宽带流量</li>
<li>减少了服务器的负担，大大提高了网站性能</li>
<li>加快了客户端加载网页的速度 这也正是 HTTP 缓存属于客户端缓存的原因</li>
</ol>
<p>不同刷新的请求执行过程</p>
<ol>
<li>浏览器地址栏中写入 URL，回车，浏览器发现缓存中有这个文件了，不用继续请求了，直接去缓存拿（最快）</li>
<li>F5，就是告诉浏览器，别偷懒，好歹去服务器看看这个文件是否有过期了。于是浏览器就胆胆襟襟的发送一个请求带上 If-Modify-since。</li>
<li>Ctrl+F5，告诉浏览器，你先把你缓存中的这个文件给我删了，然后再去服务器请求个完整的资源文件下来。于是客户端就完成了强行更新的操作</li>
</ol>
<p>实际场景应用缓存策略</p>
<p>频繁变动的资源</p>
<p>首先使用 <code>Cache-control: no-cache</code> 使浏览器每次都请求服务器，然后配合 ETag 或者 Last-Modified 来验证资源是否有效。这样的做法虽然不能节省流量，但是能显著减小响应数据的大小</p>
<p>代码文件</p>
<p>这里指除了 html 外的代码文件，因为 html 文件一般不缓存或者缓存时间很短</p>
<p>给代码文件设置一年有效期： <code>Cache-Control: max-age=31536000</code> ，这样只有文件 hash 值发生变化才会去请求文件，否则一直使用缓存</p>
<h1 id="浏览器渲染原理"><a href="#浏览器渲染原理" class="headerlink" title="浏览器渲染原理"></a>浏览器渲染原理</h1><h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><ul>
<li>图片加载优化：不使用图片，CSS 代替（三角形等）；不同的分辨率裁剪不同的图片；小图用 base64；雪碧图</li>
<li>DNS 预解析 <code>&lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://xxxxx&quot;</code></li>
<li>防抖</li>
</ul>
<pre><code class="javascript">/**
 * 防抖：事件触发，N秒之后执行。期间再次触发，则重新计算
 */
const debounce = (fn, wait, immediate) =&gt; &#123;
  let timer

  const debounced = function (...args) &#123;
    timer &amp;&amp; clearTimeout(timer)
    if (immediate) &#123;
      const callNow = !timer

      if (callNow) &#123;
        fn.apply(this, args)
      &#125;

      timer = setTimeout(() =&gt; &#123;
        timer = null
      &#125;, wait)
    &#125; else &#123;
      timer = setTimeout(() =&gt; &#123;
        fn.apply(this, args)
      &#125;, wait)
    &#125;
  &#125;

  return debounced
&#125;
</code></pre>
<ul>
<li>节流</li>
</ul>
<pre><code class="javascript">/**
 * 节流：事件触发，马上执行，N秒之内，事件不再执行，N秒结束之时，再执行一次
 */
const throttle = (fn, wait) =&gt; &#123;
  let timer,
    previous = 0
  const throttled = function (...args) &#123;
    const now = +new Date()
    const remaining = wait - (now - previous)

    if (remaining &lt;= 0 || remaining &gt; wait) &#123;
      if (timer) &#123;
        clearTimeout(timer)
        timer = null
      &#125;
      previous = now
      fn.apply(this, args)
    &#125; else if (!timer) &#123;
      timer = setTimeout(() =&gt; &#123;
        fn.apply(this, args)
        previous = +new Date()
        timer = null
      &#125;, remaining)
    &#125;
  &#125;

  return throttled
&#125;
</code></pre>
<ul>
<li>预加载 <code>&lt;link rel=&quot;preload&quot; href=&quot;http://xxxxx&quot;</code></li>
<li>预渲染 <code>&lt;link rel=&quot;prerender&quot; href=&quot;http://xxxxx&quot;</code></li>
<li>懒执行，某些逻辑需要时再计算，可以用于首屏优化，因为某些逻辑并不会在首页用到。</li>
<li>懒加载</li>
<li>CDN</li>
</ul>
<h1 id="Webpack-性能优化"><a href="#Webpack-性能优化" class="headerlink" title="Webpack 性能优化"></a>Webpack 性能优化</h1><p>减少 webpack 打包时间</p>
<ul>
<li>优化 loader</li>
</ul>
<pre><code class="javascript">module.export = &#123;
  module: &#123;
    rules: [
      &#123;
        test: /\.js$/,
        loader: &#39;babel-loader?cacheDirectory=true&#39;, // 便以后的文件缓存起来
        include: [resolve(&#39;src&#39;)],
        exclude: &#39;/node_modules/&#39;,
      &#125;,
    ],
  &#125;,
&#125;
</code></pre>
<ul>
<li>HappyPack： node 是单线程的，webpack 也是单线程的，HappyPack 可以将 Loader 的同步执行转换为并行的</li>
<li>DllPlugin： DllPlugin 可以将特定的类库提前打包引入</li>
<li>代码压缩</li>
</ul>
<p>减小打包体积</p>
<ul>
<li>按需加载</li>
<li>Tree Shaking 摇树优化</li>
</ul>
<h1 id="从输入-URL-到页面渲染"><a href="#从输入-URL-到页面渲染" class="headerlink" title="从输入 URL 到页面渲染"></a>从输入 URL 到页面渲染</h1><ul>
<li>DNS 查询，通过域名找到 IP</li>
<li>建立 TCP 连接，TCP 三次握手</li>
<li>发送 HTTP 请求</li>
<li>服务端处理并响应</li>
<li>浏览器解析并渲染<ul>
<li>200 开始解析，302 重定向，500 报错</li>
<li>HTML 文件解析成 DOM 树，CSS 解析成 CSSDOM 树，遇到 script 标签，判断是否有 async 或 defer 字段，前者并行下载，后者先下载，延后执行，若没有，下载并执行，阻塞渲染进程。然后 DOM 树和 CSSDOM 树合并成为 Render 树，确定页面元素的布局和样式等等</li>
<li>调用 GPU 开始绘制，合成图层，显示在屏幕上</li>
</ul>
</li>
<li>断开连接，TCP 连接结束</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>给我买一杯咖啡</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/blog/uploads/images/wechat.JPG" alt="牧野ξ 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/blog/uploads/images/alipay.JPG" alt="牧野ξ 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/blog/tags/Javascript/" rel="tag"><i class="fa fa-tag"></i> Javascript</a>
              <a href="/blog/tags/Interview/" rel="tag"><i class="fa fa-tag"></i> Interview</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/blog/others-formulae-settings/" rel="prev" title="工具设置">
                  <i class="fa fa-chevron-left"></i> 工具设置
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/blog/others-miniprogram-ci/" rel="next" title="小程序 CI 工具使用教程">
                  小程序 CI 工具使用教程 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">牧野ξ</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/blog/js/comments.js"></script><script src="/blog/js/utils.js"></script><script src="/blog/js/motion.js"></script><script src="/blog/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/blog/js/third-party/search/local-search.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"chivesssss","repo":"blog","client_id":"c3cc68364f4467a2a082","client_secret":"980bc7da5a170dbc25288db00b6d74d5cbd3d392","admin_user":"chivesssss","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js","integrity":"sha256-Pmj85ojLaPOWwRtlMJwmezB/Qg8BzvJp5eTzvXaYAfA="},"path_md5":"dfeb3a06a95b56d8baf8e7e3e95eb0cf"}</script>
<script src="/blog/js/third-party/comments/gitalk.js"></script>

</body>
</html>
