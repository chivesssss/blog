<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>相关自定义函数</title>
    <url>/blog/interviews-custom-function/</url>
    <content><![CDATA[<span id="more"></span>

<pre><code class="javascript">;(function () &#123;
  // 一个函数无论我们 bind 几次， this 永远由第一次 bind 决定
  const a = &#123;&#125;
  const fn = function () &#123;
    console.log(this)
  &#125;
  fn.bind().bind(a)()

  // 换种写法
  const fn2 = function () &#123;
    return function () &#123;
      return fn.apply()
    &#125;.apply(a)
  &#125;
  fn2()
&#125;)()

// 闭包第一题
;(function () &#123;
  function createIncrement() &#123;
    let count = 0
    function increment() &#123;
      count++
    &#125;

    let message = `Count is $&#123;count&#125;`
    function log() &#123;
      console.log(message)
    &#125;

    return [increment, log]
  &#125;

  const [increment, log] = createIncrement()
  increment()
  increment()
  increment()
  log() // =&gt; ?
&#125;)()

// 闭包第二题
;(function () &#123;
  function fn() &#123;
    a = 0
    return function (b) &#123;
      return b + a++
    &#125;
  &#125;
  var f = fn()
  console.log(f(5)) // 5
  console.log(fn()(5)) // 5
  console.log(f(5)) // 6
  console.log(a) // 2
&#125;)()
;(function () &#123;
  /**
   * 简易版深拷贝函数
   */
  const deepClone = obj =&gt; &#123;
    if (typeof obj !== &#39;object&#39;) &#123;
      throw new Error(&#39;发生错误&#39;)
    &#125;

    const newObj = obj instanceof Array ? [] : &#123;&#125;

    for (const key in obj) &#123;
      if (Object.hasOwnProperty.call(obj, key)) &#123;
        const value = obj[key]
        newObj[key] = typeof value === &#39;object&#39; ? deepClone(value) : value
      &#125;
    &#125;
    return newObj
  &#125;
&#125;)()
;(function () &#123;
  // 变量提升转换前
  console.log(a) // undefined
  var a = 1
  function b() &#123;
    console.log(a)
  &#125;
  b() // 1

  // 变量提升转换前后
  var a = undefined
  console.log(a) // undefined
  a = 1
  function b() &#123;
    console.log(a)
  &#125;
  b() // 1
&#125;)()
;(function () &#123;
  /**
   * 组合继承：子类的构造函数中通过 Parent.call(this) 继承父类的属性，
   * 然后改变子类的原型为 new Parent() 来继承父类的函数
   */
  function Parent(value) &#123;
    this.value = value
  &#125;

  Parent.prototype.getValue = function () &#123;
    console.log(this.value)
  &#125;

  function Child(value) &#123;
    Parent.call(this, value) // 构造函数可以传参，不会与父类引用属性共享
  &#125;

  Child.prototype = new Parent() // 可以复用父类的函数，但是子类原型上多了不需要的父类的属性

  const child = new Child(1)

  child.getValue() // 1

  child instanceof Parent // true

  /**
   * Class 继承，关键点在于 extends、super
   */
  class Parent &#123;
    constructor(value) &#123;
      this.value = value
    &#125;

    getValue() &#123;
      console.log(this.value)
    &#125;
  &#125;

  class Child extends Parent &#123;
    constructor(value) &#123;
      super(value)
      this.value = value
    &#125;
  &#125;

  const child = new Child(1)

  child.getValue() // 1

  child instanceof Parent // true
&#125;)()
;(function () &#123;
  /**
   * 通过自定义 set 和 get 函数的方式，在原本的逻辑中插入了我们的函数
   * 逻辑（回调函数），实现了在对对象任何属性进行读写时发出通知
   */
  let obj = &#123; a: 1 &#125;

  let onWatch = (target, setCallback, getCallback) =&gt; &#123;
    return new Proxy(target, &#123;
      set(target, key, value, receiver) &#123;
        setCallback(key, value)
        return Reflect.set(target, key, value, receiver)
      &#125;,
      get(target, key, receiver) &#123;
        getCallback(target, key)

        // return target[key]
        return Reflect.get(target, key, receiver)
      &#125;,
    &#125;)
  &#125;

  let p = onWtch(
    obj,
    (k, v) =&gt; &#123;
      // 数据变化，响应式监听
      console.log(`监测到属性$&#123;k&#125;改变为$&#123;v&#125;`)
    &#125;,
    (t, k) =&gt; &#123;
      // 数据读取，响应式派发
      console.log(`&#39;$&#123;k&#125;&#39; = $&#123;t[k]&#125;`)
    &#125;
  )

  p.a = 3 // 监测到属性a改变为3
  p.a // &#39;a&#39; = 3
&#125;)()
;(function () &#123;
  /**
   * 手写 Promise
   * 作用：1、消灭嵌套调用；2、合并多个任务的请求结果
   * API： Promise.resolve, Promise.reject, Promise.prototype.catch,
   * Promise.prototype.finally, Promise.all, Promise.race
   */
  const PENDING = &#39;pending&#39;
  const RESOLVED = &#39;resolved&#39;
  const REJECTED = &#39;rejected&#39;
  function MyPromise(executor) &#123;
    this.status = PENDING
    this.value = undefined
    this.reason = undefined

    this.onResolvedCallbacks = []
    this.onRejectedCallbacks = []

    const resolve = value =&gt; &#123;
      if (this.status === PENDING) &#123;
        this.value = value
        this.status = RESOLVED

        this.onResolvedCallbacks.forEach(fn =&gt; fn())
      &#125;
    &#125;

    const reject = reason =&gt; &#123;
      if (this.status === PENDING) &#123;
        this.reason = reason
        this.status = REJECTED

        this.onRejectedCallbacks.forEach(fn =&gt; fn())
      &#125;
    &#125;

    try &#123;
      executor(resolve, reject)
    &#125; catch (error) &#123;
      reject(error)
    &#125;
  &#125;

  MyPromise.prototype.then = function (onResolved, onRejected) &#123;
    onResolved = typeof onResolved === &#39;function&#39; ? onResolved : v =&gt; v
    onRejected =
      typeof onRejected === &#39;function&#39;
        ? onRejected
        : err =&gt; &#123;
            throw err
          &#125;

    if (this.status === RESOLVED) &#123;
      onResolved(this.value)
    &#125;

    if (this.status === REJECTED) &#123;
      onRejected(this.reason)
    &#125;

    if (this.status === PENDING) &#123;
      this.onResolvedCallbacks.push(() =&gt; &#123;
        onResolved(this.value)
      &#125;)

      this.onRejectedCallbacks.push(() =&gt; &#123;
        onRejected(this.reason)
      &#125;)
    &#125;
  &#125;
&#125;)()
;(function () &#123;
  function mySetInterval(callback, interval) &#123;
    let timer
    const now = Date.now
    let startTime = now()
    let endTime = startTime

    const loop = () =&gt; &#123;
      timer = window.requestAnimationFrame(loop)
      endTime = now()
      if (endTime - startTime &gt;= interval) &#123;
        startTime = endTime = now()
        callback(timer)
      &#125;
    &#125;

    timer = window.requestAnimationFrame(loop)
    return timer
  &#125;

  let a = 0
  mySetInterval(timer =&gt; &#123;
    console.log(&#39;1&#39;)
    a++
    if (a === 3) &#123;
      window.cancelAnimationFrame(timer)
    &#125;
  &#125;, 1000)
&#125;)()
;(function () &#123;
  /**
   * Event loop（执行一个宏任务，执行所有微任务，再继续如此循环）
   * log:1,4,8,7,3,9,6,5,2
   */
  ;(function () &#123;
    function test() &#123;
      console.log(1)
      setTimeout(function () &#123;
        console.log(2)
      &#125;, 1000)
    &#125;

    test()

    setTimeout(function () &#123;
      Promise.resolve().then(() =&gt; &#123;
        console.log(9)
      &#125;)
      console.log(3)
    &#125;)

    new Promise(function (resolve) &#123;
      console.log(4)
      setTimeout(function () &#123;
        console.log(5)
      &#125;, 100)
      resolve()
    &#125;).then(function () &#123;
      setTimeout(function () &#123;
        console.log(6)
      &#125;, 0)
      console.log(7)
    &#125;)

    console.log(8)
  &#125;)()
&#125;)()
;(function () &#123;
  /**
   * apply、call 的模拟实现，这两个方法被调用时，函数会立即执行，并返回结果
   */
  Function.prototype.myCall = function (context) &#123;
    const context = context || window
    context.fn = this
    const args = []
    for (let i = 1; i &lt; arguments.length; i++) &#123;
      args.push(&#39;arguments[&#39; + i + &#39;]&#39;) // 由于后面会使用 eval 表达式，所以不能直接 push 具体的值
    &#125;
    const result = eval(&#39;context.fn(&#39; + args + &#39;)&#39;)
    delete context.fn
    return result
  &#125;

  Function.prototype.myApply = function (context, arr) &#123;
    const context = Object(context) || window
    context.fn = this
    let result
    if (!arr) &#123;
      result = context.fn()
    &#125; else &#123;
      const args = []
      for (let i = 0; i &lt; arr.length; i++) &#123;
        args.push(&#39;arr[&#39; + i + &#39;]&#39;)
      &#125;
      result = eval(&#39;context.fn(&#39; + args + &#39;)&#39;)
    &#125;
    delete context.fn
    return result
  &#125;
  /**
   * bind 的模拟实现。bind 方法会创建一个新函数，这个函数并不会立即执行。当这个新函数被调用时，bind的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。
   */
  Function.prototype.myBind = function (context) &#123;
    if (typeof this !== &#39;function&#39;) &#123;
      throw new Error(&#39;Function.prototype.bind - what is trying to be bound is not callable&#39;)
    &#125;

    const self = this
    const args = Array.prototype.slice.call(arguments, 1) // 此处的 arguments 为 bind 时传递的参数
    const fNOP = function () &#123;&#125;

    const fbound = function () &#123;
      /**
       * 当作为构造函数时，this 指向实例，self 指向绑定函数，因为下面修改了 fbound.prototype 为 绑定函数的
       * prototype，此时结果为 true，当结果为 true 的时候，this 指向实例。
       *
       * 当作为普通函数时，this 指向 window，self 指向绑定函数，此时结果为 false，当结果为 false 的时候，
       * this 指向绑定的 context。
       */
      self.apply(this instanceof self ? this : context, args.concat(Array.prototype.slice.call(arguments))) // 此处的 arguments 返回的函数执行时的参数,两处参数合并起来成为 bind 函数完整的参数
    &#125;

    fNOP.prototype = this.prototype // 空函数中转，防止改变 fbound 函数的 prototype 时改变了原来函数的原型
    fbound.prototype = new fNOP()

    return fbound
  &#125;
&#125;)()
;(function () &#123;
  /**
   * 模拟实现 new 操作。e.g. myNew(Person,18)
   * @returns 新对象
   */
  function myNew() &#123;
    const obj = new Object(), // 用new Object() 的方式新建了一个对象 obj
      Constructor = [].shift.call(arguments) // 取出第一个参数，就是我们要传入的构造函数。此外因为 shift 会修改原数组，所以 arguments 会被去除第一个参数

    obj.__proto__ = Constructor.prototype

    // function Person(name, age) &#123;
    //   this.strength = 60
    //   this.age = age

    //   return &#123;
    //     name: name,
    //     habit: &#39;Games&#39;,
    //   &#125;
    // &#125;

    // var person = new Person(&#39;Kevin&#39;, &#39;18&#39;)

    // console.log(person.name) // Kevin
    // console.log(person.habit) // Games
    // console.log(person.strength) // undefined
    // console.log(person.age) // undefined

    const result = Constructor.apply(obj, arguments)

    return typeof result === &#39;object&#39; ? result : obj // 构造函数返回值如果是一个对象，就返回这个对象，如果不是，就该返回什么就返回什么
  &#125;
&#125;)()
;(function () &#123;
  /**
   * 自定义instanceof函数
   */
  function myInstanceof(left, right) &#123;
    const prototype = right.prototype
    let left = left.__proto__

    while (true) &#123;
      if (left === null || left === undefined) &#123;
        return false
      &#125;

      if (prototype === left) &#123;
        return true
      &#125;

      left = left.__proto__
    &#125;
  &#125;
&#125;)()
;(function () &#123;
  // 以下会先打印冒泡然后是捕获
  node.addEventListener(
    &#39;click&#39;,
    event =&gt; &#123;
      console.log(&#39;冒泡&#39;)
    &#125;,
    false
  )

  node.addEventListener(
    &#39;click&#39;,
    event =&gt; &#123;
      console.log(&#39;捕获&#39;)
    &#125;,
    true
  )
&#125;)()
;(function () &#123;
  /**
   * url 链接返回的是：[callbackName](&#123;code:0, data:[], msg: &#39;&#39;&#125;)
   * 在执行栈这个函数会立即执行
   */
  const jsonp = (url, callbackName, success) =&gt; &#123;
    let script = document.createElement(&#39;script&#39;)
    script.src = url
    script.async = true
    script.type = &#39;text/script&#39;
    window[callbackName] = function (data) &#123;
      success &amp;&amp; success(data)
    &#125;
    document.body.appendChild(script)
  &#125;

  jsonp(&#39;https://xxx&#39;, &#39;callback&#39;, function (value) &#123;
    console.log(value)
  &#125;)
&#125;)()
;(function () &#123;
  /**
   * 防抖：事件触发，N秒之后执行。期间再次触发，则重新计算
   */
  const debounce = (fn, wait, immediate) =&gt; &#123;
    let timer

    const debounced = function (...args) &#123;
      timer &amp;&amp; clearTimeout(timer)
      if (immediate) &#123;
        const callNow = !timer

        if (callNow) &#123;
          fn.apply(this, args)
        &#125;

        timer = setTimeout(() =&gt; &#123;
          timer = null
        &#125;, wait)
      &#125; else &#123;
        timer = setTimeout(() =&gt; &#123;
          fn.apply(this, args)
        &#125;, wait)
      &#125;
    &#125;

    return debounced
  &#125;
&#125;)()
;(function () &#123;
  /**
   * 节流：事件触发，马上执行，N秒之内，事件不再执行，N秒结束之时，再执行一次
   */
  const throttle = (fn, wait) =&gt; &#123;
    let timer,
      previous = 0
    const throttled = function (...args) &#123;
      const now = +new Date()
      const remaining = wait - (now - previous)

      if (remaining &lt;= 0 || remaining &gt; wait) &#123;
        if (timer) &#123;
          clearTimeout(timer)
          timer = null
        &#125;
        previous = now
        fn.apply(this, args)
      &#125; else if (!timer) &#123;
        timer = setTimeout(() =&gt; &#123;
          fn.apply(this, args)
          previous = +new Date()
          timer = null
        &#125;, remaining)
      &#125;
    &#125;

    return throttled
  &#125;
&#125;)()
;(function () &#123;
  // 通过Dep解耦属性的依赖和更新操作
  class Dep &#123;
    constructor() &#123;
      this.subs = []
    &#125;
    // 收集依赖
    add(sub) &#123;
      this.subs.push(sub)
    &#125;
    // 通知更新
    notify() &#123;
      this.subs.forEach(sub =&gt; &#123;
        sub.update()
      &#125;)
    &#125;
  &#125;
  Dep.target = null // 全局属性，通过该属性配置watcher

  class Watcher &#123;
    constructor(obj, key, callback) &#123;
      // 将 Dep.target 指向自己
      // 然后触发属性的 getter 触发监听
      // 最后将 Dep.target 置为空
      Dep.target = this
      this.callback = callback
      this.obj = obj
      this.key = key
      this.val = obj[key]
      Dep.target = null
    &#125;

    update() &#123;
      // 获得最新值
      this.val = this.obj[this.key]
      // 调用 update 方法 更新 dom
      this.callback(this.val)
    &#125;
  &#125;

  // 观察、监听
  function observe(obj) &#123;
    if (!obj || typeof obj !== &#39;object&#39;) &#123;
      return
    &#125;

    Object.keys(obj).forEach(key =&gt; &#123;
      defineReactive(obj, key, obj[key])
    &#125;)
  &#125;
  function defineReactive(obj, key, val) &#123;
    // 递归子属性
    observe(val)
    let dp = new Dep()

    Object.defineProperty(obj, key, &#123;
      enumerable: true, // 可枚举
      configurable: true, // 可配置
      // 自定义函数
      set: function reactiveSetter(newVal) &#123;
        val = newVal
        dp.notify() // 值变了以后才去通知
      &#125;,
      get: function reactiveGetter() &#123;
        if (Dep.target) &#123;
          // 只有在实例化watcher的时候依赖才会被添加进去
          dp.add(Dep.target)
        &#125;
        return val
      &#125;,
    &#125;)
  &#125;

  var data = &#123; name: &#39;xiaoming&#39; &#125;
  observe(data)
  function update(value) &#123;
    console.log(`watch 到新的值：$&#123;value&#125;`)
  &#125;

  new Watcher(data, &#39;name&#39;, update)

  data.name = &#39;xiaowang&#39;
&#125;)()
;(function () &#123;
  // 给 localstorage 设置过期时间
  Storage.prototype.setExpire = (key, value, expire) =&gt; &#123;
    let obj = &#123;
      data: value,
      time: Date.now(),
      expire: expire,
    &#125;
    localStorage.setItem(key, JSON.stringify(obj))
  &#125;

  Storage.prototype.getExpire = key =&gt; &#123;
    let val = localStorage.getItem(key)
    if (!val) &#123;
      return val
    &#125;
    val = JSON.parse(val)
    if (Date.now() - val.time &gt; val.expire) &#123;
      localStorage.removeItem(key)
      return null
    &#125;
    return val.data
  &#125;
&#125;)()
</code></pre>
]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>function</tag>
      </tags>
  </entry>
  <entry>
    <title>前端（掘金小册）</title>
    <url>/blog/interviews-juejin-front-end-interview/</url>
    <content><![CDATA[<h3 id="小册食用指南"><a href="#小册食用指南" class="headerlink" title="小册食用指南"></a>小册食用指南</h3><p>整本小册涉及到了十四个模块，每一模块中又包含了许许多多的知识点。每一模块都自成体系但是又会与其他模块中的内容有交集。比如说浏览器、Webpack、网络协议这几个模块中涉及到的部分内容和性能优化模块是相互关联的。</p>
<p>如果你是刚刚开始阅读小册的内容，可以根据自己的薄弱点，对症下药，学习相应的模块。但是学习单个模块中的内容时不推荐跳着阅读，因为很可能后面的内容与之前的有所联系，没有理解之前的知识点的话，可能会对后续的学习会造成困扰。</p>
<span id="more"></span>

<p><img src="./JS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E5%8F%8A%E5%B8%B8%E8%80%83%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89.png" alt="JS 基础知识点及常考面试题（一）"><br><img src="./JS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E5%8F%8A%E5%B8%B8%E8%80%83%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89.png" alt="JS 基础知识点及常考面试题（二）"><br><img src="./ES6%E7%9F%A5%E8%AF%86%E7%82%B9%E5%8F%8A%E5%B8%B8%E8%80%83%E9%9D%A2%E8%AF%95%E9%A2%98.png" alt="ES6知识点及常考面试题"><br><img src="./JS%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E5%8F%8A%E5%B8%B8%E8%80%83%E9%9D%A2%E8%AF%95%E9%A2%98.png" alt="JS异步编程及常考面试题"><br><img src="./%E6%89%8B%E5%86%99Promise.png" alt="手写Promise"><br><img src="./%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFEventLoop.png" alt="事件循环EventLoop"><br><img src="./JS%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86%E7%82%B9%E5%8F%8A%E5%B8%B8%E8%80%83%E9%9D%A2%E8%AF%95%E9%A2%98.png" alt="JS进阶知识点及常考面试题"><br><img src="./JS%E6%80%9D%E8%80%83%E9%A2%98.png" alt="JS思考题"><br><img src="./DevToolsTips.png" alt="DevToolsTips"><br><img src="./%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E5%8F%8A%E5%B8%B8%E8%80%83%E9%9D%A2%E8%AF%95%E9%A2%98.png" alt="浏览器基础知识点及常考面试题"><br><img src="./%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6.png" alt="浏览器缓存机制"><br><img src="./%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86.png" alt="浏览器渲染原理"><br><img src="./%E5%AE%89%E5%85%A8%E9%98%B2%E8%8C%83%E7%9F%A5%E8%AF%86%E7%82%B9.png" alt="安全防范知识点"><br><img src="./%E4%BB%8EV8%E4%B8%AD%E7%9C%8BJS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.png" alt="从V8中看JS性能优化"><br><img src="./%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%90%90%E7%A2%8E%E4%BA%8B.png" alt="性能优化琐碎事"><br><img src="./Webpack%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.png" alt="Webpack性能优化"><br><img src="./%E5%AE%9E%E7%8E%B0%E5%B0%8F%E5%9E%8B%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7.png" alt="实现小型打包工具"><br><img src="./React%E5%92%8CVue%E4%B8%A4%E5%A4%A7%E6%A1%86%E6%9E%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%B8%E7%88%B1%E7%9B%B8%E6%9D%80.png" alt="React和Vue两大框架之间的相爱相杀"><br><img src="./Vue%E5%B8%B8%E8%80%83%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9.png" alt="Vue常考基础知识点"><br><img src="./Vue%E5%B8%B8%E8%80%83%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86%E7%82%B9.png" alt="Vue常考进阶知识点"><br><img src="./React%E5%B8%B8%E8%80%83%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9.png" alt="React常考基础知识点"><br><img src="./React%E5%B8%B8%E8%80%83%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86%E7%82%B9.png" alt="React常考进阶知识点"><br><img src="./%E7%9B%91%E6%8E%A7.png" alt="监控"><br><img src="./UDP.png" alt="UDP"><br><img src="./TCP.png" alt="TCP"><br><img src="./HTTP%E5%8F%8ATLS.png" alt="HTTP及TLS"><br><img src="./HTTP/2%E5%8F%8AHTTP/3.png" alt="HTTP/2及HTTP/3"><br><img src="./%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E7%9A%84%E6%95%B4%E4%B8%AA%E6%B5%81%E7%A8%8B.png" alt="输入URL到页面渲染的整个流程"><br><img src="./%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png" alt="设计模式"><br><img src="./%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="常见数据结构"><br><img src="./%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842.png" alt="常见数据结构2"><br><img src="./%E5%B8%B8%E8%80%83%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%E6%9E%90.png" alt="常考算法题解析"><br><img src="./%E5%B8%B8%E8%80%83%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3%E6%9E%902.png" alt="常考算法题解析2"><br><img src="./CSS%E5%B8%B8%E8%80%83%E9%9D%A2%E8%AF%95%E9%A2%98%E8%B5%84%E6%96%99.png" alt="CSS常考面试题资料"><br><img src="./%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BD%E4%B8%80%E5%B0%81%E7%AE%80%E5%8E%86.png" alt="如何写好一封简历"><br><img src="./%E9%9D%A2%E8%AF%95%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7.png" alt="面试常用技巧"></p>
]]></content>
  </entry>
  <entry>
    <title>Axios 请求二次重发</title>
    <url>/blog/javascript-axios-request-resend/</url>
    <content><![CDATA[<h1 id="定义相关变量与函数"><a href="#定义相关变量与函数" class="headerlink" title="定义相关变量与函数"></a>定义相关变量与函数</h1><p>定义 Axios 的 <code>baseUrl</code></p>
<pre><code class="javascript">const BASE_URL = process.env.VUE_APP_BASEURL
</code></pre>
<p>定义 <code>Token</code> 的刷新状态</p>
<pre><code class="javascript">let isRefreshing = false
</code></pre>
<p>定义 <code>Token</code> 失效后，发送的请求的容器 – 缓存接口</p>
<pre><code class="javascript">let subscribers = []
</code></pre>
<span id="more"></span>

<p>定义函数， 刷新 <code>Token</code> 后, 将缓存的接口重新请求一次，请求发送以后，清空容器</p>
<pre><code class="javascript">function onAccessTokenFetched(newToken) &#123;
  subscribers.forEach(callback =&gt; &#123;
    callback(newToken)
  &#125;)
  // 清空缓存接口
  subscribers = []
&#125;
</code></pre>
<p>定义函数，添加请求失败的接口到容器中</p>
<pre><code class="javascript">function addSubscriber(callback) &#123;
  subscribers.push(callback)
&#125;
</code></pre>
<h1 id="Axios-拦截器配置"><a href="#Axios-拦截器配置" class="headerlink" title="Axios 拦截器配置"></a>Axios 拦截器配置</h1><pre><code class="javascript">import &#123; getUserToken &#125; from &#39;your/api/path&#39;

axios.interceptors.response.use(
  response =&gt; &#123;
    console.log(&#39;response :&gt;&gt; &#39;, response)

    // &#123;
    //   config: &#123;
    //     headers: &#123;
    //       Authorization: &#39;&#39;
    //     &#125;
    //     method: &#39;&#39;,
    //     url: &#39;&#39;
    //   &#125;,
    //   data: &#123;&#125;,
    //   status: 200,
    //   statusText: &#39;OK&#39;
    // &#125;

    if (response.status === 200) &#123;
      if (response.data.code === 0) &#123;
        return response.data.data
      &#125;

      return Promise.reject(new Error(response.data.msg))
    &#125; else if (response.status === 401) &#123;
      /**
       * 将未授权接口缓存起来。retryOriginalRequest 这个 Promise 函数很关键，它一直处于等待状态。
       * 只有当 token 刷新成功后，onAccessTokenFetched 这个函数执行了回调函数，返回了 resolve 状态
       */
      const retryOriginalRequest = new Promise(resolve =&gt; &#123;
        addSubscriber(newToken =&gt; &#123;
          resolve(
            axios.request(&#123;
              ...response.config,
              headers: &#123;
                ...response.config.headers,
                Authorization: newToken,
              &#125;,
            &#125;)
          )
        &#125;)
      &#125;)

      // 无感刷新Token
      if (!isRefreshing) &#123;
        isRefreshing = true

        getUserToken(&#123;
          grant_type: &#39;refresh_token&#39;,
          refresh_token: localStorage.getItem(&#39;SYS_REFRESH_TOKEN&#39;),
          scope: &#39;server&#39;,
        &#125;)
          .then(refreshRes =&gt; &#123;
            const newToken = `$&#123;refreshRes[&#39;token_type&#39;]&#125; $&#123;refreshRes[&#39;access_token&#39;]&#125;`
            const newRefreshToken = refreshRes[&#39;refresh_token&#39;]
            localStorage.setItem(&#39;SYS_TOKEN&#39;, newToken)
            localStorage.setItem(&#39;SYS_REFRESH_TOKEN&#39;, newRefreshToken)

            // 当刷新成功后, 重新发送缓存请求
            onAccessTokenFetched(newToken)
          &#125;)
          .catch(() =&gt; &#123;
            // 刷新token报错的话, 就需要跳转到登录页面
            localStorage.setItem(&#39;SYS_TOKEN&#39;, &#39;&#39;)
            localStorage.setItem(&#39;SYS_REFRESH_TOKEN&#39;, &#39;&#39;)

            window.location.href = &#39;/login&#39;
          &#125;)
          .finally(() =&gt; &#123;
            isRefreshing = false
          &#125;)
      &#125;

      return retryOriginalRequest
    &#125; else &#123;
      return Promise.reject(new Error(response.statusText))
    &#125;
  &#125;,
  error =&gt; &#123;
    return Promise.reject(new Error(error))
  &#125;
)
</code></pre>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Vue</tag>
        <tag>Axios</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6 Class 封装原生 Websocket</title>
    <url>/blog/javascript-es6-websocket/</url>
    <content><![CDATA[<pre><code class="javascript">import &#123; getToken &#125; from &#39;@/util/auth&#39;
/**
 * 心跳基类
 */
export class Heart &#123;
  HEART_TIMEOUT = null // 心跳计时器
  SERVER_HEART_TIMEOUT = null // 心跳计时器

  constructor() &#123;
    this.timeout = 5000
  &#125;
  // 重置
  reset() &#123;
    clearTimeout(this.HEART_TIMEOUT)
    clearTimeout(this.SERVER_HEART_TIMEOUT)
    return this
  &#125;
  /**
   * 启动心跳
   * @param &#123;Function&#125; cb 回调函数
   */
  start(cb) &#123;
    this.HEART_TIMEOUT = setTimeout(() =&gt; &#123;
      cb()
      this.SERVER_HEART_TIMEOUT = setTimeout(() =&gt; &#123;
        cb()
        // 重新开始检测
        this.reset().start(cb())
      &#125;, this.timeout)
    &#125;, this.timeout)
  &#125;
&#125;
</code></pre>
<span id="more"></span>

<pre><code class="javascript">export class Socket extends Heart &#123;
  ws = null

  RECONNEC_TTIMER = null // 重连计时器
  RECONNECT_COUNT = 10 // 变量保存，防止丢失

  OPTIONS = &#123;
    url: `ws://dev.api.ucthings.com/websocket/api/ws/plugins/telemetry?Blade-Auth=bearer $&#123;getToken()&#125;`, // 链接的通道的地址
    heartTime: 5000, // 心跳时间间隔
    heartMsg: &#39;ping&#39;, // 心跳信息,默认为&#39;ping&#39;
    isReconnect: true, // 是否自动重连
    isRestory: false, // 是否销毁
    reconnectTime: 2000, // 重连时间间隔
    reconnectCount: 5, // 重连次数 -1 则不限制
    openCb: null, // 连接成功的回调
    closeCb: null, // 关闭的回调
    messageCb: null, // 消息的回调
    errorCb: null, // 错误的回调
  &#125;
  constructor(ops) &#123;
    super()
    Object.assign(this.OPTIONS, ops)
    this.create()
  &#125;
  /**
   * 建立连接
   */
  create() &#123;
    if (!(&#39;WebSocket&#39; in window)) &#123;
      /* eslint-disable no-new */
      new Error(&#39;当前浏览器不支持，无法使用&#39;)
      return
    &#125;
    if (!this.OPTIONS.url) &#123;
      new Error(&#39;地址不存在，无法建立通道&#39;)
      return
    &#125;
    delete this.ws
    this.ws = new WebSocket(this.OPTIONS.url)
    this.onopen()
    this.onclose()
    this.onmessage()
  &#125;
  /**
   * 自定义连接成功事件
   * 如果callback存在，调用callback，不存在调用OPTIONS中的回调
   * @param &#123;Function&#125; callback 回调函数
   */
  onopen(callback) &#123;
    this.ws.onopen = event =&gt; &#123;
      clearTimeout(this.RECONNEC_TTIMER) // 清除重连定时器
      // 建立心跳机制
      super.reset().start(() =&gt; &#123;
        this.send(this.OPTIONS.heartMsg)
      &#125;)
      if (typeof callback === &#39;function&#39;) &#123;
        callback(event)
      &#125; else &#123;
        typeof this.OPTIONS.openCb === &#39;function&#39; &amp;&amp; this.OPTIONS.openCb(event)
      &#125;
    &#125;
  &#125;
  /**
   * 自定义关闭事件
   * 如果callback存在，调用callback，不存在调用OPTIONS中的回调
   * @param &#123;Function&#125; callback 回调函数
   */
  onclose(callback) &#123;
    this.ws.onclose = event =&gt; &#123;
      super.reset()
      if (!this.OPTIONS.isRestory) &#123;
        Object.assign(this.OPTIONS, &#123;
          url: `ws://dev.api.ucthings.com/websocket/api/ws/plugins/telemetry?Blade-Auth=bearer $&#123;getToken()&#125;`, // 链接的通道的地址
        &#125;)
        this.onreconnect()
      &#125;

      if (typeof callback === &#39;function&#39;) &#123;
        callback(event)
      &#125; else &#123;
        typeof this.OPTIONS.closeCb === &#39;function&#39; &amp;&amp; this.OPTIONS.closeCb(event)
      &#125;
    &#125;
  &#125;
  /**
   * 自定义错误事件
   * 如果callback存在，调用callback，不存在调用OPTIONS中的回调
   * @param &#123;Function&#125; callback 回调函数
   */
  onerror(callback) &#123;
    this.ws.onerror = event =&gt; &#123;
      if (typeof callback === &#39;function&#39;) &#123;
        callback(event)
      &#125; else &#123;
        typeof this.OPTIONS.errorCb === &#39;function&#39; &amp;&amp; this.OPTIONS.errorCb(event)
      &#125;
    &#125;
  &#125;
  /**
   * 自定义消息监听事件
   * 如果callback存在，调用callback，不存在调用OPTIONS中的回调
   * @param &#123;Function&#125; callback 回调函数
   */
  onmessage(callback) &#123;
    this.ws.onmessage = event =&gt; &#123;
      // 收到任何消息，重新开始倒计时心跳检测
      super.reset().start(() =&gt; &#123;
        this.send(this.OPTIONS.heartMsg)
      &#125;)

      this.OPTIONS.reconnectCount = this.RECONNECT_COUNT // 计数器重置

      if (typeof callback === &#39;function&#39;) &#123;
        callback(event.data)
      &#125; else &#123;
        typeof this.OPTIONS.messageCb === &#39;function&#39; &amp;&amp; this.OPTIONS.messageCb(event.data)
      &#125;
    &#125;
  &#125;
  /**
   * 自定义发送消息事件
   * @param &#123;String&#125; data 发送的文本
   */
  send(data) &#123;
    if (this.ws.readyState !== this.ws.OPEN) &#123;
      new Error(&#39;没有连接到服务器，无法推送&#39;)
      return
    &#125;
    this.ws.send(data)
  &#125;
  /**
   * 连接事件
   */
  onreconnect() &#123;
    if (this.OPTIONS.reconnectCount &gt; 0 || this.OPTIONS.reconnectCount === -1) &#123;
      this.RECONNEC_TTIMER = setTimeout(() =&gt; &#123;
        this.create()
        if (this.OPTIONS.reconnectCount !== -1) this.OPTIONS.reconnectCount--
      &#125;, this.OPTIONS.reconnectTime)
    &#125; else &#123;
      clearTimeout(this.RECONNEC_TTIMER)
      this.OPTIONS.reconnectCount = this.RECONNECT_COUNT
    &#125;
  &#125;
  /**
   * 销毁
   */
  destroy() &#123;
    super.reset()
    clearTimeout(this.RECONNEC_TTIMER) // 清除重连定时器
    this.OPTIONS.isRestory = true
    this.ws.close()
  &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>ECMAScript 6</tag>
        <tag>Websocket</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈 apply()方法与 call()方法</title>
    <url>/blog/javascript-javascript-function-apply-call/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol>
<li><p>在 JavaScript 中，函数就是一个对象，函数在没有返回值时默认返回一个对象。</p>
</li>
<li><p>当一个对象 <strong>A（this object）</strong> 没有某个方法，但是其他对象 <strong>B（other object）</strong> 有这一方法，我们可以借助 <code>call()</code> 方法或 <code>apply()</code> 方法，用其它对象 <strong>B（other object）</strong> 的方法来操作。<code>apply()</code> 方法与 <code>call()</code> 方法的第一个参数是对象 <strong>A（this object）</strong> ，第二个参数为传递给对象 <strong>B（other object）</strong> 的该方法的参数。</p>
</li>
<li><p>形式为：<code>B.fn.apply(A,[arguments])</code> 或者 <code>B.fn.call(A,arg1,arg2,arg3……)</code></p>
</li>
</ol>
<span id="more"></span>

<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="js">function person() &#123;&#125;
person.prototype = &#123;
  name: &#39;jack&#39;,
  say: function () &#123;
    console.log(&#39;my name is&#39; + this.name)
  &#125;,
&#125;
var goodPerson = new person()
goodPerson.say() // 打印 my name is jack

// 现在有一个对象 dog = &#123;name:&#39;wangwang&#39;&#125;,
// 这条狗也想说话（拥有 say 方法），
// 那么我们可以这样 goodPerson.say.call(dog) 这样 dog 就可以说话了。

var dog = &#123;
  name: &#39;wangwang&#39;,
&#125;
goodPerson.say.apply(dog) // my name is wangwang

goodPerson.say.call(dog) // my name is wangwang
</code></pre>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Typescript 学习笔记</title>
    <url>/blog/javascript-typescript-doc/</url>
    <content><![CDATA[<h1 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h1><h2 id="定义数组"><a href="#定义数组" class="headerlink" title="定义数组"></a>定义数组</h2><pre><code class="ts">let list: number[] = [1, 2, 3] // 元素类型后面接上 []
// 或者 数组泛型
let list: Array&lt;number&gt; = [1, 2, 3]
</code></pre>
<h2 id="元组类型"><a href="#元组类型" class="headerlink" title="元组类型"></a>元组类型</h2><p>它允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。</p>
<pre><code class="ts">let x: [string, number] // 数组长度为2，第一个为字符串，第二个是数字
// Initialize it
x = [&#39;hello&#39;, 10] // OK
// Initialize it incorrectly
x = [10, &#39;hello&#39;] // Error
</code></pre>
<p>当访问一个越界的元素，会使用联合类型替代</p>
<pre><code class="ts">x[3] = &#39;world&#39; // OK, 字符串可以赋值给(string | number)类型

console.log(x[5].toString()) // OK, &#39;string&#39; 和 &#39;number&#39; 都有 toString

x[6] = true // Error, 布尔不是(string | number)类型
</code></pre>
<span id="more"></span>

<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>默认情况下，从 0 开始为元素编号 （数字枚举）</p>
<pre><code class="ts">enum Color &#123;
  Red,
  Green,
  Blue,
&#125;
let c: Color = Color.Green

// 即
enum Color &#123;
  Red = 0,
  Green = 1,
  Blue = 2,
&#125;
let c: Color = Color.Green
</code></pre>
<p>也可以手动的指定成员的数值</p>
<pre><code class="ts">enum Color &#123;
  Red = 1,
  Green = 2,
  Blue = 4,
&#125;
let c: Color = Color.Green
</code></pre>
<p>反向映射：<strong>数字枚举</strong>类型提供的一个便利是你可以由枚举的值得到它的名字（<strong>可以把把数字 1 换成字符串“1”试试</strong>）</p>
<pre><code class="ts">enum Color &#123;
  Red = 1,
  Green,
  Blue,
&#125;
let colorName: string = Color[2]

console.log(colorName) // 显示&#39;Green&#39;因为上面代码里它的值是2
</code></pre>
<h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><pre><code class="ts">let someValue: any = &#39;this is a string&#39;

let strLength: number = (someValue as string).length

// 或者

let someValue: any = &#39;this is a string&#39;

let strLength: number = (&lt;string&gt;someValue).length
</code></pre>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="可选属性及额外的属性检查"><a href="#可选属性及额外的属性检查" class="headerlink" title="可选属性及额外的属性检查"></a>可选属性及额外的属性检查</h2><pre><code class="ts">// 绕过额外的属性检查
interface SquareConfig &#123;
  color?: string
  width?: number
  [propName: string]: any
&#125;
</code></pre>
<h2 id="函数类型接口"><a href="#函数类型接口" class="headerlink" title="函数类型接口"></a>函数类型接口</h2><pre><code class="ts">interface SearchFunc &#123;
  (source: string, subString: string): boolean
&#125;

let mySearch: SearchFunc = (src: string, sub: string): boolean =&gt; &#123;
  let result = src.search(sub)
  return result &gt; -1
&#125;
</code></pre>
<h2 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h2><pre><code class="ts">// 接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。
interface ClockInterface &#123;
  currentTime: Date
  setTime(d: Date)
&#125;

class Clock implements ClockInterface &#123;
  currentTime: Date
  setTime(d: Date) &#123;
    this.currentTime = d
  &#125;
  constructor(h: number, m: number) &#123;&#125;
&#125;
</code></pre>
<h2 id="继承接口"><a href="#继承接口" class="headerlink" title="继承接口"></a>继承接口</h2><pre><code class="ts">interface Shape &#123;
  color: string
&#125;

interface PenStroke &#123;
  penWidth: number
&#125;

interface Square extends Shape, PenStroke &#123;
  sideLength: number
&#125;

let square = &lt;Square&gt;&#123;&#125;
// let square: Square = &#123;&#125;
square.color = &#39;blue&#39;
square.sideLength = 10
square.penWidth = 5.0
</code></pre>
<h2 id="接口继承类"><a href="#接口继承类" class="headerlink" title="接口继承类"></a>接口继承类</h2><p>当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的 private 和 protected 成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。</p>
<p>当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。 这个子类除了继承至基类外与基类没有任何关系。</p>
<pre><code class="ts">class Control &#123;
  private state: any
&#125;

interface SelectableControl extends Control &#123;
  select(): void
&#125;

class Button extends Control implements SelectableControl &#123;
  select() &#123;&#125;
&#125;

class TextBox extends Control &#123;
  select() &#123;&#125;
&#125;

// 错误：“Image”类型缺少“state”属性。
class Image implements SelectableControl &#123;
  select() &#123;&#125;
&#125;

class Location &#123;&#125;
</code></pre>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>基础例子</p>
<pre><code class="ts">class Animal &#123;
  name: string
  constructor(theName: string) &#123;
    this.name = theName
  &#125;
  move(distanceInMeters: number = 0) &#123;
    console.log(`$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m.`)
  &#125;
&#125;

class Snake extends Animal &#123;
  constructor(name: string) &#123;
    super(name)
  &#125;
  move(distanceInMeters = 5) &#123;
    console.log(&#39;Slithering...&#39;)
    super.move(distanceInMeters)
  &#125;
&#125;

class Horse extends Animal &#123;
  constructor(name: string) &#123;
    super(name)
  &#125;
  move(distanceInMeters = 45) &#123;
    console.log(&#39;Galloping...&#39;)
    super.move(distanceInMeters)
  &#125;
&#125;

let sam = new Snake(&#39;Sammy the Python&#39;)
let tom: Animal = new Horse(&#39;Tommy the Palomino&#39;)

sam.move()
tom.move(34)
</code></pre>
<h2 id="公共，私有与受保护的修饰符"><a href="#公共，私有与受保护的修饰符" class="headerlink" title="公共，私有与受保护的修饰符"></a>公共，私有与受保护的修饰符</h2><p>当成员被标记成 <code>private</code> 时，它就不能在声明它的类的外部访问，值类也不行。<br><code>protected</code> 修饰符与 <code>private</code> 修饰符的行为很相似，但有一点不同， <code>protected</code> 成员在派生类中仍然可以访问。</p>
<pre><code class="ts">class Person &#123;
  protected name: string
  constructor(name: string) &#123;
    this.name = name
  &#125;
&#125;

class Employee extends Person &#123;
  private department: string

  constructor(name: string, department: string) &#123;
    super(name)
    this.department = department
  &#125;

  public getElevatorPitch() &#123;
    return `Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.`
  &#125;
&#125;

let howard = new Employee(&#39;Howard&#39;, &#39;Sales&#39;)
console.log(howard.getElevatorPitch())
console.log(howard.name) // 错误
</code></pre>
<pre><code class="ts">class Person &#123;
  protected name: string
  protected constructor(theName: string) &#123;
    this.name = theName
  &#125;
&#125;

// Employee 能够继承 Person
class Employee extends Person &#123;
  private department: string

  constructor(name: string, department: string) &#123;
    super(name)
    this.department = department
  &#125;

  public getElevatorPitch() &#123;
    return `Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.`
  &#125;
&#125;

let howard = new Employee(&#39;Howard&#39;, &#39;Sales&#39;)
let john = new Person(&#39;John&#39;) // 错误: &#39;Person&#39; 的构造函数是被保护的.
</code></pre>
<h2 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h2><pre><code class="ts">let passcode = &#39;secret passcode&#39;

class Employee &#123;
  private _fullName: string

  get fullName(): string &#123;
    return this._fullName
  &#125;

  set fullName(newName: string) &#123;
    if (passcode &amp;&amp; passcode == &#39;secret passcode&#39;) &#123;
      this._fullName = newName
    &#125; else &#123;
      console.log(&#39;Error: Unauthorized update of employee!&#39;)
    &#125;
  &#125;
&#125;

let employee = new Employee()
employee.fullName = &#39;Bob Smith&#39;
if (employee.fullName) &#123;
  alert(employee.fullName)
&#125;
</code></pre>
<p><strong>只带有 get 不带有 set 的存取器自动被推断为 readonly</strong></p>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。 不同于接口，抽象类可以包含成员的实现细节。 abstract 关键字是用于定义抽象类和在抽象类内部定义抽象方法。</p>
<p><strong>抽象类中的抽象方法不包含具体实现并且必须在派生类中实现</strong></p>
<pre><code class="ts">abstract class Department &#123;
  constructor(public name: string) &#123;&#125;

  printName(): void &#123;
    console.log(&#39;Department name: &#39; + this.name)
  &#125;

  abstract printMeeting(): void // 必须在派生类中实现
&#125;

class AccountingDepartment extends Department &#123;
  constructor() &#123;
    super(&#39;Accounting and Auditing&#39;) // 在派生类的构造函数中必须调用 super()
  &#125;

  printMeeting(): void &#123;
    console.log(&#39;The Accounting Department meets each Monday at 10am.&#39;)
  &#125;

  generateReports(): void &#123;
    console.log(&#39;Generating accounting reports...&#39;)
  &#125;
&#125;

let department: Department // 允许创建一个对抽象类型的引用
department = new Department() // 错误: 不能创建一个抽象类的实例
department = new AccountingDepartment() // 允许对一个抽象子类进行实例化和赋值
department.printName()
department.printMeeting()
department.generateReports() // 错误: 方法在声明的抽象类中不存在
</code></pre>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>泛型函数：给 identity 添加了类型<strong>变量</strong> T。 T 帮助我们捕获用户传入的类型（比如：number），之后我们就可以使用这个类型。 之后我们再次使用了 T 当做返回值类型。现在我们可以知道参数类型与返回值类型是相同的了。</p>
<pre><code class="ts">function identity&lt;T&gt;(arg: T): T &#123;
  return arg
&#125;

// T 在定义函数的时候是一个代表类型的变量。这里调用的时候明确的指定了 T 是 string 类型，并做为一个参数传给函数，使用了 &lt;&gt; 括起来而不是 ()
let output = identity&lt;string&gt;(&#39;myString&#39;) // type of output will be &#39;string&#39;
</code></pre>
<pre><code class="ts">function identity&lt;T, U&gt;(value: T, message: U): T &#123;
  console.log(message)
  return value
&#125;

console.log(identity&lt;number, string&gt;(68, &#39;Semlinker&#39;))
console.log(identity(68, &#39;Semlinker&#39;)) // 编译器自行推断
</code></pre>
<h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><pre><code class="ts">interface Identities&lt;V, M&gt; &#123;
  value: V
  message: M
&#125;

function identity&lt;T, U&gt;(value: T, message: U): Identities&lt;T, U&gt; &#123;
  console.log(value + &#39;: &#39; + typeof value)
  console.log(message + &#39;: &#39; + typeof message)
  let identities: Identities&lt;T, U&gt; = &#123;
    value,
    message,
  &#125;
  return identities
&#125;

console.log(identity(68, &#39;Semlinker&#39;))
</code></pre>
<h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><pre><code class="ts">class GenericNumber&lt;T&gt; &#123;
  zeroValue: T
  add: (x: T, y: T) =&gt; T
&#125;

let myGenericNumber = new GenericNumber&lt;number&gt;()
myGenericNumber.zeroValue = 0
myGenericNumber.add = function (x, y) &#123;
  return x + y
&#125;
</code></pre>
<h2 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h2><h3 id="确保属性存在"><a href="#确保属性存在" class="headerlink" title="确保属性存在"></a>确保属性存在</h3><pre><code class="ts">function identity&lt;T&gt;(arg: T[]): T[] &#123;
  console.log(arg.length)
  return arg
&#125;

// or
function identity&lt;T&gt;(arg: Array&lt;T&gt;): Array&lt;T&gt; &#123;
  console.log(arg.length)
  return arg
&#125;
</code></pre>
<h3 id="检查对象上的键是否存在"><a href="#检查对象上的键是否存在" class="headerlink" title="检查对象上的键是否存在"></a>检查对象上的键是否存在</h3><p>首先了解 keyof 操作符。keyof 操作符是在 TypeScript 2.1 版本引入的，该操作符可以用于获取某种类型的所有键，其返回类型是联合类型。</p>
<pre><code class="ts">interface Person &#123;
  name: string
  age: number
  location: string
&#125;

type K1 = keyof Person // &quot;name&quot; | &quot;age&quot; | &quot;location&quot;
type K2 = keyof Person[] // number | &quot;length&quot; | &quot;push&quot; | &quot;concat&quot; | ...
type K3 = keyof &#123; [x: string]: Person &#125; // string | number
</code></pre>
<pre><code class="ts">enum Difficulty &#123;
  Easy,
  Intermediate,
  Hard,
&#125;

function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K): T[K] &#123;
  return obj[key]
&#125;

let tsInfo = &#123;
  name: &#39;Typescript&#39;,
  supersetOf: &#39;Javascript&#39;,
  difficulty: Difficulty.Intermediate,
&#125;

let difficulty: Difficulty = getProperty(tsInfo, &#39;difficulty&#39;) // OK

let supersetOf: string = getProperty(tsInfo, &#39;superset_of&#39;) // Error
</code></pre>
<h3 id="泛型参数默认类型"><a href="#泛型参数默认类型" class="headerlink" title="泛型参数默认类型"></a>泛型参数默认类型</h3><pre><code class="ts">interface A&lt;T = string&gt; &#123;
  name: T
&#125;

const strA: A = &#123; name: &#39;Semlinker&#39; &#125;
const numB: A&lt;number&gt; = &#123; name: 101 &#125;
</code></pre>
<h1 id="枚举-1"><a href="#枚举-1" class="headerlink" title="枚举"></a>枚举</h1><h2 id="数字枚举"><a href="#数字枚举" class="headerlink" title="数字枚举"></a>数字枚举</h2><pre><code class="ts">enum E &#123;
  A = getSomeValue(),
  B, // error! &#39;A&#39; is not constant-initialized, so &#39;B&#39; needs an initializer
&#125;
</code></pre>
<h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><p>待续……</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Typescript</tag>
      </tags>
  </entry>
  <entry>
    <title>Umi Request 拦截器</title>
    <url>/blog/javascript-umi-request-interceptors/</url>
    <content><![CDATA[<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p><strong><code>response 拦截器</code> 会先于 <code>异常处理程序 「errorHandler」 </code> 对返回值进行处理与判断</strong></p>
<span id="more"></span>

<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="typescript">/**
 * request 网络请求工具
 * 更详细的 api 文档: https://github.com/umijs/umi-request
 */
import &#123; extend &#125; from &#39;umi-request&#39;
import &#123; notification &#125; from &#39;antd&#39;
import &#123; stringify &#125; from &#39;querystring&#39;

import &#123; SYSTEM_USER_LOGIN_URL, SYSTEM_USER_TOKEN &#125; from &#39;@/globalData&#39;

const isDev = process.env.NODE_ENV === &#39;development&#39;

const baseUrl = &#39;https://myapi.com&#39;

const ERROR_MESSAGE: string = &#39;发生自定义错误&#39;

const codeMessage = &#123;
  200: &#39;服务器成功返回请求的数据。&#39;,
  201: &#39;新建或修改数据成功。&#39;,
  202: &#39;一个请求已经进入后台排队（异步任务）。&#39;,
  204: &#39;删除数据成功。&#39;,
  400: &#39;发出的请求有错误，服务器没有进行新建或修改数据的操作。&#39;,
  401: &#39;用户没有权限（令牌、用户名、密码错误）。&#39;,
  404: &#39;发出的请求针对的是不存在的记录，服务器没有进行操作。&#39;,
  403: &#39;用户得到授权，但是访问是被禁止的。&#39;,
  406: &#39;请求的格式不可得。&#39;,
  410: &#39;请求的资源被永久删除，且不会再得到的。&#39;,
  422: &#39;当创建一个对象时，发生一个验证错误。&#39;,
  500: &#39;服务器发生错误，请检查服务器。&#39;,
  502: &#39;网关错误。&#39;,
  503: &#39;服务不可用，服务器暂时过载或维护。&#39;,
  504: &#39;网关超时。&#39;,
&#125;

/**
 * 异常处理程序
 * 处理程序如果 return，则将值作为返回。
 * &#39;return;&#39; 相当于 return undefined, 在处理结果时判断 response 是否有值即可。
 * 这时相当于 &#39;resolve( undefined || &#123; key: value&#125; )&#39;，
 * 如果没有 return ， 正确则表现为 &#39;resolve( &#123;key: value&#125; )&#39;， 错误则表现为 &#39;reject( error )&#39;
 */
const errorHandler = async (error: any) =&gt; &#123;
  if (error.message === ERROR_MESSAGE) &#123;
    return
  &#125;
  const &#123; response &#125; = error
  if (response &amp;&amp; response.status) &#123;
    const errorText = codeMessage[response.status] || response.statusText
    const &#123; status, url &#125; = response
    notification.error(&#123;
      message: `请求错误 $&#123;status&#125;: $&#123;url&#125;`,
      description: errorText,
    &#125;)
  &#125; else if (!response) &#123;
    notification.error(&#123;
      description: &#39;您的网络发生异常，无法连接服务器&#39;,
      message: &#39;网络异常&#39;,
    &#125;)
  &#125;
  // eslint-disable-next-line no-useless-return
  return
&#125;

/**
 * 配置request请求时的默认参数
 */
const request = extend(&#123;
  errorHandler, // 默认错误处理
  credentials: &#39;include&#39;, // 默认请求是否带上cookie
&#125;)

/**
 * request 拦截
 */
request.interceptors.request.use((url, options) =&gt; &#123;
  return &#123;
    url,
    options: &#123;
      ...options,
      headers: &#123;
        ...options.headers,
        Authorization: getToken(), // 发送请求时，头部携带用户验证信息
      &#125;,
    &#125;,
  &#125;
&#125;)

/**
 * response 拦截
 */
request.interceptors.response.use(async response =&gt; &#123;
  const &#123; status &#125; = response
  if (status === 401) &#123;
    localStorage.clear()
    const queryString = stringify(&#123;
      redirect: window.location.href,
    &#125;)
    window.location.href = `/user/login?$&#123;queryString&#125;`
  &#125;
  try &#123;
    const data = await response.clone().json()
    if (data.code === 1) &#123;
      // 对自定义的 code 进行判断
      notification.error(&#123;
        message: &#39;请求错误&#39;,
        description: data.msg,
      &#125;)

      return Promise.reject(new Error(ERROR_MESSAGE))
    &#125;
  &#125; catch (error) &#123;
    console.log(&#39;error&#39;, error)
  &#125;
  return response
&#125;)

export default request
</code></pre>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Umi</tag>
        <tag>HttpRequest</tag>
      </tags>
  </entry>
  <entry>
    <title>工具函数集合</title>
    <url>/blog/javascript-util-functions/</url>
    <content><![CDATA[<h2 id="通用工具类"><a href="#通用工具类" class="headerlink" title="通用工具类"></a>通用工具类</h2><pre><code class="javascript">export default class func &#123;
  /**
   * 不为空
   * @param val
   * @returns &#123;boolean&#125;
   */
  static notEmpty(val) &#123;
    return !this.isEmpty(val)
  &#125;

  /**
   * 是否为定义
   * @param val
   * @returns &#123;boolean&#125;
   */
  static isUndefined(val) &#123;
    return val === null || typeof val === &#39;undefined&#39;
  &#125;

  /**
   * 为空
   * @param val
   * @returns &#123;boolean&#125;
   */
  static isEmpty(val) &#123;
    if (val === null || typeof val === &#39;undefined&#39; || (typeof val === &#39;string&#39; &amp;&amp; val === &#39;&#39; &amp;&amp; val !== &#39;undefined&#39;)) &#123;
      return true
    &#125;
    return false
  &#125;

  /**
   * 强转int型
   * @param val
   * @param defaultValue
   * @returns &#123;number&#125;
   */
  static toInt(val, defaultValue) &#123;
    if (this.isEmpty(val)) &#123;
      return defaultValue === undefined ? -1 : defaultValue
    &#125;
    const num = parseInt(val, 0)
    return Number.isNaN(num) ? (defaultValue === undefined ? -1 : defaultValue) : num
  &#125;

  /**
   * Json强转为Form类型
   * @param obj
   * @returns &#123;FormData&#125;
   */
  static toFormData(obj) &#123;
    const data = new FormData()
    Object.keys(obj).forEach(key =&gt; &#123;
      data.append(key, Array.isArray(obj[key]) ? obj[key].join(&#39;,&#39;) : obj[key])
    &#125;)
    return data
  &#125;

  /**
   * date类转为字符串格式
   * @param date
   * @param format
   * @returns &#123;null&#125;
   */
  static format(date, format = &#39;YYYY-MM-DD HH:mm:ss&#39;) &#123;
    return date ? date.format(format) : null
  &#125;

  /**
   * 根据逗号联合
   * @param arr
   * @returns &#123;string&#125;
   */
  static join(arr) &#123;
    return arr ? arr.join(&#39;,&#39;) : &#39;&#39;
  &#125;

  /**
   * 根据逗号分隔
   * @param str
   * @returns &#123;string&#125;
   */
  static split(str) &#123;
    return str ? String(str).split(&#39;,&#39;) : &#39;&#39;
  &#125;
&#125;
</code></pre>
<span id="more"></span>

<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><pre><code class="javascript">/* 合法uri*/
export function validateURL(textval) &#123;
  const urlregex = /^(https?|ftp):\/\/([a-zA-Z0-9.-]+(:[a-zA-Z0-9.&amp;%$-]+)*@)*((25[0-5]|2[0-4][0-9]|1[0-9]&#123;2&#125;|[1-9][0-9]?)(\.(25[0-5]|2[0-4][0-9]|1[0-9]&#123;2&#125;|[1-9]?[0-9]))&#123;3&#125;|([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+\.(com|edu|gov|int|mil|net|org|biz|arpa|info|name|pro|aero|coop|museum|[a-zA-Z]&#123;2&#125;))(:[0-9]+)*(\/($|[a-zA-Z0-9.,?&#39;\\+&amp;%$#=~_-]+))*$/
  return urlregex.test(textval)
&#125;
/**
 * 邮箱
 * @param &#123;*&#125; s
 */
export function isEmail(s) &#123;
  return /^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+((.[a-zA-Z0-9_-]&#123;2,3&#125;)&#123;1,2&#125;)$/.test(s)
&#125;

/**
 * 手机号码
 * @param &#123;*&#125; s
 */
export function isMobile(s) &#123;
  return /^1[0-9]&#123;10&#125;$/.test(s)
&#125;

/**
 * 电话号码
 * @param &#123;*&#125; s
 */
export function isPhone(s) &#123;
  return /^([0-9]&#123;3,4&#125;-)?[0-9]&#123;7,8&#125;$/.test(s)
&#125;

/**
 * URL地址
 * @param &#123;*&#125; s
 */
export function isURL(s) &#123;
  return /^http[s]?:\/\/.*/.test(s)
&#125;

/* 小写字母*/
export function validateLowerCase(str) &#123;
  const reg = /^[a-z]+$/
  return reg.test(str)
&#125;

/* 大写字母*/
export function validateUpperCase(str) &#123;
  const reg = /^[A-Z]+$/
  return reg.test(str)
&#125;

/* 大小写字母*/
export function validatAlphabets(str) &#123;
  const reg = /^[A-Za-z]+$/
  return reg.test(str)
&#125;
/*验证pad还是pc*/
export const vaildatePc = function () &#123;
  const userAgentInfo = navigator.userAgent
  const Agents = [&#39;Android&#39;, &#39;iPhone&#39;, &#39;SymbianOS&#39;, &#39;Windows Phone&#39;, &#39;iPad&#39;, &#39;iPod&#39;]
  let flag = true
  for (var v = 0; v &lt; Agents.length; v++) &#123;
    if (userAgentInfo.indexOf(Agents[v]) &gt; 0) &#123;
      flag = false
      break
    &#125;
  &#125;
  return flag
&#125;
/**
 * validate email
 * @param email
 * @returns &#123;boolean&#125;
 */
export function validateEmail(email) &#123;
  const re = /^(([^&lt;&gt;()\\[\]\\.,;:\s@&quot;]+(\.[^&lt;&gt;()\\[\]\\.,;:\s@&quot;]+)*)|(&quot;.+&quot;))@((\[[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]&#123;2,&#125;))$/
  return re.test(email)
&#125;

/**
 * 判断身份证号码
 */
export function cardid(code) &#123;
  let list = []
  let result = true
  let msg = &#39;&#39;
  var city = &#123;
    11: &#39;北京&#39;,
    12: &#39;天津&#39;,
    13: &#39;河北&#39;,
    14: &#39;山西&#39;,
    15: &#39;内蒙古&#39;,
    21: &#39;辽宁&#39;,
    22: &#39;吉林&#39;,
    23: &#39;黑龙江 &#39;,
    31: &#39;上海&#39;,
    32: &#39;江苏&#39;,
    33: &#39;浙江&#39;,
    34: &#39;安徽&#39;,
    35: &#39;福建&#39;,
    36: &#39;江西&#39;,
    37: &#39;山东&#39;,
    41: &#39;河南&#39;,
    42: &#39;湖北 &#39;,
    43: &#39;湖南&#39;,
    44: &#39;广东&#39;,
    45: &#39;广西&#39;,
    46: &#39;海南&#39;,
    50: &#39;重庆&#39;,
    51: &#39;四川&#39;,
    52: &#39;贵州&#39;,
    53: &#39;云南&#39;,
    54: &#39;西藏 &#39;,
    61: &#39;陕西&#39;,
    62: &#39;甘肃&#39;,
    63: &#39;青海&#39;,
    64: &#39;宁夏&#39;,
    65: &#39;新疆&#39;,
    71: &#39;台湾&#39;,
    81: &#39;香港&#39;,
    82: &#39;澳门&#39;,
    91: &#39;国外 &#39;,
  &#125;
  if (!validatenull(code)) &#123;
    if (code.length == 18) &#123;
      if (!code || !/(^\d&#123;18&#125;$)|(^\d&#123;17&#125;(\d|X|x)$)/.test(code)) &#123;
        msg = &#39;证件号码格式错误&#39;
      &#125; else if (!city[code.substr(0, 2)]) &#123;
        msg = &#39;地址编码错误&#39;
      &#125; else &#123;
        //18位身份证需要验证最后一位校验位
        code = code.split(&#39;&#39;)
        //∑(ai×Wi)(mod 11)
        //加权因子
        var factor = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2]
        //校验位
        var parity = [1, 0, &#39;X&#39;, 9, 8, 7, 6, 5, 4, 3, 2, &#39;x&#39;]
        var sum = 0
        var ai = 0
        var wi = 0
        for (var i = 0; i &lt; 17; i++) &#123;
          ai = code[i]
          wi = factor[i]
          sum += ai * wi
        &#125;
        if (parity[sum % 11] != code[17]) &#123;
          msg = &#39;证件号码校验位错误&#39;
        &#125; else &#123;
          result = false
        &#125;
      &#125;
    &#125; else &#123;
      msg = &#39;证件号码长度不为18位&#39;
    &#125;
  &#125; else &#123;
    msg = &#39;证件号码不能为空&#39;
  &#125;
  list.push(result)
  list.push(msg)
  return list
&#125;
/**
 * 判断手机号码是否正确
 */
export function isvalidatemobile(phone) &#123;
  let list = []
  let result = true
  let msg = &#39;&#39;
  var isPhone = /^0\d&#123;2,3&#125;-?\d&#123;7,8&#125;$/
  //增加134 减少|1349[0-9]&#123;7&#125;，增加181,增加145，增加17[678]
  if (!validatenull(phone)) &#123;
    if (phone.length == 11) &#123;
      if (isPhone.test(phone)) &#123;
        msg = &#39;手机号码格式不正确&#39;
      &#125; else &#123;
        result = false
      &#125;
    &#125; else &#123;
      msg = &#39;手机号码长度不为11位&#39;
    &#125;
  &#125; else &#123;
    msg = &#39;手机号码不能为空&#39;
  &#125;
  list.push(result)
  list.push(msg)
  return list
&#125;
/**
 * 判断姓名是否正确
 */
export function validatename(name) &#123;
  var regName = /^[\u4e00-\u9fa5]&#123;2,4&#125;$/
  if (!regName.test(name)) return false
  return true
&#125;
/**
 * 判断是否为整数
 */
export function validatenum(num, type) &#123;
  let regName = /[^\d.]/g
  if (type == 1) &#123;
    if (!regName.test(num)) return false
  &#125; else if (type == 2) &#123;
    regName = /[^\d]/g
    if (!regName.test(num)) return false
  &#125;
  return true
&#125;
/**
 * 判断是否为小数
 */
export function validatenumord(num, type) &#123;
  let regName = /[^\d.]/g
  if (type == 1) &#123;
    if (!regName.test(num)) return false
  &#125; else if (type == 2) &#123;
    regName = /[^\d.]/g
    if (!regName.test(num)) return false
  &#125;
  return true
&#125;
/**
 * 判断是否为空
 */
export function validatenull(val) &#123;
  if (typeof val == &#39;boolean&#39;) &#123;
    return false
  &#125;
  if (typeof val == &#39;number&#39;) &#123;
    return false
  &#125;
  if (val instanceof Array) &#123;
    if (val.length == 0) return true
  &#125; else if (val instanceof Object) &#123;
    if (JSON.stringify(val) === &#39;&#123;&#125;&#39;) return true
  &#125; else &#123;
    if (val == &#39;null&#39; || val == null || val == &#39;undefined&#39; || val == undefined || val == &#39;&#39;) return true
    return false
  &#125;
  return false
&#125;
</code></pre>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>网页字体设置</title>
    <url>/blog/javascript-web-font-settings/</url>
    <content><![CDATA[<h2 id="字体文件下载"><a href="#字体文件下载" class="headerlink" title="字体文件下载"></a>字体文件下载</h2><p>从 <a href="https://google-webfonts-helper.herokuapp.com/fonts">Google Fonts</a> 下载免费字体，这里我们选择思源黑体 <code>Noto Sans SC</code>。</p>
<span id="more"></span>

<h2 id="字体定义细节"><a href="#字体定义细节" class="headerlink" title="字体定义细节"></a>字体定义细节</h2><ul>
<li><p>英文字体在前，中文字体在后。原因很简单，中文字体包中通常包含了英文字符，反之则不成立，如果先设置了中文字体，那么英文字体根本轮不到 fallback</p>
</li>
<li><p>操作系统方面，Apple 系列（macOS + iOS）字体在前（直接用 -apple-system 即可），Windows 字体在后。macOS 下的用户有一定概率安装了 Windows 字体（因为安装了 Office），而 Windows 下安装 macOS 字体的用户却少之又少，所以如果 Windows 在前，那么在 macOS 下很有可能就出现「放着苹方不用却用微软雅黑」这种坑爹情况</p>
</li>
<li><p>根据访问网站的用户群体不同，可以考虑放弃对于老旧操作系统和浏览器的支持，比如我在使用思源宋体的时候，仅提供了 .woff 和 .woff2 格式的字体文件，完全放弃了老版本的 IE 和 Safari</p>
</li>
<li><p>仅对 Windows 用户使用自定义字体，比如思源系列，macOS、iOS、Linux 就使用系统自带字体就好。原因嘛当然是因为 Windows 自带的中文字体实在找不到好看的，而主动安装字体的用户毕竟还是少数</p>
</li>
<li><p>衬线还是非衬线完全看个人审美喜好，比如我就不觉得宋体系列好看（所以你现在看到的思源黑体，如果你是 Windows 用户的话）。同时，中文衬线搭配英文非衬线，或者反过来，中文非衬线搭配英文衬线，也完全没有问题</p>
</li>
<li><p><code>Georgia</code> 、<code>-apple-system</code>、 <code>&#39;Nimbus Roman No9 L&#39;</code> 分别对应 <code>Windows</code>、 <code>macOS/iOS</code>、 <code>Linux</code> 下三种系统内置英文字体（其实 <code>Georgia</code> 就已经覆盖三种系统了，后面两个只是出于保险起见）。<code>&#39;PingFang SC&#39;</code>（苹方）、<code>&#39;Hiragino Sans GB&#39;</code>（冬青黑体）、<code>&#39;Microsoft Yahei&#39;</code>（微软雅黑）对应三种系统内置中文字体（按照上文说法，Apple 系列在前，Windows 在最后），<code>&#39;Noto Sans SC&#39;</code>（思源黑体）则是允许免费使用的第三方字体，已经被我存储在本地。</p>
</li>
</ul>
<h2 id="网页字体定义样式"><a href="#网页字体定义样式" class="headerlink" title="网页字体定义样式"></a>网页字体定义样式</h2><pre><code class="less">/* noto-sans-sc-300 - latin_chinese-simplified */
@font-face &#123;
  font-family: &#39;Noto Sans SC&#39;;
  font-style: normal;
  font-weight: 300;
  src: url(&#39;/fonts/noto-sans-sc/noto-sans-sc-v11-latin_chinese-simplified-300.eot&#39;); /* IE9 Compat Modes */
  src: local(&#39;Noto Sans SC Light&#39;), local(&#39;NotoSansSC-Light&#39;),
    url(&#39;/fonts/noto-sans-sc/noto-sans-sc-v11-latin_chinese-simplified-300.eot?#iefix&#39;) format(&#39;embedded-opentype&#39;), /* IE6-IE8 */
      url(&#39;/fonts/noto-sans-sc/noto-sans-sc-v11-latin_chinese-simplified-300.woff2&#39;) format(&#39;woff2&#39;),
    /* Super Modern Browsers */ url(&#39;/fonts/noto-sans-sc/noto-sans-sc-v11-latin_chinese-simplified-300.woff&#39;) format(&#39;woff&#39;),
    /* Modern Browsers */ url(&#39;/fonts/noto-sans-sc/noto-sans-sc-v11-latin_chinese-simplified-300.ttf&#39;) format(&#39;truetype&#39;),
    /* Safari, Android, iOS */ url(&#39;/fonts/noto-sans-sc/noto-sans-sc-v11-latin_chinese-simplified-300.svg#NotoSansSC&#39;)
      format(&#39;svg&#39;); /* Legacy iOS */
&#125;

/* noto-sans-sc-regular - latin_chinese-simplified */
@font-face &#123;
  font-family: &#39;Noto Sans SC&#39;;
  font-style: normal;
  font-weight: 400;
  src: url(&#39;/fonts/noto-sans-sc/noto-sans-sc-v11-latin_chinese-simplified-regular.eot&#39;); /* IE9 Compat Modes */
  src: local(&#39;Noto Sans SC Regular&#39;), local(&#39;NotoSansSC-Regular&#39;),
    url(&#39;/fonts/noto-sans-sc/noto-sans-sc-v11-latin_chinese-simplified-regular.eot?#iefix&#39;) format(&#39;embedded-opentype&#39;),
    /* IE6-IE8 */ url(&#39;/fonts/noto-sans-sc/noto-sans-sc-v11-latin_chinese-simplified-regular.woff2&#39;) format(&#39;woff2&#39;),
    /* Super Modern Browsers */ url(&#39;/fonts/noto-sans-sc/noto-sans-sc-v11-latin_chinese-simplified-regular.woff&#39;) format(&#39;woff&#39;),
    /* Modern Browsers */ url(&#39;/fonts/noto-sans-sc/noto-sans-sc-v11-latin_chinese-simplified-regular.ttf&#39;) format(&#39;truetype&#39;),
    /* Safari, Android, iOS */
      url(&#39;/fonts/noto-sans-sc/noto-sans-sc-v11-latin_chinese-simplified-regular.svg#NotoSansSC&#39;) format(&#39;svg&#39;); /* Legacy iOS */
&#125;

/* noto-sans-sc-500 - latin_chinese-simplified */
@font-face &#123;
  font-family: &#39;Noto Sans SC&#39;;
  font-style: normal;
  font-weight: 500;
  src: url(&#39;/fonts/noto-sans-sc/noto-sans-sc-v11-latin_chinese-simplified-500.eot&#39;); /* IE9 Compat Modes */
  src: local(&#39;Noto Sans SC Medium&#39;), local(&#39;NotoSansSC-Medium&#39;),
    url(&#39;/fonts/noto-sans-sc/noto-sans-sc-v11-latin_chinese-simplified-500.eot?#iefix&#39;) format(&#39;embedded-opentype&#39;), /* IE6-IE8 */
      url(&#39;/fonts/noto-sans-sc/noto-sans-sc-v11-latin_chinese-simplified-500.woff2&#39;) format(&#39;woff2&#39;),
    /* Super Modern Browsers */ url(&#39;/fonts/noto-sans-sc/noto-sans-sc-v11-latin_chinese-simplified-500.woff&#39;) format(&#39;woff&#39;),
    /* Modern Browsers */ url(&#39;/fonts/noto-sans-sc/noto-sans-sc-v11-latin_chinese-simplified-500.ttf&#39;) format(&#39;truetype&#39;),
    /* Safari, Android, iOS */ url(&#39;/fonts/noto-sans-sc/noto-sans-sc-v11-latin_chinese-simplified-500.svg#NotoSansSC&#39;)
      format(&#39;svg&#39;); /* Legacy iOS */
&#125;
</code></pre>
<pre><code class="less">@import &#39;./font-face.less&#39;;

html,
body &#123;
  font-family: Georgia, -apple-system, &#39;Nimbus Roman No9 L&#39;, &#39;PingFang SC&#39;, &#39;Hiragino Sans GB&#39;, &#39;Noto Sans SC&#39;, &#39;Microsoft Yahei&#39;,
    &#39;WenQuanYi Micro Hei&#39;, &#39;ST Heiti&#39;, sans-serif !important;
  font-size: 12px;
  word-spacing: 1px;
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  -moz-osx-font-smoothing: grayscale;
  -webkit-font-smoothing: antialiased;
  box-sizing: border-box;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>网页</tag>
        <tag>字体</tag>
      </tags>
  </entry>
  <entry>
    <title>在项目中启用 commitlint</title>
    <url>/blog/others-commit-lint/</url>
    <content><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>和 <code>eslint</code> 一样的是， <code>commitlint</code> 自身只提供了检测的功能和一些最基础的规则，使用者需要根据这些规则配置出自己的规范。</p>
<p>对于 <code>Conventional Commits</code> 规范，社区已经整理好了 <code>@commitlint/config-conventional</code> 包，我们只需要安装并启用它就可以了。</p>
<p>首先安装 commitlint 以及 conventional 规范：</p>
<pre><code class="sh">npm install --save-dev @commitlint/cli @commitlint/config-conventional
</code></pre>
<span id="more"></span>

<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>接着创建 <code>commitlint.config.js</code> 或者 <code>.commitlintrc.js</code> 文件，并写入以下内容：</p>
<pre><code class="js">module.exports = &#123;
  extends: [&#39;@commitlint/config-conventional&#39;],
  rules: &#123;
    &#39;body-leading-blank&#39;: [1, &#39;always&#39;],
    &#39;body-max-line-length&#39;: [2, &#39;always&#39;, 100],
    &#39;footer-leading-blank&#39;: [1, &#39;always&#39;],
    &#39;footer-max-line-length&#39;: [2, &#39;always&#39;, 100],
    &#39;header-max-length&#39;: [2, &#39;always&#39;, 100],
    &#39;scope-case&#39;: [2, &#39;always&#39;, &#39;lower-case&#39;],
    &#39;subject-case&#39;: [2, &#39;never&#39;, [&#39;sentence-case&#39;, &#39;start-case&#39;, &#39;pascal-case&#39;, &#39;upper-case&#39;]],
    &#39;subject-empty&#39;: [2, &#39;never&#39;],
    &#39;subject-full-stop&#39;: [2, &#39;never&#39;, &#39;.&#39;],
    &#39;type-case&#39;: [2, &#39;always&#39;, &#39;lower-case&#39;],
    &#39;type-empty&#39;: [2, &#39;never&#39;],
    &#39;type-enum&#39;: [
      2,
      &#39;always&#39;,
      [&#39;build&#39;, &#39;chore&#39;, &#39;ci&#39;, &#39;docs&#39;, &#39;feat&#39;, &#39;fix&#39;, &#39;perf&#39;, &#39;refactor&#39;, &#39;revert&#39;, &#39;style&#39;, &#39;test&#39;],
    ],
  &#125;,
&#125;
</code></pre>
<p><strong>注意：rule 由 name 和配置数组组成，如：<code>name: [0, &#39;always&#39;, 72]</code>，数组中第一位为 <code>level</code> ，可选<code>0, 1, 2</code>， <code>0</code> 为 <code>disable</code> ， <code>1</code> 为 <code>warning</code> ， <code>2</code> 为 <code>error</code> ，第二位为应用与否，可选 <code>always|never</code> ，第三位该 <code>rule</code> 的值。</strong></p>
<p>至此，<code>commitlint</code> 的配置就基本完成了，但目前我们还没有说何时来执行 <code>commitlint</code>。</p>
<p>答案显而易见，在每次执行 <code>git commit</code> 的时候咯~</p>
<p>为了可以在每次 commit 时执行 commitlint 检查我们输入的 message，我们还需要用到一个工具 —— <code>husky</code>。</p>
<p><code>husky</code> 是一个增强的 <code>git hook</code> 工具。可以在 <code>git hook</code> 的各个阶段执行我们在 <code>package.json</code> 中配置好的 <code>npm script</code>。</p>
<p>首先安装 <code>husky</code>：</p>
<pre><code class="sh">npm install --save-dev husky
</code></pre>
<p>接着在 <code>package.json</code> 中配置 <code>commit-msg</code> 脚本：</p>
<pre><code class="json">&#123;
  &quot;husky&quot;: &#123;
    &quot;hooks&quot;: &#123;
      &quot;commit-msg&quot;: &quot;commitlint -E HUSKY_GIT_PARAMS&quot;,
      &quot;pre-commit&quot;: &quot;lint-staged&quot;
    &#125;
  &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Vue</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>利用 GitHub Action 部署静态网页或者博客</title>
    <url>/blog/others-github-action-deploy-web-page/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Github Actions 可以很方便实现 CI/CD 工作流，类似 Travis 的用法，来帮我们完成一些工作，比如实现自动化测试、打包、部署等操作。当我们运行 Jobs 时，它会创建一个容器 (runner)，容器支持：Ubuntu、Windows 和 MacOS 等系统，在容器中我们可以安装软件，利用安装的软件帮我们处理一些数据，然后把处理好的数据推送到某个地方。</p>
<p>本文将介绍利用 Github Actions 实现自动部署 hexo 到 Github Pages 以及自动部署自己的静态网页，在之前我们需要写完文章执行 <code>hexo generate --deploy</code> 来部署，当你文章比较多的时候，可能还需要等待很久，而且还可能会遇到本地安装的 Node.js 版本与 Hexo 不兼容的问题，利用 Github Actions 你将会没有这些烦恼。</p>
<span id="more"></span>

<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><h3 id="创建所需仓库"><a href="#创建所需仓库" class="headerlink" title="创建所需仓库"></a>创建所需仓库</h3><ol>
<li>创建 <code>source-code</code> 仓库用来存放 Hexo 项目源码或者自有静态网页的源码</li>
<li>创建 <code>deploy</code> 仓库用来存放打包后的博客页面或者静态页面，并创建一个 <code>gh-pages</code> 分支</li>
</ol>
<h3 id="生成部署密钥"><a href="#生成部署密钥" class="headerlink" title="生成部署密钥"></a>生成部署密钥</h3><p>一路回车，执行以下命令：</p>
<pre><code class="shell">ssh-keygen -t rsa -C &quot;yourname@example.com&quot; -f github-deploy-key
</code></pre>
<p>当前目录下会有 <code>github-deploy-key</code> （私钥）和 <code>github-deploy-key.pub</code> （公钥）两个文件</p>
<h3 id="配置部署密钥"><a href="#配置部署密钥" class="headerlink" title="配置部署密钥"></a>配置部署密钥</h3><p>复制 <code>github-deploy-key</code> （私钥）文件内容，在 <code>source-code</code> 仓库 Settings -&gt; Secrets -&gt; Add a new secret 页面上添加</p>
<ol>
<li>在 <code>Name</code> 输入框填写 <code>DEPLOY_PRI</code>（可以自定义）</li>
<li>在 <code>Value</code> 输入框填写 <code>github-deploy-key</code> （私钥）文件内容</li>
</ol>
<p>复制 <code>github-deploy-key.pub</code> （公钥）文件内容，在 <code>deploy</code> 仓库 Settings -&gt; Deploy keys -&gt; Add deploy key 页面上添加</p>
<ol>
<li>在 <code>Title</code> 输入框填写 <code>DEPLOY_PUB</code>（可以自定义）</li>
<li>在 <code>Key</code> 输入框填写 <code>github-deploy-key.pub</code> （公钥）文件内容</li>
<li>勾选 <code>Allow write access</code> 选项</li>
</ol>
<h2 id="编写-Github-Actions"><a href="#编写-Github-Actions" class="headerlink" title="编写 Github Actions"></a>编写 Github Actions</h2><h3 id="Hexo-博客"><a href="#Hexo-博客" class="headerlink" title="Hexo 博客"></a>Hexo 博客</h3><p>在 <code>source-code</code> 仓库根目录下创建 <code>.github/workflows/deploy.yml</code> 文件</p>
<pre><code class="yml">name: CI

# 当代码推送到master分支时触发Action工作流
on:
  push:
    branches:
      - master

jobs:
  build:
    name: Hexo Auto-Deploy by GitHub Actions
    runs-on: ubuntu-latest

    steps:
      # 切换分支，使用checkout@v2插件
      - name: 1. git checkout...
        uses: actions/checkout@v2
      # 设置node环境，使用setup-node@v1插件
      - name: 2. setup nodejs...
        uses: actions/setup-node@v1
      # 安装依赖包
      - name: 3. install hexo...
        run: |
          npm install hexo-cli -g
          npm install
      # 生成静态文件
      - name: 4. hexo generate public files...
        run: |
          hexo clean
          hexo g
      # 进行部署， “DEPLOY_PRI” 为上面 👆 ‘github-deploy-key’ （私钥）的名称
      - name: 5. hexo deploy ...
        run: |
          mkdir -p ~/.ssh/
          echo &quot;$&#123;&#123; secrets.DEPLOY_PRI &#125;&#125;&quot; &gt; ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts

          git config --global user.name &quot;chivesssss&quot;
          git config --global user.email &quot;ismartgoo@gmail.com&quot;

          hexo clean &amp;&amp; hexo deploy
</code></pre>
<p><strong>注意： 执行 <code>hexo deploy</code> 命令之前，需要对 hexo 配置文件中的 <code>deploy</code> 字段进行配置</strong></p>
<pre><code class="yml">deploy:
  type: &#39;git&#39;
  repo: git@github.com:yourGithubUsername/deploy.git
  branch: [gh-pages]
</code></pre>
<h3 id="自有静态网页（以-NUXT-项目为例）"><a href="#自有静态网页（以-NUXT-项目为例）" class="headerlink" title="自有静态网页（以 NUXT 项目为例）"></a>自有静态网页（以 NUXT 项目为例）</h3><p>在 <code>source-code</code> 仓库根目录下创建 <code>.github/workflows/deploy.yml</code> 文件</p>
<pre><code class="yml">name: CI

# 当代码推送到main分支时触发Action工作流
on:
  push:
    branches:
      - main

jobs:
  build:
    name: Nuxt Project Auto-Deploy by GitHub Actions
    runs-on: ubuntu-latest

    steps:
      # 切换分支，使用checkout@v2插件
      - name: 1. git checkout...
        uses: actions/checkout@v2

      # 设置node环境，使用setup-node@v1插件
      - name: 2. setup nodejs...
        uses: actions/setup-node@v1

      # 安装依赖包
      - name: 3. install npm packages...
        run: |
          npm install

      # 生成静态文件
      - name: 4. nuxt generate dist files...
        run: |
          npm run generate

      # 利用插件 peaceiris/actions-gh-pages@v3 进行部署， “DEPLOY_PRI” 为上面 👆 ‘github-deploy-key’ （私钥）的名称
      - name: 5. nuxt deploy ...
        uses: peaceiris/actions-gh-pages@v3
        with:
          deploy_key: $&#123;&#123; secrets.DEPLOY_PRI &#125;&#125;
          external_repository: yourGithubUsername/deploy
          publish_dir: ./dist # 打包后的静态文件所在的目录
          keep_files: false # 删除已经存在的文件夹
          publish_branch: gh-pages # 部署的分支
          commit_message: $&#123;&#123; github.event.head_commit.message &#125;&#125;
</code></pre>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>Deploy</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序 CI 工具使用教程</title>
    <url>/blog/others-miniprogram-ci/</url>
    <content><![CDATA[<h2 id="通过-Uni-App-CLI-命令行工具构建的项目"><a href="#通过-Uni-App-CLI-命令行工具构建的项目" class="headerlink" title="通过 Uni-App CLI 命令行工具构建的项目"></a>通过 Uni-App CLI 命令行工具构建的项目</h2><h3 id="在项目中安装依赖包"><a href="#在项目中安装依赖包" class="headerlink" title="在项目中安装依赖包"></a>在项目中安装依赖包</h3><pre><code class="shell">yarn add miniprogram-ci -D
</code></pre>
<p>在使用过程中，可能会遇到报错。在我的 Case 中需要自己手动安装其他的依赖包</p>
<pre><code class="shell">yarn add @vue/babel-preset-app -D
</code></pre>
<span id="more"></span>

<h3 id="小程序后台配置"><a href="#小程序后台配置" class="headerlink" title="小程序后台配置"></a>小程序后台配置</h3><p>在小程序后台开发设置中下载小程序上传密钥以及配置 IP 白名单</p>
<p><img src="https://cdn.jsdelivr.net/gh/chivesssss/picture-store@master/uPic/2021/07/31/19/45/wx-upload.png" alt="微信后台配置"></p>
<h2 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h2><p>在项目根目录中新建 config 文件夹，密钥放在其中的 key 文件夹中。此时，新建 ci.wx.js 文件</p>
<pre><code class="javascript">const ci = require(&#39;miniprogram-ci&#39;)
let &#123; wxVersion: version, wxDesc: desc &#125; = require(&#39;../package.json&#39;).wx

if (!version) version = &#39;0.0.1&#39;
if (!desc) desc = new Date() + &#39;上传&#39;

const project = new ci.Project(&#123;
  appid: &#39;wx2cd5a54eb60684a4&#39;,
  type: &#39;miniProgram&#39;,
  projectPath: process.cwd() + &#39;/dist/build/mp-weixin&#39;, // 不同的构建工具，Build 后的文件路径可能不同
  privateKeyPath: process.cwd() + &#39;/config/key/private.wx2cd5a54eb60684a4.key&#39;,
  ignores: [&#39;node_modules/**/*&#39;],
&#125;)
ci.upload(&#123;
  project,
  version,
  desc,
  setting: &#123;
    minify: true, // 进行代码压缩
  &#125;,
&#125;)
  .then(res =&gt; &#123;
    console.log(&#39;上传成功&#39;, &#39;\n&#39;, res)
  &#125;)
  .catch(error =&gt; &#123;
    if (error.errCode == -1) &#123;
      console.log(&#39;上传成功&#39;, &#39;\n&#39;, error)
    &#125;
    console.log(&#39;上传失败&#39;, &#39;\n&#39;, error)
    process.exit(-1)
  &#125;)
</code></pre>
<h2 id="package-json-中配置-Node-命令"><a href="#package-json-中配置-Node-命令" class="headerlink" title="package.json 中配置 Node 命令"></a>package.json 中配置 Node 命令</h2><pre><code class="json">&#123;
  &quot;scripts&quot;: &#123;
    &quot;upload-wx&quot;: &quot;npm run build:mp-weixin &amp;&amp; node config/ci.wx.js&quot; // 此处实例为 Uni-App Cli 命令构建出来的项目，具体命令请根据实际情况
  &#125;
&#125;
</code></pre>
<h2 id="通过-HBuilderX-等工具构建的项目"><a href="#通过-HBuilderX-等工具构建的项目" class="headerlink" title="通过 HBuilderX 等工具构建的项目"></a>通过 HBuilderX 等工具构建的项目</h2><h3 id="全局安装"><a href="#全局安装" class="headerlink" title="全局安装"></a>全局安装</h3><pre><code class="shell">npm install -g miniprogram-ci
</code></pre>
<h3 id="查看命令行调用参数"><a href="#查看命令行调用参数" class="headerlink" title="查看命令行调用参数"></a>查看命令行调用参数</h3><pre><code class="shell">miniprogram-ci --help
</code></pre>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre><code class="shell"># upload
export PACKAGE_VERSION = &#123;version:&#39;0.0.1&#39;,desc:new Date() + &#39;上传&#39;&#125;


miniprogram-ci \
  upload \
  # 打包好的文件路径
  --pp ./demo-proj/ \
  # 小程序后台下载下来的密钥存放路径
  --pkp ./private.YOUR_APPID.key \
  # 小程序ID
  --appid YOUR_APPID \
  # 版本信息、描述信息
  --uv PACKAGE_VERSION \
  # 选择机器人 1-30
  -r 1 \
  # 允许 ES6
  --enable-es6 true \
  # 压缩代码
  --minify true \
</code></pre>
<p><strong>PS: 将上述示例编写成对应平台可执行的 shell 脚本（如：.bat 文件）即可。</strong></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3 笔记</title>
    <url>/blog/vue-vue3-notes/</url>
    <content><![CDATA[<h2 id="Fragment（碎片）"><a href="#Fragment（碎片）" class="headerlink" title="Fragment（碎片）"></a>Fragment（碎片）</h2><p><code>vue3</code> 支持 碎片（ <code>fragment</code> ）， 但是仍然推荐单根组件，因为父组件传入的一些非 <code>props</code> 会出问题，没有地方可以绑定。这种情况下，要求开发者明确定义属性应该分布在哪里。</p>
<pre><code class="html">&lt;!-- Layout.vue --&gt;
&lt;template&gt;
  &lt;header&gt;...&lt;/header&gt;
  &lt;main v-bind=&quot;$attrs&quot;&gt;...&lt;/main&gt;
  &lt;footer&gt;...&lt;/footer&gt;
&lt;/template&gt;
</code></pre>
<span id="more"></span>

<h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h2><p>如果只想在 <code>mounted</code> 和 <code>updated</code> 执行相同逻辑，第二个参数可以直接传递一个函数用在组件上时，如果组件是 <strong>单根</strong> 可以正常使用非单根组件有问题，没有执行相关逻辑。</p>
<pre><code class="js">app.directive(&#39;myDire&#39;, &#123;
  beforeMount() &#123;&#125;,
  mounted(el, binding) &#123;
    // binding arg 参数 value 参数的值 modifiers
    //用到的修饰符 oldValue 上一次接受到的值 instance 组件 dir 指令生命周期相关
    console.log(&#39;mounted&#39;, el, binding)
  &#125;,
  beforeUpdate() &#123;&#125;,
  updated(el, binding) &#123;
    console.log(&#39;updated&#39;, el, binding)
  &#125;,
  beforeUnmount() &#123;&#125;,
  unmounted() &#123;&#125;,
&#125;)
app.mount(&#39;#app&#39;)
</code></pre>
<h2 id="穿梭机"><a href="#穿梭机" class="headerlink" title="穿梭机"></a>穿梭机</h2><p>把元素渲染到指定的节点中，而不是深度嵌套，但是仍然是父组件的逻辑子组件</p>
<pre><code class="js">&lt;teleport to=&quot;body&quot;&gt;modal-button&lt;/teleport&gt;
</code></pre>
<h2 id="render（渲染）"><a href="#render（渲染）" class="headerlink" title="render（渲染）"></a>render（渲染）</h2><p><code>v-model</code> 指令扩展为 <code>modelValue</code> 和 <code>onUpdate:modelValue</code> 在模板编译过程中，我们必须自己提供这些 <code>prop</code></p>
<pre><code class="js">render() &#123;
  return Vue.h(&#39;SomeComponent&#39;, &#123;
    &#39;modelValue&#39;: this.modelValue,
    &#39;onUpdate:modelValue&#39;: value =&gt; this.$emit(&#39;update:modelValue&#39;, value),
    &#39;onClick&#39;:&#123;
      &#39;handle&#39;:function ()&#123;&#125;,
      &#39;passive&#39;:true,
      &#39;once&#39;:true// 修饰符
  &#125;
&#125;)
</code></pre>
<h2 id="slots（插槽）"><a href="#slots（插槽）" class="headerlink" title="slots（插槽）"></a>slots（插槽）</h2><p><code>$slots</code> 访问静态插槽每个插槽都是 <code>Vnode</code> 数组</p>
<pre><code class="js">// `&lt;div&gt;&lt;slot :text=&quot;message&quot;&gt;&lt;/slot&gt;&lt;/div&gt;`
return Vue.h(
  &#39;div&#39;,
  &#123;&#125;,
  this.$slots.default(&#123;
    text: this.message,
  &#125;)
)
</code></pre>
<h2 id="plugins（插件）"><a href="#plugins（插件）" class="headerlink" title="plugins（插件）"></a>plugins（插件）</h2><p>通常向 <code>Vue</code> 添加全局级功能。它可以是公开 <code>install()</code> 方法的 <code>object</code> ，也可以是 <code>function</code>。</p>
<p>接收的参数变化了，原来的 <code>new Vue()</code> 变为 用户创建的实例 <code>app</code>， <code>options</code> 没变。往 <code>app.config.globalProperties</code> 上面加属性，事件等，所有实例均可访问</p>
<h2 id="setup-使用"><a href="#setup-使用" class="headerlink" title="setup 使用"></a>setup 使用</h2><p><code>setUp</code> 作为选项，需要返回一个对象，否则会报错。 接受参数为 <code>props</code> 与 <code>context</code>， <code>context</code> 包含 <code>attrs</code> 、 <code>slots</code> 和 <code>emit</code>。</p>
<pre><code class="js">setup(props, context)&#123;
  return &#123; &#125;
&#125;

// 或者

setup(props,&#123; attrs, slots, emit &#125;)&#123;
  return &#123; &#125;
&#125;
</code></pre>
<p><code>context</code> 本身不是响应式的，但是传递的值是 <code>proxy</code> 响应式的。<br><code>setup</code> 的返回值可以提供给<strong>计算属性</strong>、<strong>方法</strong>、<strong>生命周期钩子</strong>、<strong>组件的模板</strong>等等使用，它返回值可以是一个 **<em>函数</em>**，作为 <code>render</code></p>
<h2 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h2><p><code>ref</code> <strong><em>单个原始类型</em></strong> 响应式，需要访问到 <code>value</code></p>
<pre><code class="js">const count = ref(0)
console.log(count.value) // 0

count.value++
console.log(count.value) // 1
</code></pre>
<p><code>reactive</code> <strong><em>对象</em></strong> 每一个值响应式，对象会自动展开 <code>value</code>， 数组，Map 等内部的值不会自动展开，需要自己访问 <code>value</code></p>
<pre><code class="js">const obj = reactive(&#123; count: 0 &#125;)
</code></pre>
<pre><code class="js">const books = reactive([ref(&#39;Vue 3 Guide&#39;)])
// 这里需要 .value
console.log(books[0].value)

const map = reactive(new Map([[&#39;count&#39;, ref(0)]]))
// 这里需要 .value
console.log(map.get(&#39;count&#39;).value)
</code></pre>
<p><code>toRefs</code> 响应式对象解构</p>
<pre><code class="js">import &#123; reactive, toRefs &#125; from &#39;vue&#39;

const book = reactive(&#123;
  author: &#39;Vue Team&#39;,
  year: &#39;2020&#39;,
  title: &#39;Vue 3 Guide&#39;,
  description: &#39;You are reading this book right now ;)&#39;,
  price: &#39;free&#39;,
&#125;)

let &#123; author, title &#125; = toRefs(book)

title.value = &#39;Vue 3 Detailed Guide&#39; // 我们需要使用 .value 作为标题，现在是 ref
console.log(book.title) // &#39;Vue 3 Detailed Guide&#39;
</code></pre>
<p><code>computed</code> 使用时，也不会自动展开。</p>
<p><code>watchEffect</code> 为了根据 <strong><em>反应状态</em></strong> 自动应用和重新应用副作用，我们可以使用 <code>watchEffect</code> 方法。它 <strong><em>立即执行</em></strong> 传入的一个 <strong><em>函数</em></strong> ，同时响应式追踪其 <strong><em>依赖</em></strong> ，并在其依赖变更时重新运行该函数。最终它 <strong><em>返回一个移除监听的函数</em></strong> ，可以手动清除监听，否则跟随组件生命周期，传入的函数会在初始化执行一次。</p>
<p>侦听副作用传入的函数可以接收一个 <code>onInvalidate</code> 函数作入参，用来注册清理失效时的回调。当 1、副作用即将重新执行时；2、侦听器被停止 (如果在 setup() 或生命周期钩子函数中使用了 watchEffect，则在组件卸载时)时，这个失效回调会被触发。因此，清除函数第一次不会执行而是进行注册。</p>
<pre><code class="js">const data = ref(null)
watchEffect(async onInvalidate =&gt; &#123;
  onInvalidate(() =&gt; &#123;...&#125;) // 我们在 Promise 解析之前注册清除函数
  data.value = await fetchData(props.id)
&#125;)
</code></pre>
<blockquote>
<p>异步函数都会隐式地返回一个 <code>Promise</code> ，清理函数必须要在 <code>Promise</code> 被 <code>resolve</code> 之前被注册。</p>
</blockquote>
<p><code>watch</code>与 <code>watchEffect</code> 比较:</p>
<ol>
<li>可以懒执行</li>
<li>更具体说明重新运行</li>
<li>访问变化前后的值</li>
</ol>
<pre><code class="js">// 侦听一个 getter
const state = reactive(&#123; count: 0 &#125;)
watch(
  () =&gt; state.count,
  (count, prevCount) =&gt; &#123;
    /* ... */
  &#125;
)

// 直接侦听ref
const count = ref(0)
watch(count, (count, prevCount) =&gt; &#123;
  /* ... */
&#125;)

// 侦听多个数据源
const fooRef = ref(&#39;AAAAA&#39;)
const barRef = ref(&#39;BBBBB&#39;)
watch([fooRef, barRef], ([foo, bar], [prevFoo, prevBar]) =&gt; &#123;
  /* ... */
&#125;)
</code></pre>
<h2 id="生命周期-与-setup-对应表"><a href="#生命周期-与-setup-对应表" class="headerlink" title="生命周期 与 setup 对应表"></a>生命周期 与 <code>setup</code> 对应表</h2><table>
<thead>
<tr>
<th align="center">生命周期</th>
<th align="center">setup</th>
</tr>
</thead>
<tbody><tr>
<td align="center">beforeCreate</td>
<td align="center">Not needed*</td>
</tr>
<tr>
<td align="center">created</td>
<td align="center">Not needed*</td>
</tr>
<tr>
<td align="center">beforeMount</td>
<td align="center">onBeforeMount</td>
</tr>
<tr>
<td align="center">mounted</td>
<td align="center">onMounted</td>
</tr>
<tr>
<td align="center">beforeUpdate</td>
<td align="center">onBeforeUpdate</td>
</tr>
<tr>
<td align="center">updated</td>
<td align="center">onUpdated</td>
</tr>
<tr>
<td align="center">beforeUnmount</td>
<td align="center">onBeforeUnmount</td>
</tr>
<tr>
<td align="center">unmounted</td>
<td align="center">onUnmounted</td>
</tr>
<tr>
<td align="center">errorCaptured</td>
<td align="center">onErrorCaptured</td>
</tr>
<tr>
<td align="center">renderTracked</td>
<td align="center">onRenderTracked</td>
</tr>
<tr>
<td align="center">renderTriggered</td>
<td align="center">onRenderTriggered</td>
</tr>
</tbody></table>
<h2 id="provide-inject"><a href="#provide-inject" class="headerlink" title="provide/inject"></a>provide/inject</h2><h2 id="函数组件"><a href="#函数组件" class="headerlink" title="函数组件"></a>函数组件</h2><h2 id="global-API"><a href="#global-API" class="headerlink" title="global API"></a>global API</h2><table>
<thead>
<tr>
<th align="center">变化前</th>
<th align="center">变化后</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Vue.config</td>
<td align="center">app.config</td>
</tr>
<tr>
<td align="center">Vue.config.productionTip</td>
<td align="center">removed</td>
</tr>
<tr>
<td align="center">Vue.config.ignoredElements</td>
<td align="center">app.config.isCustomElement</td>
</tr>
<tr>
<td align="center">Vue.component</td>
<td align="center">app.component</td>
</tr>
<tr>
<td align="center">Vue.directive</td>
<td align="center">app.directive</td>
</tr>
<tr>
<td align="center">Vue.mixin</td>
<td align="center">app.mixin</td>
</tr>
<tr>
<td align="center">Vue.use</td>
<td align="center">app.use</td>
</tr>
</tbody></table>
<p><code>nextTick</code> 以及所有的 <code>api</code> 不再挂载到全局，而是模块导出</p>
<pre><code class="js">import &#123; nextTick &#125; from &#39;vue&#39;
</code></pre>
<h2 id="一些变化"><a href="#一些变化" class="headerlink" title="一些变化"></a>一些变化</h2><h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><p>用于自定义组件时，<code>v-model</code>、<code>prop</code> 和 <strong><em>事件默认名称</em></strong> 已更改</p>
<ul>
<li><p>prop：value -&gt; modelValue</p>
</li>
<li><p>event：input -&gt; update:modelValue</p>
</li>
</ul>
<p><code>v-bind</code> 的 <code>.sync</code> 修饰符和组件的 <code>model</code> 选项已移除，可用 <code>v-model</code> 作为代替</p>
<p>若需要更改 <code>model</code> 名称，而不是更改组件内的 <code>model</code> 选项，那么现在我们可以将一个 <code>argument</code> 传递给 <code>model</code></p>
<pre><code class="html">&lt;ChildComponent :title=&quot;pageTitle&quot; @update:title=&quot;pageTitle = $event&quot; /&gt;

&lt;!-- 简写: --&gt;
&lt;ChildComponent v-model:title=&quot;pageTitle&quot; /&gt;
</code></pre>
<p>现在可以在同一个组件上使用多个 v-model 进行双向绑定</p>
<pre><code class="html">&lt;ChildComponent
  :title=&quot;pageTitle&quot;
  @update:title=&quot;pageTitle = $event&quot;
  :content=&quot;pageContent&quot;
  @update:content=&quot;pageContent = $event&quot;
/&gt;

&lt;!-- 简写： --&gt;
&lt;ChildComponent v-model:title=&quot;pageTitle&quot; v-model:content=&quot;pageContent&quot; /&gt;
</code></pre>
<p>现在可以自定义 <code>v-model</code> 修饰符。</p>
<h3 id="API-Reference（详情请参考文档）"><a href="#API-Reference（详情请参考文档）" class="headerlink" title="API Reference（详情请参考文档）"></a>API Reference（详情请参考文档）</h3>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3 响应式原理</title>
    <url>/blog/vue-vue3-reactivity-in-depth/</url>
    <content><![CDATA[<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ol>
<li>ES6 <code>Set</code> 和 <code>Map</code> 数据结构</li>
<li>ES6 <code>Proxy</code> 代理</li>
</ol>
<span id="more"></span>

<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="javascript">/**
 * 判断参数是否为对象
 * @param &#123;object&#125; obj
 */
const isObj = obj =&gt; &#123;
  return Object.prototype.toString.call(obj) === &#39;[object Object]&#39;
&#125;

/**
 * 可以对 key 产生影响的函数，本示例中的 logger 函数
 */
const efftctStack = []

// Map 对象
// &#123;
//   target:&#123;
//     key: [fn1,fn2,fn3,...fn]
//   &#125;
// &#125;
const targetMap = new Map()

const track = (target, key) =&gt; &#123;
  const rxFn = efftctStack[efftctStack.length - 1]
  if (!rxFn) return // 如果没有能对属性产生影响的函数，就返回，停止依赖收集

  let targetKeyMap = targetMap.get(target)
  if (!targetKeyMap) &#123;
    targetKeyMap = new Map()
    targetMap.set(target, targetKeyMap)
  &#125;
  let keySet = targetKeyMap.get(key)
  if (!keySet) &#123;
    keySet = new Set()
    targetKeyMap.set(key, keySet)
  &#125;
  keySet.add(rxFn)
&#125;

const trigger = (target, key, value) =&gt; &#123;
  let targetKeyMap = targetMap.get(target)
  if (!targetKeyMap) return
  let keySet = targetKeyMap.get(key)
  if (!keySet) return
  keySet.forEach(fn =&gt; &#123;
    fn() // logger()
  &#125;)
&#125;

const reactive = originObj =&gt; &#123;
  if (!isObj(originObj)) return originObj

  const proxyObj = new Proxy(originObj, &#123;
    get(target, key, receiver) &#123;
      let res = Reflect.get(target, key, receiver)
      console.log(&#39;get :&gt;&gt; &#39;, key)
      track(target, key)
      return isObj(res) ? reactive(res) : res
    &#125;,
    set(target, key, value, receiver) &#123;
      let res = Reflect.set(target, key, value, receiver)
      trigger(target, key, value)
      return res
    &#125;,
  &#125;)

  return proxyObj
&#125;

const effect = fn =&gt; &#123;
  const rxFn = function () &#123;
    try &#123;
      efftctStack.push(rxFn)
      return fn()
    &#125; finally &#123;
      efftctStack.pop()
    &#125;
  &#125;
  rxFn()
&#125;

const logger = params =&gt; &#123;
  console.log(&#39;信息打印 :&gt;&gt; &#39;, params)
&#125;

const demoData = reactive(&#123; a: 0 &#125;)

effect(() =&gt; logger(demoData.a))

setInterval(() =&gt; &#123;
  demoData.a++
&#125;, 1000)
</code></pre>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>工具设置</title>
    <url>/blog/others-formulae-settings/</url>
    <content><![CDATA[<h1 id="NodeJS"><a href="#NodeJS" class="headerlink" title="NodeJS"></a>NodeJS</h1><p><code>.npmrc</code> 配置</p>
<pre><code class="conf">registry=https://registry.npm.taobao.org/
sass_binary_site=https://npm.taobao.org/mirrors/node-sass
chromedriver_cdnurl=https://npm.taobao.org/mirrors/chromedriver
phantomjs_cdnurl=https://npm.taobao.org/mirrors/phantomjs
electron_mirror=https://npm.taobao.org/mirrors/electron
</code></pre>
<p>该文件的一般路径为：<code>~/.npmrc</code></p>
<span id="more"></span>

<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p>大多数时候，我们的机器上会有很多的 Git Host，比如公司 Gitlab、 Github、 OSChina 等，那我们就需要在本地配置多个 SSH Key，使得不同的 Host 能使用不同的 SSH Key 。配置方法如下（以公司 Gitlab 和个人 Github 为例）：</p>
<p>为公司 Gitlab 生成一对秘钥 SSH Key</p>
<pre><code class="shell">ssh-keygen -t rsa -C &#39;youremail@xxx.com&#39; -f ~/.ssh/gitlab_id-rsa
</code></pre>
<p>为个人 Github 生成一对秘钥 SSH Key</p>
<pre><code class="shell">ssh-keygen -t rsa -C &#39;yourotheremail@xxx.com&#39; -f ~/.ssh/github_id-rsa
</code></pre>
<p>这时去查看 <code>~/.ssh</code> 目录下的文件，会有 <code>gitlab_id-rsa</code>、 <code>gitlab_id-rsa.pub</code> 和 <code>github_id-rsa</code>、 <code>github_id-rsa.pub</code> 四个文件</p>
<p>在 <code>~/.ssh</code> 目录下新建名称为 <code>config</code> 的文件（无后缀名）。用于配置多个不同的 host 使用不同的 SSH Key，内容如下：</p>
<pre><code># 配置文件参数
# Host : Host 可以看作是一个你要识别的模式，对识别的模式，进行配置对应的的主机名和 ssh 文件（根据实际情况进行修改）
# HostName : 要登录主机的主机名（根据实际情况进行修改）
# User : 登录名，一般是 ssh 路径中主机名的前缀
# IdentityFile : 指明上面 User 对应的 identityFile 路径

# gitlab
Host gitlab.com
HostName gitlab.com
PreferredAuthentications publickey
User git
IdentityFile ~/.ssh/gitlab_id-rsa

# github
Host github.com
HostName github.com
PreferredAuthentications publickey
User git
IdentityFile ~/.ssh/github_id-rsa
</code></pre>
<p>按照上面的步骤分别往 Gitlab 和 Github 上添加生成的公钥 <code>gitlab_id-rsa.pub</code> 和 <code>github_id-rsa.pub</code></p>
<p>OK，大功告成，再次执行 git 命令验证就已经不需要再次验证权限了。</p>
<h1 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a>Homebrew</h1><p>详细教程，请参考：<a href="https://mirrors.tuna.tsinghua.edu.cn/help/homebrew/">Homebrew 国内镜像使用教程</a></p>
<h1 id="Alfred"><a href="#Alfred" class="headerlink" title="Alfred"></a>Alfred</h1><h2 id="外观设置（字体、颜色）"><a href="#外观设置（字体、颜色）" class="headerlink" title="外观设置（字体、颜色）"></a>外观设置（字体、颜色）</h2><pre><code class="json">&#123;
  &quot;alfredtheme&quot;: &#123;
    &quot;result&quot;: &#123;
      &quot;textSpacing&quot;: 7,
      &quot;subtext&quot;: &#123;
        &quot;size&quot;: 20,
        &quot;colorSelected&quot;: &quot;#FFFFFFA7&quot;,
        &quot;font&quot;: &quot;FZJingLeiS-R-GB&quot;,
        &quot;color&quot;: &quot;#FFFFFF4F&quot;
      &#125;,
      &quot;shortcut&quot;: &#123;
        &quot;size&quot;: 24,
        &quot;colorSelected&quot;: &quot;#FFFFFF9E&quot;,
        &quot;font&quot;: &quot;FZJingLeiS-R-GB&quot;,
        &quot;color&quot;: &quot;#FFD478FF&quot;
      &#125;,
      &quot;backgroundSelected&quot;: &quot;#00000051&quot;,
      &quot;text&quot;: &#123;
        &quot;size&quot;: 30,
        &quot;colorSelected&quot;: &quot;#37ADFFFF&quot;,
        &quot;font&quot;: &quot;FZJingLeiS-R-GB&quot;,
        &quot;color&quot;: &quot;#FFFFFF8A&quot;
      &#125;,
      &quot;iconPaddingHorizontal&quot;: 6,
      &quot;roundness&quot;: 0,
      &quot;paddingVertical&quot;: 3,
      &quot;iconSize&quot;: 44
    &#125;,
    &quot;search&quot;: &#123;
      &quot;background&quot;: &quot;#00000000&quot;,
      &quot;paddingVertical&quot;: 5,
      &quot;spacing&quot;: 5,
      &quot;text&quot;: &#123;
        &quot;size&quot;: 36,
        &quot;colorSelected&quot;: &quot;#000000FF&quot;,
        &quot;font&quot;: &quot;FZJingLeiS-R-GB&quot;,
        &quot;color&quot;: &quot;#FFFFFFFF&quot;
      &#125;,
      &quot;roundness&quot;: 0,
      &quot;backgroundSelected&quot;: &quot;#B2D7FFFF&quot;
    &#125;,
    &quot;window&quot;: &#123;
      &quot;color&quot;: &quot;#00000085&quot;,
      &quot;paddingHorizontal&quot;: 0,
      &quot;width&quot;: 573,
      &quot;borderPadding&quot;: 0,
      &quot;borderColor&quot;: &quot;#000000FF&quot;,
      &quot;blur&quot;: 25,
      &quot;roundness&quot;: 3,
      &quot;paddingVertical&quot;: 5
    &#125;,
    &quot;credit&quot;: &quot;.·°oO&quot;,
    &quot;separator&quot;: &#123;
      &quot;color&quot;: &quot;#CD00FFFF&quot;,
      &quot;thickness&quot;: 0
    &#125;,
    &quot;scrollbar&quot;: &#123;
      &quot;color&quot;: &quot;#00000033&quot;,
      &quot;thickness&quot;: 3
    &#125;,
    &quot;name&quot;: &quot;MuYesAlfredTheme&quot;
  &#125;
&#125;
</code></pre>
<p><strong>复制以上代码，生成 <code>customized.alfredappearance</code> 文件，双击即可。字体使用的是<a href="https://gitee.com/chivesssss/upic/raw/master/uPic/2021-03-10/FZJLJW.ttf">方正静蕾体</a></strong></p>
<p>详细教程，请参考：<a href="https://juejin.cn/post/6844904062484217863">高效 Alfred 进阶</a></p>
<h1 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a>Visual Studio Code</h1><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul>
<li>删除行内容： <code>command + shift + k</code></li>
<li>删除左侧内容： <code>command + backspace</code></li>
<li>删除右侧内容： <code>command + delete</code></li>
<li>移动到行首行尾：<code>command + ←</code> 、 <code>command + →</code></li>
<li>上下移动： <code>option + ↑</code> 、 <code>option + ↓</code></li>
<li>移动到文档的开头和末尾： <code>command + ↑</code> 、 <code>command + ↓</code></li>
<li>回到上一个光标的位置： <code>command + u</code></li>
<li>花括号跳转： <code>command + shift + \</code></li>
<li>块注释： <code>Option + Shift + a</code></li>
<li>快速打开文件： <code>command + p</code></li>
</ul>
<h2 id="插件推荐及使用"><a href="#插件推荐及使用" class="headerlink" title="插件推荐及使用"></a>插件推荐及使用</h2><h3 id="REST-Client"><a href="#REST-Client" class="headerlink" title="REST Client"></a>REST Client</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>在测试 REST API 的时候，想必大家都会有不同的工具选择。如果是基于 CLI 的话，大家应该会选择 cURL。如果是 GUI 工具的话，相信很多人都会使用 Postman。不过今天，如果开发是使用 vs code，那么我推荐 REST Client 插件</p>
<p>我们在 vs code 新建一个以 <code>.http</code> 或者 <code>.rest</code> 结尾的文件，填入你的 HTTP 请求，点击 Send Request，或者右键选择 Send Request，或者直接用快捷键 Ctrl+Alt+R ，你的 REST API 就执行了，然后 API Response 就会显示在右边区域。是不是很方便？</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol>
<li>通过 <code>###</code> 分隔符，同一个 HTTP 文件里可以涵盖多个 HTTP 请求。</li>
<li>Authentication: REST Client 支持了 Basic Auth，SSL Client Certificates，Azure Active Directory 等多种验证机制</li>
<li>Cookies 的支持</li>
<li>支持 HTTP 3xx 的重定向</li>
<li>变量的支持：环境变量，文件变量，预定义的系统变量等等</li>
</ol>
<h4 id="配置文件示例"><a href="#配置文件示例" class="headerlink" title="配置文件示例"></a>配置文件示例</h4><pre><code class="conf">@hostname = api.example.com
@port = 8080
@host = &#123;&#123;hostname&#125;&#125;:&#123;&#123;port&#125;&#125;
@contentType = application/json

###
@name = hello

# @name login
POST https://&#123;&#123;host&#125;&#125;/api/user/login HTTP/1.1

content-type: &#123;&#123;contentType&#125;&#125;

&#123;
  &quot;username&quot;:&#123;&#123;name&#125;&#125;,
  &quot;password&quot;:&quot;123&quot;
&#125;

###
@authToken = &#123;&#123;login.response.body.result.data.token&#125;&#125;

# @name userInfo
GET https://&#123;&#123;host&#125;&#125;/api/user/info HTTP/1.1

Content-Type: &#123;&#123;contentType&#125;&#125;
X-Authorization:&#123;&#123;authToken&#125;&#125;
</code></pre>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="VS-Code-中路径别名-提示和函数跳转等问题"><a href="#VS-Code-中路径别名-提示和函数跳转等问题" class="headerlink" title="VS Code 中路径别名 @ 提示和函数跳转等问题"></a>VS Code 中路径别名 <code>@</code> 提示和函数跳转等问题</h3><ul>
<li>如果我们用了路径别名 <code>@</code> 等，那么我们的插件 <code>path-intellisense</code> 将默认不支持自动提示，但是我们对这个插件的 <code>mappings</code> 设置如下，就可以了。</li>
</ul>
<pre><code class="jsonc">&#123;
  // setting.json
  &quot;path-intellisense.mappings&quot;: &#123;
    &quot;@&quot;: &quot;$&#123;workspaceRoot&#125;/src&quot;
  &#125;
&#125;
</code></pre>
<ul>
<li>我们希望 Ctrl + 鼠标左键点击一个外部方法时，能够快速跳转到对应的外部文件，很多人说 Webstorm 都可以，其实 VS Code 也可以，同样的原因，之所以不能跳转，也是因为路径别名 <code>@</code> 不能被 VS Code 识别，所以我们同样需要在 VS Code 里面做映射。在项目 <code>package.json</code> 所在同级目录下创建文件<code>jsconfig.json</code> ,写上如下配置即可。</li>
</ul>
<pre><code class="json">&#123;
  &quot;compilerOptions&quot;: &#123;
    &quot;target&quot;: &quot;ES6&quot;,
    &quot;module&quot;: &quot;commonjs&quot;,
    &quot;allowSyntheticDefaultImports&quot;: true,
    &quot;baseUrl&quot;: &quot;./&quot;,
    &quot;paths&quot;: &#123;
      &quot;@/*&quot;: [&quot;src/*&quot;]
    &#125;
  &#125;,
  &quot;exclude&quot;: [&quot;node_modules&quot;]
&#125;
</code></pre>
<h1 id="iTerm2"><a href="#iTerm2" class="headerlink" title="iTerm2"></a>iTerm2</h1><h2 id="如何一键安装"><a href="#如何一键安装" class="headerlink" title="如何一键安装"></a>如何一键安装</h2><p>国内：</p>
<pre><code class="bash">sh -c &quot;$(curl -fsSL https://code.aliyun.com/kar/ohmyiterm2/raw/master/install.sh)&quot; &quot;&quot; aliyun
</code></pre>
<p>国外：</p>
<pre><code class="bash">sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/KingFalse/ohmyiterm2/master/install.sh)&quot; &quot;&quot; github
</code></pre>
<p><strong>它安装了什么</strong></p>
<ul>
<li>安装 Xcode Command Line Tools</li>
<li>安装 <a href="https://github.com/ohmyzsh/ohmyzsh">ohmyzsh</a></li>
<li>安装 <a href="https://github.com/paulirish/git-open">ohmyzsh 插件 git-open</a></li>
<li>安装 <a href="https://github.com/zsh-users/zsh-autosuggestions">ohmyzsh 插件 zsh-autosuggestions</a></li>
<li>安装 <a href="https://github.com/zsh-users/zsh-syntax-highlighting">ohmyzsh 插件 zsh-syntax-highlighting</a></li>
<li>安装 <a href="https://github.com/wting/autojump">ohmyzsh 插件 autojump</a></li>
<li>安装 <a href="https://starship.rs/">ohmyzsh 主题 starship</a></li>
<li>安装 <a href="https://iterm2.com/">iTerm2</a></li>
<li>安装 <a href="https://www.iterm2.com/documentation-utilities.html">iTerm2-Utilities 扩展</a></li>
<li>安装 <a href="https://github.com/dracula/iterm">iTerm2-Dracula 主题</a></li>
<li>安装 <a href="https://ohse.de/uwe/software/lrzsz.html">lrzsz 并配置 Triggers</a></li>
<li>安装 sshpass</li>
</ul>
<h2 id="如何去除蓝色三角形？"><a href="#如何去除蓝色三角形？" class="headerlink" title="如何去除蓝色三角形？"></a>如何去除蓝色三角形？</h2><p><img src="https://cdn.jsdelivr.net/gh/chivesssss/picture-store@master/uPic/2021/03/07/12/55/iterm2-%E8%93%9D%E8%89%B2%E4%B8%89%E8%A7%92%E5%BD%A2.jpeg" alt="操作示例"></p>
<h2 id="ohmyzsh-主题-starship-配置文件-config-starship-toml"><a href="#ohmyzsh-主题-starship-配置文件-config-starship-toml" class="headerlink" title="ohmyzsh 主题 starship 配置文件(~/.config/starship.toml)"></a><a href="https://starship.rs/">ohmyzsh 主题 starship</a> 配置文件(~/.config/starship.toml)</h2><pre><code class="toml"># Don&#39;t print a new line at the start of the prompt
add_newline = false
[aws]
disabled = true
[battery]
disabled = true
# Replace the &quot;❯&quot; symbol in the prompt with &quot;➜&quot;
[character]
success_symbol = &quot;[➜](bold green)&quot;
error_symbol = &quot;[✗](bold red)&quot;
symbol = &quot;[➜](bold green)&quot;
[line_break]
disabled = false
</code></pre>
<h1 id="Windows-Terminal"><a href="#Windows-Terminal" class="headerlink" title="Windows Terminal"></a>Windows Terminal</h1><h2 id="第一步：安装相关的模块和-PowerLine-主题"><a href="#第一步：安装相关的模块和-PowerLine-主题" class="headerlink" title="第一步：安装相关的模块和 PowerLine 主题"></a>第一步：安装相关的模块和 <code>PowerLine</code> 主题</h2><p>如果你使用管理员权限打开 PowerShell 并且想把 oh-my-posh 安装到所有用户，输入</p>
<pre><code class="shell">Install-Module posh-git
Install-Module oh-my-posh
</code></pre>
<p>否则输入</p>
<pre><code class="shell">Install-Module posh-git -Scope CurrentUser
Install-Module oh-my-posh -Scope CurrentUser
</code></pre>
<p>安装完成后，输入</p>
<pre><code class="shell">Import-Module posh-git
Import-Module oh-my-posh
Set-Theme PowerLine
</code></pre>
<p>如果出现以下报错</p>
<pre><code class="shell"> 无法加载文件 C:\Users\Hong\Documents\WindowsPowerShell\Microsoft.PowerShell
_profile.ps1，因为在此系统上禁止运行脚本。有关详细信息，请参阅 http://go.micros
oft.com/fwlink/?LinkID=135170 中的 about_Execution_Policies。
所在位置 行:1 字符: 3
</code></pre>
<p>以管理员身份再次运行 Windows Terminal 并输入以下命令。（没有报错请忽略）</p>
<pre><code class="shell">Set-ExecutionPolicy RemoteSigned
</code></pre>
<p>但是这次使用 <code>Import-Module</code> 的指令，再次启动 <code>PowerShell</code> 就会发现没有效果，这是因为这些指令仅限于本次会话的 <code>PowerShell</code> 有效，因此，若要使这一效果在每次启动的时候都有效，那就要将其添加到启动脚本中。打开<code>~\Documents\WindowsPowerShell</code>新建文本文档，命名为<code>Microsoft.PowerShell_profile.ps1</code>（记得开拓展名显示），输入以下内容，保存。</p>
<pre><code class="shell">Import-Module posh-git
Import-Module oh-my-posh
Set-Theme PowerLine
</code></pre>
<p>这样，在每次 <code>PoweShell</code> 打开的时候都会加载自定义的文件并启用 <code>PowerLine</code> 主题。</p>
<h2 id="第二步：注册安装字体"><a href="#第二步：注册安装字体" class="headerlink" title="第二步：注册安装字体"></a>第二步：注册安装字体</h2><p>这里使用的是更纱等距黑体，即 <code>Sarasa Term SC</code> 这个名称配置 <code>windows Terminal</code> 字体时要用到（记得有这回事）要不然小图标还是乱码。这款字体是开源字体，可以美观地显示中文，而且是等宽字体，也就说在终端中不会出现排版错误，这款字体你可以在<a href="https://github.com/be5invis/Sarasa-Gothic/releases">这里下载</a>。</p>
<h2 id="第三步：改造终端的配置文件"><a href="#第三步：改造终端的配置文件" class="headerlink" title="第三步：改造终端的配置文件"></a>第三步：改造终端的配置文件</h2><p><code>Windows Terminal</code> 的配置文件储存在 <code>~\AppData\Local\Packages\Microsoft.WindowsTerminal_8wekyb3d8bbwe\LocalState\settings.json</code> 这个 <code>json</code> 文件中，在代码编辑器中打开并编辑（比如 VS Code）。</p>
<pre><code class="jsonc">// This file was initially generated by Windows Terminal 1.0.1401.0
// It should still be usable in newer versions, but newer versions might have additional
// settings, help text, or changes that you will not see unless you clear this file
// and let us generate a new one for you.

// To view the default settings, hold &quot;alt&quot; while clicking on the &quot;Settings&quot; button.
// For documentation on these settings, see: https://aka.ms/terminal-documentation
&#123;
  &quot;$schema&quot;: &quot;https://aka.ms/terminal-profiles-schema&quot;,

  &quot;defaultProfile&quot;: &quot;&#123;61c54bbd-c2c6-5271-96e7-009a87ff44bf&#125;&quot;,

  // You can add more global application settings here.
  // To learn more about global settings, visit https://aka.ms/terminal-global-settings

  // If enabled, selections are automatically copied to your clipboard.
  &quot;copyOnSelect&quot;: false,

  // If enabled, formatted data is also copied to your clipboard
  &quot;copyFormatting&quot;: false,

  // A profile specifies a command to execute paired with information about how it should look and feel.
  // Each one of them will appear in the &#39;New Tab&#39; dropdown,
  //   and can be invoked from the commandline with `wt.exe -p xxx`
  // To learn more about profiles, visit https://aka.ms/terminal-profile-settings
  &quot;profiles&quot;: &#123;
    &quot;defaults&quot;: &#123;
      // Put settings here that you want to apply to all profiles.
    &#125;,
    &quot;list&quot;: [
      &#123;
        // Make changes here to the powershell.exe profile.
        &quot;guid&quot;: &quot;&#123;61c54bbd-c2c6-5271-96e7-009a87ff44bf&#125;&quot;,
        &quot;name&quot;: &quot;Windows PowerShell&quot;,
        &quot;commandline&quot;: &quot;powershell.exe&quot;,
        &quot;hidden&quot;: false,
        //以下是新增加的配置项
        &quot;closeOnExit&quot;: true,
        &quot;colorScheme&quot;: &quot;Dracula&quot;, //颜色主题名称,就是schemes下面的每个实例的 name 值
        &quot;cursorColor&quot;: &quot;#ffffff&quot;, //光标颜色
        &quot;cursorShape&quot;: &quot;filledBox&quot;, //光标类型  可选 bar empytBox filledBox vintage
        &quot;fontFace&quot;: &quot;Sarasa Term SC&quot;, //字体名称  安装字体时的字体名称
        &quot;fontSize&quot;: 12, //字体大小
        &quot;historySize&quot;: 8001,
        // &quot;icon&quot; : &quot;D:\\image\\phone.jpg&quot;,     //程序的小图标，也就是在标题栏和新建中显示的图标地址
        // &quot;backgroundImage&quot;: &quot;D:\\image\\bga.jpg&quot;,  //配置背景图片地址
        &quot;acrylicOpacity&quot;: 0.75, //不透明度，值越大，背景就越浓，否则就越淡
        // &quot;backgroundImageOpacity&quot;: 0.25,      //背景图片的透明度
        &quot;padding&quot;: &quot;0, 0, 0, 0&quot;,
        &quot;snapOnInput&quot;: true,
        &quot;startingDirectory&quot;: &quot;%USERPROFILE%&quot;,
        &quot;useAcrylic&quot;: true, //是否开启毛玻璃特效，值为false的时候就没有毛玻璃特效
        &quot;tabTitle&quot;: &quot;chessYu&quot; //标签名称
      &#125;,
      &#123;
        // Make changes here to the cmd.exe profile.
        &quot;guid&quot;: &quot;&#123;0caa0dad-35be-5f56-a8ff-afceeeaa6101&#125;&quot;,
        &quot;name&quot;: &quot;命令提示符&quot;,
        &quot;commandline&quot;: &quot;cmd.exe&quot;,
        &quot;hidden&quot;: false
      &#125;,
      &#123;
        &quot;guid&quot;: &quot;&#123;b453ae62-4e3d-5e58-b989-0a998ec441b8&#125;&quot;,
        &quot;hidden&quot;: false,
        &quot;name&quot;: &quot;Azure Cloud Shell&quot;,
        &quot;source&quot;: &quot;Windows.Terminal.Azure&quot;
      &#125;
    ]
  &#125;,

  // Add custom color schemes to this array.
  // To learn more about color schemes, visit https://aka.ms/terminal-color-schemes
  &quot;schemes&quot;: [
    &#123;
      &quot;name&quot;: &quot;Dracula&quot;,
      &quot;black&quot;: &quot;#000000&quot;,
      &quot;red&quot;: &quot;#ff5555&quot;,
      &quot;green&quot;: &quot;#50fa7b&quot;,
      &quot;yellow&quot;: &quot;#f1fa8c&quot;,
      &quot;blue&quot;: &quot;#bd93f9&quot;,
      &quot;purple&quot;: &quot;#ff79c6&quot;,
      &quot;cyan&quot;: &quot;#8be9fd&quot;,
      &quot;white&quot;: &quot;#bbbbbb&quot;,
      &quot;brightBlack&quot;: &quot;#555555&quot;,
      &quot;brightRed&quot;: &quot;#ff5555&quot;,
      &quot;brightGreen&quot;: &quot;#50fa7b&quot;,
      &quot;brightYellow&quot;: &quot;#f1fa8c&quot;,
      &quot;brightBlue&quot;: &quot;#bd93f9&quot;,
      &quot;brightPurple&quot;: &quot;#ff79c6&quot;,
      &quot;brightCyan&quot;: &quot;#8be9fd&quot;,
      &quot;brightWhite&quot;: &quot;#ffffff&quot;,
      &quot;background&quot;: &quot;#1e1f29&quot;,
      &quot;foreground&quot;: &quot;#f8f8f2&quot;
    &#125;,
    &#123;
      &quot;name&quot;: &quot;Ubuntu&quot;,
      &quot;black&quot;: &quot;#2e3436&quot;,
      &quot;red&quot;: &quot;#cc0000&quot;,
      &quot;green&quot;: &quot;#4e9a06&quot;,
      &quot;yellow&quot;: &quot;#c4a000&quot;,
      &quot;blue&quot;: &quot;#3465a4&quot;,
      &quot;purple&quot;: &quot;#75507b&quot;,
      &quot;cyan&quot;: &quot;#06989a&quot;,
      &quot;white&quot;: &quot;#d3d7cf&quot;,
      &quot;brightBlack&quot;: &quot;#555753&quot;,
      &quot;brightRed&quot;: &quot;#ef2929&quot;,
      &quot;brightGreen&quot;: &quot;#8ae234&quot;,
      &quot;brightYellow&quot;: &quot;#fce94f&quot;,
      &quot;brightBlue&quot;: &quot;#729fcf&quot;,
      &quot;brightPurple&quot;: &quot;#ad7fa8&quot;,
      &quot;brightCyan&quot;: &quot;#34e2e2&quot;,
      &quot;brightWhite&quot;: &quot;#eeeeec&quot;,
      &quot;background&quot;: &quot;#300a24&quot;,
      &quot;foreground&quot;: &quot;#eeeeec&quot;
    &#125;,
    &#123;
      &quot;name&quot;: &quot;AdventureTime&quot;,
      &quot;black&quot;: &quot;#050404&quot;,
      &quot;red&quot;: &quot;#bd0013&quot;,
      &quot;green&quot;: &quot;#4ab118&quot;,
      &quot;yellow&quot;: &quot;#e7741e&quot;,
      &quot;blue&quot;: &quot;#0f4ac6&quot;,
      &quot;purple&quot;: &quot;#665993&quot;,
      &quot;cyan&quot;: &quot;#70a598&quot;,
      &quot;white&quot;: &quot;#f8dcc0&quot;,
      &quot;brightBlack&quot;: &quot;#4e7cbf&quot;,
      &quot;brightRed&quot;: &quot;#fc5f5a&quot;,
      &quot;brightGreen&quot;: &quot;#9eff6e&quot;,
      &quot;brightYellow&quot;: &quot;#efc11a&quot;,
      &quot;brightBlue&quot;: &quot;#1997c6&quot;,
      &quot;brightPurple&quot;: &quot;#9b5953&quot;,
      &quot;brightCyan&quot;: &quot;#c8faf4&quot;,
      &quot;brightWhite&quot;: &quot;#f6f5fb&quot;,
      &quot;background&quot;: &quot;#1f1d45&quot;,
      &quot;foreground&quot;: &quot;#f8dcc0&quot;
    &#125;
  ],

  // Add custom keybindings to this array.
  // To unbind a key combination from your defaults.json, set the command to &quot;unbound&quot;.
  // To learn more about keybindings, visit https://aka.ms/terminal-keybindings
  &quot;keybindings&quot;: [
    // Copy and paste are bound to Ctrl+Shift+C and Ctrl+Shift+V in your defaults.json.
    // These two lines additionally bind them to Ctrl+C and Ctrl+V.
    // To learn more about selection, visit https://aka.ms/terminal-selection
    &#123; &quot;command&quot;: &#123; &quot;action&quot;: &quot;copy&quot;, &quot;singleLine&quot;: false &#125;, &quot;keys&quot;: &quot;ctrl+c&quot; &#125;,
    &#123; &quot;command&quot;: &quot;paste&quot;, &quot;keys&quot;: &quot;ctrl+v&quot; &#125;,

    // Press Ctrl+Shift+F to open the search box
    &#123; &quot;command&quot;: &quot;find&quot;, &quot;keys&quot;: &quot;ctrl+shift+f&quot; &#125;,

    // Press Alt+Shift+D to open a new pane.
    // - &quot;split&quot;: &quot;auto&quot; makes this pane open in the direction that provides the most surface area.
    // - &quot;splitMode&quot;: &quot;duplicate&quot; makes the new pane use the focused pane&#39;s profile.
    // To learn more about panes, visit https://aka.ms/terminal-panes
    &#123;
      &quot;command&quot;: &#123;
        &quot;action&quot;: &quot;splitPane&quot;,
        &quot;split&quot;: &quot;auto&quot;,
        &quot;splitMode&quot;: &quot;duplicate&quot;
      &#125;,
      &quot;keys&quot;: &quot;alt+shift+d&quot;
    &#125;
  ]
&#125;
</code></pre>
<h2 id="第四步：选颜色主题"><a href="#第四步：选颜色主题" class="headerlink" title="第四步：选颜色主题"></a>第四步：选颜色主题</h2><p>配置文件内置了几个颜色主题，并且都是亮色的，很不符合一些人的胃口，这时候我们就需要在 <a href="https://github.com/mbadolato/iTerm2-Color-Schemes">mbadolato/iTerm2-Color-Schemes</a> 这个仓库中寻找自己喜欢的颜色主题，这里颜色主题有足足两百多个，选完自己喜欢的，就可以到仓库的 <a href="https://github.com/mbadolato/iTerm2-Color-Schemes/tree/master/windowsterminal">windowsterminal</a> 文件夹里面下载适用于 <code>Windows Terminal</code> 的格式。选好之后，粘贴到 <code>schemes</code> 这个数组里，然后在想应用的配置文件里的 <code>colorScheme</code> 设置为你新粘贴的主题的名字。保存后 <code>Windows Terminal</code> 是实时更新的，看看最终的配置效果。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>软件</tag>
        <tag>设置</tag>
      </tags>
  </entry>
  <entry>
    <title>知识点梳理</title>
    <url>/blog/interviews-interview-formatted/</url>
    <content><![CDATA[<h1 id="原始类型、引用类型"><a href="#原始类型、引用类型" class="headerlink" title="原始类型、引用类型"></a>原始类型、引用类型</h1><p>原始类型：<code>undefined</code>、<code>null</code>、<code>boolean</code>、 <code>string</code>、 <code>number</code>、 <code>symbol</code></p>
<p><code>typeof null === &#39;object&#39;</code> 是一个历史悠久的 bug，因为 <code>000</code> 开始表示对象， <code>null</code> 也是全零</p>
<p>原始类型存储的是值，引用类型存储的是指针</p>
<p><code>typeof</code> 可以判断除了 <code>null</code> 以外的原始类型。 <code>instanceof</code> 可以判对象的正确类型，但是不能判断原始类型，因为它是通过<code>原型链</code>去判断的。</p>
<span id="more"></span>

<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><p>略，详见掘金小册</p>
<h1 id="this"><a href="#this" class="headerlink" title="this"></a>this</h1><ol>
<li>定义一个函数 <code>foo()</code>，如果直接调用 <code>foo</code> ，不管 <code>foo</code> 函数放在了什么地方， <code>this</code> 一定是 <code>window</code></li>
<li>对于 <code>obj.foo()</code> 等情形，谁调用了函数，谁就是 <code>this</code> 。这里 <code>this</code> 就是 <code>obj</code> 对象</li>
<li>对于 <code>const f = new foo()</code> 的方式来说， <code>this</code> 永远指向 <code>f</code> ，不会有任何改变</li>
<li>箭头函数是没有 <code>this</code> 的，箭头函数的 <code>this</code> 取决于包裹箭头函数的第一个普通函数的 <code>this</code> 。另外，箭头函数使用 <code>bind</code> 、 <code>new</code> 这类函数是无效的</li>
<li>对于 <code>bind</code> 这些改变上下文的 API， <code>this</code> 只取决于第一个参数，如果第一个参数为空，那么就是 <code>window</code> 。注意，一个函数无论我们 <code>bind</code> 几次， <code>this</code> 永远由第一次 bind 决定</li>
</ol>
<pre><code class="javascript">const a = &#123;&#125;
const fn = function () &#123;
  console.log(this)
&#125;
fn.bind().bind(a)()

// 换种写法
const fn2 = function () &#123;
  return function () &#123;
    return fn.apply()
  &#125;.apply(a)
&#125;
</code></pre>
<ol start="6">
<li>综上： <strong><code>new</code> 的方式优先级最高，其次 <code>bind</code> 等函数，然后是 <code>obj.foo()</code> 这种方式的调用，最后是 <code>直接调用</code>。同时，箭头函数的 <code>this</code> 一旦绑定，就不会再改变了</strong></li>
</ol>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>定义：函数和 <code>声明</code> 这个函数时的作用域结合起来，就是闭包</p>
<pre><code class="js">;(function () &#123;
  var a = 1
  function add() &#123;
    var b = 2
    var sum = b + a
    console.log(sum) // 3
  &#125;
  add()
&#125;)()
</code></pre>
<p><code>add</code> 函数本身，以及其内部可访问的变量，即 <code>a = 1</code> ，这两个组合在⼀起就被称为闭包，仅此⽽已。</p>
<p>闭包最⼤的作⽤就是<strong>隐藏变量</strong>，闭包的⼀⼤特性就是<strong>内部函数总是可以访问其所在的外部函数中声明的参数和变量</strong>，即使在其外部函数被返回（寿命终结）了之后也可以访问。</p>
<p>基于此特性，JavaScript 可以实现<strong>私有变量</strong>、<strong>特权变量</strong>、<strong>储存变量</strong>等</p>
<p>我们就以<strong>私有变量</strong>举例，私有变量的实现⽅法很多，有靠约定的（变量名前加<code>_</code>）,有靠 <code>Proxy</code> 代理的，也有靠 <code>Symbol</code> 这种新数据类型的。</p>
<p>但是真正⼴泛流⾏的其实是使⽤闭包。</p>
<pre><code class="js">function Person() &#123;
  var name = &#39;Jim&#39;
  this.getName = function () &#123;
    return name
  &#125;
  this.setName = function (value) &#123;
    name = value
  &#125;
&#125;
const Jim = new Person()
console.log(Jim.getName()) // Jim
Jim.setName(&#39;Tom&#39;)
console.log(Jim.getName()) // Tom
console.log(name) //name is not defined
</code></pre>
<p>其他例子</p>
<pre><code class="javascript">// 第一题
;(function () &#123;
  function createIncrement() &#123;
    let count = 0
    function increment() &#123;
      count++
    &#125;

    let message = `Count is $&#123;count&#125;`
    function log() &#123;
      console.log(message)
    &#125;

    return [increment, log]
  &#125;

  const [increment, log] = createIncrement()
  increment()
  increment()
  increment()
  log() // =&gt; ?
&#125;)()

// 第二题
;(function () &#123;
  function fn() &#123;
    a = 0
    return function (b) &#123;
      return b + a++
    &#125;
  &#125;
  var f = fn()
  console.log(f(5)) // 5
  console.log(fn()(5)) // 5
  console.log(f(5)) // 6
  console.log(a) // 2
&#125;)()
</code></pre>
<h1 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h1><p>浅拷贝： <code>Object.assign</code> ， <code>&#123;...someObject&#125;</code></p>
<p>深拷贝： <code>JSON.parse(JSON.stringfy(object))</code> ，但是也有局限性</p>
<ul>
<li>会忽略 <code>undefined</code></li>
<li>会忽略 <code>symbol</code></li>
<li>不能序列化函数</li>
<li>不能解决循环引用的对象</li>
</ul>
<pre><code class="javascript">/**
 * 简易版深拷贝函数
 */
const deepClone = obj =&gt; &#123;
  if (typeof obj !== &#39;object&#39;) &#123;
    throw new Error(&#39;发生错误&#39;)
  &#125;

  const newObj = obj instanceof Array ? [] : &#123;&#125;

  for (const key in obj) &#123;
    if (Object.hasOwnProperty.call(obj, key)) &#123;
      const value = obj[key]
      newObj[key] = typeof value === &#39;object&#39; ? deepClone(value) : value
    &#125;
  &#125;
  return newObj
&#125;
</code></pre>
<h1 id="原型及原型链"><a href="#原型及原型链" class="headerlink" title="原型及原型链"></a>原型及原型链</h1><p>当我们创建一个<strong>实例</strong>时 <code>let person = new Person(&#39;Jim&#39;, &#39;25&#39;, &#39;football player&#39;)</code> ，我们可以发现能使用很多种函数，但是我们明明没有定义过它们，对于这种情况你是否有过疑惑？</p>
<p>当我们在浏览器中打印 <code>person</code> 时你会发现，在 <code>person</code> 上居然还有一个 <code>__proto__</code> 属性。其实每个 JS 对象都有 <code>__proto__</code> 属性，这个属性指向了该对象 <code>Person</code> 的原型 <code>Person.prototype</code>。</p>
<p>原型也是一个对象，并且这个对象中包含了很多函数，所以我们可以得出一个结论：对于 <code>person</code> 来说，可以通过 <code>__proto__</code> 找到一个原型对象，在该对象中定义了很多函数让我们来使用。</p>
<p>在 <code>__proto__</code> 对象中还有一个 <code>constructor</code> 属性，也就是构造函数。打开 <code>constructor</code> 属性我们又可以发现其中还有一个 <code>prototype</code> 属性，并且这个属性对应的值和先前我们在 <code>__proto__</code> 中看到的一模一样。所以我们又可以得出一个结论：原型的 <code>constructor</code> 属性指向构造函数，构造函数又通过 <code>prototype</code> 属性指回原型，但是并不是所有函数都具有这个属性，<code>Function.prototype.bind()</code> 就没有这个属性。</p>
<p><img src="https://cdn.jsdelivr.net/gh/chivesssss/picture-store@master/uPic/2021/03/28/13/27/CUIOOY.png" alt="示意图"></p>
<p>总结：</p>
<ul>
<li><code>Object</code> 是所有对象的爸爸，所有对象都可以通过 <code>__proto__</code> 找到它</li>
<li><code>Function</code> 是所有函数的爸爸，所有函数都可以通过 <code>__proto__</code> 找到它</li>
<li>函数的 prototype 是一个对象</li>
<li>对象的 <code>__proto__</code> 属性指向原型， <code>__proto__</code> 将对象和原型连接起来组成了原型链</li>
</ul>
<h1 id="作用域及作用域链"><a href="#作用域及作用域链" class="headerlink" title="作用域及作用域链"></a>作用域及作用域链</h1><p>作用域就是一个<strong>独立的地盘</strong>，最大的用处就是<strong>隔离变量</strong>，不同作用域下同名变量不会有冲突。</p>
<p><code>ES6</code> 之前 <code>JavaScript</code> 没有块级作用域，只有全局作用域和函数作用域。<code>ES6</code>的到来，为我们提供了<code>块级作用域</code>，可通过新增命令 <code>let</code> 和 <code>const</code> 来体现。</p>
<p>全局作用域</p>
<ul>
<li>最外层函数 和在最外层函数外面定义的变量拥有全局作用域</li>
<li>所有末定义直接赋值的变量自动声明为拥有全局作用域</li>
<li>所有 window 对象的属性拥有全局作用域</li>
</ul>
<p>块级作用域</p>
<p>块级作用域可通过新增命令 let 和 const 声明，所声明的变量在指定块的作用域外无法被访问。块级作用域在如下情况被创建：</p>
<ul>
<li>在一个函数内部</li>
<li>在一个代码块（由一对花括号包裹）内部</li>
</ul>
<p>块级作用域有以下几个特点：</p>
<ul>
<li>声明变量不会提升到代码块顶部，所以会暂时性锁区</li>
<li>禁止重复声明</li>
</ul>
<p>作用域链</p>
<p>当在当前作用域中取值失败时，就要到<strong>创建</strong>这个函数的那个作用域中取值，这里强调的是“创建”，而不是“调用”。如果还是取值失败，继续往上，形成的链条，就叫作用域链。</p>
<p>什么是变量提升</p>
<p>JavaScript 引擎的⼯作⽅式是，先解析代码，获取所有被声明的变量，然后再⼀⾏⼀⾏地运⾏。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。存在提升的原因：解决函数之间的相互调用。</p>
<pre><code class="javascript">console.log(a) // undefined
var a = 1
function b() &#123;
  console.log(a)
&#125;
b() // 1
</code></pre>
<p>上⾯的代码实际执⾏顺序是这样的:</p>
<p>第⼀步： 引擎将 <code>var a = 1</code> 拆解为 <code>var a = undefined</code> 和 <code>a = 1</code> ，并将 <code>var a = undefined</code> 放到最顶端， <code>a = 1</code> 还在原来的位置，这样⼀来代码就是这样:</p>
<pre><code class="javascript">var a = undefined
console.log(a) // undefined
a = 1
function b() &#123;
  console.log(a)
&#125;
b() // 1
</code></pre>
<p>第⼆步就是执⾏，因此 js 引擎⼀⾏⼀⾏从上往下执⾏就造成了当前的结果，这就叫变量提升。</p>
<blockquote>
<p>函数提升优于变量提升，函数提升会把 <code>整个函数</code> 挪到作用域顶部，变量提升只会把 <code>变量声明</code> 挪到作用域顶部</p>
</blockquote>
<p>var、let 及 const</p>
<ul>
<li><code>var</code> 存在提升，我们能在声明之前使用。 <code>let</code> <code>、const</code> 因为暂时性死区，不能在声明之前使用</li>
<li>全局作用域下使用 <code>let</code> 和 <code>const</code> 声明变量，变量不会被挂载到 <code>window</code> 上，这和 <code>var</code> 不一样</li>
<li><code>let</code> 和 <code>const</code> 作用基本一致，但是后者声明的变量不能再次赋值</li>
</ul>
<h1 id="原型继承和-Class-继承"><a href="#原型继承和-Class-继承" class="headerlink" title="原型继承和 Class 继承"></a>原型继承和 Class 继承</h1><pre><code class="javascript">/**
 * 组合继承：子类的构造函数中通过 Parent.call(this) 继承父类的属性，
 * 然后改变子类的原型为 new Parent() 来继承父类的函数
 */
function Parent(value) &#123;
  this.value = value
&#125;

Parent.prototype.getValue = function () &#123;
  console.log(this.value)
&#125;

function Child(value) &#123;
  Parent.call(this, value) // 构造函数可以传参，不会与父类引用属性共享
&#125;

Child.prototype = new Parent() // 可以复用父类的函数，但是子类原型上多了不需要的父类的属性

const child = new Child(1)

child.getValue() // 1

child instanceof Parent // true
</code></pre>
<pre><code class="javascript">/**
 * Class 继承，关键点在于 extends、super
 */
class Parent &#123;
  constructor(value) &#123;
    this.value = value
  &#125;

  getValue() &#123;
    console.log(this.value)
  &#125;
&#125;

class Child extends Parent &#123;
  constructor(value) &#123;
    super(value)
    this.value = value
  &#125;
&#125;

const child = new Child(1)

child.getValue() // 1

child instanceof Parent // true
</code></pre>
<h1 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h1><h1 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h1><p><code>Proxy</code> 可以理解成，在目标对象之前架设一层<code>“拦截”</code>，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</p>
<pre><code class="javascript">let proxy = new Proxy(target, handler)
</code></pre>
<ul>
<li><code>target</code> —— 是要包装的<code>对象</code>，可以是任何东西，包括函数。</li>
<li><code>handler</code> —— 代理配置：带有“钩子”（“traps”，即拦截操作的方法）的<code>对象</code>。比如 <code>get</code> 钩子用于读取 <code>target</code> 属性， <code>set</code> 钩子写入 <code>target</code> 属性等等。</li>
</ul>
<blockquote>
<p>对 <code>proxy</code> 进行操作，如果在 <code>handler</code> 中存在相应的钩子，则它将运行，并且 <code>Proxy</code> 有机会对其进行处理，否则将直接对 <code>target</code> 进行处理。</p>
</blockquote>
<p>Handler 对象包含的方法：<code>get</code> 、 <code>set</code> 、 <code>has</code> （in 运算符） 、 <code>deleteProperty</code> （delete 操作） 、 <code>apply</code> （proxy 对象作为函数被调用）、 <code>construct</code> （new 操作）、 <code>defineProperty</code></p>
<pre><code class="javascript">/**
 * 通过自定义 set 和 get 函数的方式，在原本的逻辑中插入了我们的函数
 * 逻辑（回调函数），实现了在对对象任何属性进行读写时发出通知
 */
let obj = &#123; a: 1 &#125;

let onWatch = (target, setCallback, getCallback) =&gt; &#123;
  return new Proxy(target, &#123;
    set(target, key, value, receiver) &#123;
      setCallback(key, value)
      return Reflect.set(target, key, value, receiver)
    &#125;,
    get(target, key, receiver) &#123;
      getCallback(target, key)

      // return target[key]
      return Reflect.get(target, key, receiver)
    &#125;,
  &#125;)
&#125;

let p = onWtch(
  obj,
  (k, v) =&gt; &#123;
    // 数据变化，响应式监听
    console.log(`监测到属性$&#123;k&#125;改变为$&#123;v&#125;`)
  &#125;,
  (t, k) =&gt; &#123;
    // 数据读取，响应式派发
    console.log(`&#39;$&#123;k&#125;&#39; = $&#123;t[k]&#125;`)
  &#125;
)

p.a = 3 // 监测到属性a改变为3
p.a // &#39;a&#39; = 3
</code></pre>
<p>Proxy 有一些局限：</p>
<ul>
<li>内置对象（<code>Map</code>、<code>Set</code>、<code>Promise</code>、<code>Date</code>）具有“内部插槽”，对这些对象的访问无法被代理。</li>
<li>私有类字段也是如此，因为它们是在内部使用插槽实现的。因此，代理方法的调用必须具有目标对象 this 才能访问它们</li>
<li>对象相等性测试 === 不能被拦截</li>
<li>性能：基准测试取决于引擎，但通常使用最简单的代理访问属性所需的时间要长几倍。实际上，这仅对某些“瓶颈”对象重要</li>
</ul>
<h1 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h1><ol>
<li>将 <code>Object</code> 对象的一些明显属于语言内部的方法（比如 <code>Object.defineProperty</code> ），放到 <code>Reflect</code> 对象上。现阶段，某些方法同时在 <code>Object</code> 和 <code>Reflect</code> 对象上部署，未来的新方法将只部署在 <code>Reflect</code> 对象上</li>
<li>修改某些 <code>Object</code> 方法的返回结果，让其变得更合理。比如，<code>Object.defineProperty(obj, name, desc)</code> 在无法定义属性时，会抛出一个错误，而 <code>Reflect.defineProperty(obj, name, desc)</code> 则会返回 <code>false</code> 。</li>
<li>让 <code>Object</code> 操作都变成函数行为。某些 <code>Object</code> 操作是命令式，比如 <code>name in obj</code> 和 <code>delete obj[name]</code>，而 <code>Reflect.has(obj, name)</code> 和 <code>Reflect.deleteProperty(obj, name)</code> 让它们变成了函数行为</li>
<li><code>Reflect</code> 对象的方法与 <code>Proxy</code> 对象的方法一一对应，只要是 <code>Proxy</code> 对象的方法，就能在 <code>Reflect</code> 对象上找到对应的方法。这就让 <code>Proxy</code> 对象可以方便地调用对应的 <code>Reflect</code> 方法，完成<strong>原始对象的默认行为</strong>，作为修改行为的基础。也就是说，不管 <code>Proxy</code> 怎么修改默认行为（e.g. <code>set()、get()</code>），你总可以在 <code>Reflect</code> 上获取原始对象的默认行为。</li>
</ol>
<blockquote>
<p>在大多数情况下，我们可以不使用 <code>Reflect</code> 完成相同的事情，例如，使用 <code>Reflect.get(target, prop, receiver)</code> 读取属性可以替换为 <code>target[prop]</code> 。尽管有一些细微的差别。</p>
</blockquote>
<pre><code class="javascript">let user = &#123;
  _name: &#39;Guest&#39;,
  get name() &#123;
    return this._name
  &#125;,
&#125;

let userProxy = new Proxy(user, &#123;
  get(target, prop, receiver) &#123;
    return target[prop]
  &#125;,
&#125;)

console.log(userProxy.name) // Guest
</code></pre>
<p>该 <code>get</code> 钩子在这里是“ <code>透明的</code> ”，它返回原来的属性，不会做别的任何事情。对于我们的示例而言，这就足够了。</p>
<p>但是对象 <code>admin</code> 从 <code>user</code> 继承后，我们可以观察到错误的行为</p>
<pre><code class="javascript">let user = &#123;
  _name: &#39;Guest&#39;,
  get name() &#123;
    return this._name
  &#125;,
&#125;

let userProxy = new Proxy(user, &#123;
  get(target, prop, receiver) &#123;
    return target[prop] // (*) target = user
  &#125;,
&#125;)

let admin = &#123;
  __proto__: userProxy,
  _name: &#39;Admin&#39;,
&#125;

// Expected: Admin
alert(admin.name) // 输出：Guest （？！？）
</code></pre>
<p>问题实际上出在代理中，在 <code>(*)</code> 行</p>
<ol>
<li>当我们读取 <code>admin.name</code> ，由于 <code>admin</code> 对象自身没有对应的的属性，搜索将转到其原型</li>
<li>原型是 <code>userProxy</code></li>
<li>从代理读取 <code>name</code> 属性时， <code>get</code> 钩子会触发并从原始对象返回 <code>target[prop]</code> 属性，在 <code>(*)</code> 行当调用 <code>target[prop]</code> 时，若 <code>prop</code> 是一个 <code>getter</code> ，它将在 <code>this=target</code> 上下文中运行其代码。因此，结果是来自原始对象 <code>target</code> 的 <code>this._name</code> 即来自 <code>user</code> 。</li>
</ol>
<p>更正后的变体</p>
<pre><code class="javascript">let user = &#123;
  _name: &#39;Guest&#39;,
  get name() &#123;
    return this._name
  &#125;,
&#125;

let userProxy = new Proxy(user, &#123;
  get(target, prop, receiver) &#123;
    // receiver = admin
    return Reflect.get(target, prop, receiver) // (*)
    // return Reflect.get(...arguments)
  &#125;,
&#125;)

let admin = &#123;
  __proto__: userProxy,
  _name: &#39;Admin&#39;,
&#125;

alert(admin.name) // Admin
</code></pre>
<h1 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h1><p>回调地狱：</p>
<ul>
<li>嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身</li>
<li>嵌套函数一多，就很难处理错误</li>
</ul>
<h1 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h1><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>特点：</p>
<ul>
<li>三种状态（ <code>pending</code> 、 <code>resolved</code> 、 <code>rejected</code> ），状态一旦切换，不能改变</li>
<li><code>new Promise</code> 立即执行</li>
<li>链式调用，<code>.then</code> 都是返回一个全新的 <code>Promise</code> 对象</li>
<li>解决了回调地狱</li>
</ul>
<p>缺点：</p>
<ul>
<li><code>Promise</code> 无法取消</li>
<li>错误只能在回调函数里面捕获</li>
</ul>
<pre><code class="javascript">/**
 * 手写 Promise
 * 作用：1、消灭嵌套调用；2、合并多个任务的请求结果
 * API： Promise.resolve, Promise.reject, Promise.prototype.catch,
 * Promise.prototype.finally, Promise.all, Promise.race
 */
const PENDING = &#39;pending&#39;
const RESOLVED = &#39;resolved&#39;
const REJECTED = &#39;rejected&#39;
function MyPromise(executor) &#123;
  this.status = PENDING
  this.value = undefined
  this.reason = undefined

  this.onResolvedCallbacks = []
  this.onRejectedCallbacks = []

  const resolve = value =&gt; &#123;
    if (this.status === PENDING) &#123;
      this.value = value
      this.status = RESOLVED

      this.onResolvedCallbacks.forEach(fn =&gt; fn())
    &#125;
  &#125;

  const reject = reason =&gt; &#123;
    if (this.status === PENDING) &#123;
      this.reason = reason
      this.status = REJECTED

      this.onRejectedCallbacks.forEach(fn =&gt; fn())
    &#125;
  &#125;

  try &#123;
    executor(resolve, reject)
  &#125; catch (error) &#123;
    reject(error)
  &#125;
&#125;

MyPromise.prototype.then = function (onResolved, onRejected) &#123;
  onResolved = typeof onResolved === &#39;function&#39; ? onResolved : v =&gt; v
  onRejected =
    typeof onRejected === &#39;function&#39;
      ? onRejected
      : err =&gt; &#123;
          throw err
        &#125;

  if (this.status === RESOLVED) &#123;
    onResolved(this.value)
  &#125;

  if (this.status === REJECTED) &#123;
    onRejected(this.reason)
  &#125;

  if (this.status === PENDING) &#123;
    this.onResolvedCallbacks.push(() =&gt; &#123;
      onResolved(this.value)
    &#125;)

    this.onRejectedCallbacks.push(() =&gt; &#123;
      onRejected(this.reason)
    &#125;)
  &#125;
&#125;
</code></pre>
<h1 id="async-await"><a href="#async-await" class="headerlink" title="async / await"></a>async / await</h1><p>async 函数，就是 Generator 函数的语法糖，它建⽴在 Promises 上，并且与所有现有的基于 Promise 的 API 兼容。</p>
<ol>
<li><code>async</code> 声明⼀个异步函数(async function someName(){…})</li>
<li>⾃动将常规函数转换成 Promise 函数，返回值也是⼀个 Promise 对象</li>
<li>只有 async 函数内部的异步操作执⾏完，才会执⾏ then ⽅法指定的回调函数</li>
<li>异步函数内部可以使⽤ await</li>
<li><code>await</code> 暂停异步的功能执⾏(var result = await someAsyncCall();)</li>
<li>放置在 Promise 调⽤之前，await 强制其他代码等待，直到 Promise 完成并返回结果</li>
<li>只能与 Promise ⼀起使⽤，不适⽤与回调</li>
<li>await 只能在 async 函数内部使⽤</li>
</ol>
<p>async/await 相⽐于 promise 的优势与劣势</p>
<ol>
<li>代码读起来更加同步，Promise 虽然摆脱了回调地狱，但是 then 的链式调⽤也会带来额外的阅读负担</li>
<li>Promise 传递中间值⾮常麻烦，⽽ async/await ⼏乎是同步的写法，⾮常优雅</li>
<li>错误处理友好，async/await 可以⽤成熟的 try/catch，Promise 的错误捕获⾮常冗余</li>
<li>调试友好，Promise 的调试很差，由于没有代码块，你不能在⼀个返回表达式的箭头函数中设置断点，如果你在⼀个 <code>.then</code> 代码块中使⽤调试器的步进(step-over)功能，调试器并不会进⼊后续的 <code>.then</code> 代码块，因为调试器只能跟踪同步代码的『每⼀步』</li>
<li>多个异步代码变为同步，浪费性能</li>
</ol>
<h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><p><code>setTimeout</code> 、 <code>setInterval</code> 、 <code>requestAnimationFrame</code>，其中前两者的时间并不准确。但是最后 <code>requestAnimationFrame</code> 自带函数节流功能，基本可以保证 16.6 毫秒只执行一次，并且该函数的定时效果是精确的，不会有定时器时间不准的问题。</p>
<pre><code class="javascript">function mySetInterval(callback, interval) &#123;
  let timer
  const now = Date.now
  let startTime = now()
  let endTime = startTime

  const loop = () =&gt; &#123;
    timer = window.requestAnimationFrame(loop)
    endTime = now()
    if (endTime - startTime &gt;= interval) &#123;
      startTime = endTime = now()
      callback(timer)
    &#125;
  &#125;

  timer = window.requestAnimationFrame(loop)
  return timer
&#125;

let a = 0
mySetInterval(timer =&gt; &#123;
  console.log(&#39;1&#39;)
  a++
  if (a === 3) &#123;
    window.cancelAnimationFrame(timer)
  &#125;
&#125;, 1000)
</code></pre>
<h1 id="事件循环-Event-Loop"><a href="#事件循环-Event-Loop" class="headerlink" title="事件循环 (Event Loop)"></a>事件循环 (Event Loop)</h1><p>渲染 Renderer 进程的主要线程</p>
<ul>
<li>GUI 渲染线程</li>
<li>JS 引擎线程</li>
<li>事件触发线程</li>
<li>定时触发器线程</li>
<li>异步 http 请求线程</li>
</ul>
<p>常见的宏任务(<code>macrotask</code>)</p>
<ul>
<li>主代码块 <code>script</code></li>
<li>setTimeout</li>
<li>setInterval</li>
<li>setImmediate - Node</li>
<li>requestAnimationFrame - 浏览器</li>
</ul>
<p>常见微任务(<code>microtask</code>)</p>
<ul>
<li>process.nextTick() - Node</li>
<li>Promise.then()</li>
<li>catch</li>
<li>finally</li>
<li>Object.observe</li>
<li>MutationObserver</li>
</ul>
<p>具体步骤</p>
<ul>
<li>首先，整体的<code>script</code>(作为第一个宏任务)开始执行之前，会把所有代码分为同步任务、异步任务两部分，其中异步任务会再分为宏任务和微任务</li>
<li>同步任务会直接进入主线程依次执行</li>
<li>当主线程内的任务执行完毕，主线程为空时，会检查微任务，如果有任务，就<code>全部执行</code></li>
<li>执行完微任务，就渲染页面</li>
<li>开始下一轮 Event Loop，执行<code>下一个宏任务</code>（异步代码： <code>setTimeout</code> 诸如此类）</li>
</ul>
<blockquote>
<p>PS: 我们可以看到 <code>setTimeout</code> 等宏任务的回调函数在主线程执行，因此，回调函数的执行上下文（<code>this</code>）为 <code>window</code></p>
</blockquote>
<pre><code class="javascript">/**
 * Event loop（执行一个宏任务，执行所有微任务，再继续如此循环）
 * log:1,4,8,7,3,9,6,5,2
 */
;(function () &#123;
  function test() &#123;
    console.log(1)
    setTimeout(function () &#123;
      console.log(2)
    &#125;, 1000)
  &#125;

  test()

  setTimeout(function () &#123;
    Promise.resolve().then(() =&gt; &#123;
      console.log(9)
    &#125;)
    console.log(3)
  &#125;)

  new Promise(function (resolve) &#123;
    console.log(4)
    setTimeout(function () &#123;
      console.log(5)
    &#125;, 100)
    resolve()
  &#125;).then(function () &#123;
    setTimeout(function () &#123;
      console.log(6)
    &#125;, 0)
    console.log(7)
  &#125;)

  console.log(8)
&#125;)()
</code></pre>
<h1 id="手写-apply-、-call-、-bind-函数"><a href="#手写-apply-、-call-、-bind-函数" class="headerlink" title="手写 apply 、 call 、 bind 函数"></a>手写 <code>apply</code> 、 <code>call</code> 、 <code>bind</code> 函数</h1><pre><code class="javascript">/**
 * apply、call 的模拟实现，这两个方法被调用时，函数会立即执行，并返回结果
 */
Function.prototype.myCall = function (context) &#123;
  const context = context || window
  context.fn = this
  const args = []
  for (let i = 1; i &lt; arguments.length; i++) &#123;
    args.push(&#39;arguments[&#39; + i + &#39;]&#39;) // 由于后面会使用 eval 表达式，所以不能直接 push 具体的值
  &#125;
  const result = eval(&#39;context.fn(&#39; + args + &#39;)&#39;)
  delete context.fn
  return result
&#125;

Function.prototype.myApply = function (context, arr) &#123;
  const context = Object(context) || window
  context.fn = this
  let result
  if (!arr) &#123;
    result = context.fn()
  &#125; else &#123;
    const args = []
    for (let i = 0; i &lt; arr.length; i++) &#123;
      args.push(&#39;arr[&#39; + i + &#39;]&#39;)
    &#125;
    result = eval(&#39;context.fn(&#39; + args + &#39;)&#39;)
  &#125;
  delete context.fn
  return result
&#125;
/**
 * bind 的模拟实现。bind 方法会创建一个新函数，这个函数并不会立即执行。当这个新函数被调用时，bind的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。
 */
Function.prototype.myBind = function (context) &#123;
  if (typeof this !== &#39;function&#39;) &#123;
    throw new Error(&#39;Function.prototype.bind - what is trying to be bound is not callable&#39;)
  &#125;

  const self = this
  const args = Array.prototype.slice.call(arguments, 1) // 此处的 arguments 为 bind 时传递的参数
  const fNOP = function () &#123;&#125;

  const fbound = function () &#123;
    /**
     * 当作为构造函数时，this 指向实例，self 指向绑定函数，因为下面修改了 fbound.prototype 为 绑定函数的
     * prototype，此时结果为 true，当结果为 true 的时候，this 指向实例。
     *
     * 当作为普通函数时，this 指向 window，self 指向绑定函数，此时结果为 false，当结果为 false 的时候，
     * this 指向绑定的 context。
     */
    self.apply(this instanceof self ? this : context, args.concat(Array.prototype.slice.call(arguments))) // 此处的 arguments 返回的函数执行时的参数,两处参数合并起来成为 bind 函数完整的参数
  &#125;

  fNOP.prototype = this.prototype // 空函数中转，防止改变 fbound 函数的 prototype 时改变了原来函数的原型
  fbound.prototype = new fNOP()

  return fbound
&#125;
</code></pre>
<h1 id="new"><a href="#new" class="headerlink" title="new"></a>new</h1><p>new 过程中发生的四件事儿</p>
<ol>
<li>创建了一个空对象</li>
<li>链接到原型</li>
<li>绑定 this</li>
<li>返回对象</li>
</ol>
<pre><code class="javascript">/**
 * 模拟实现 new 操作。e.g. myNew(Person,18)
 * @returns 新对象
 */
function myNew() &#123;
  const obj = new Object(), // 用new Object() 的方式新建了一个对象 obj
    Constructor = [].shift.call(arguments) // 取出第一个参数，就是我们要传入的构造函数。此外因为 shift 会修改原数组，所以 arguments 会被去除第一个参数

  obj.__proto__ = Constructor.prototype

  // function Person(name, age) &#123;
  //   this.strength = 60
  //   this.age = age

  //   return &#123;
  //     name: name,
  //     habit: &#39;Games&#39;,
  //   &#125;
  // &#125;

  // var person = new Person(&#39;Kevin&#39;, &#39;18&#39;)

  // console.log(person.name) // Kevin
  // console.log(person.habit) // Games
  // console.log(person.strength) // undefined
  // console.log(person.age) // undefined

  const result = Constructor.apply(obj, arguments)

  return typeof result === &#39;object&#39; ? result : obj // 构造函数返回值如果是一个对象，就返回这个对象，如果不是，就该返回什么就返回什么
&#125;
</code></pre>
<h1 id="instanceof-原理"><a href="#instanceof-原理" class="headerlink" title="instanceof 原理"></a>instanceof 原理</h1><p>通过判断对象（<code>左边</code>）的原型链（<code>__proto__</code>）是不是能找到类型（<code>右边</code>）的 <code>prototype</code></p>
<pre><code class="javascript">/**
 * 自定义instanceof函数
 */
function myInstanceof(left, right) &#123;
  const prototype = right.prototype
  let left = left.__proto__

  while (true) &#123;
    if (left === null || left === undefined) &#123;
      return false
    &#125;

    if (prototype === left) &#123;
      return true
    &#125;

    left = left.__proto__
  &#125;
&#125;
</code></pre>
<h1 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h1><p>事件触发过程：</p>
<ol>
<li><code>window</code> 往<code>事件触发处</code>（通常来说就是目标 dom 元素）传播，遇到注册的捕获事件会触发</li>
<li>传播到事件触发处时触发注册的事件</li>
<li>从事件触发处往 <code>window</code> 传播，遇到注册的冒泡事件会触发</li>
</ol>
<blockquote>
<p>默认注册的就是冒泡事件，所以目标元素的事件触发后应该阻止冒泡</p>
</blockquote>
<p>但是，<strong>如果给 <code>body</code> 中的子节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行</strong></p>
<pre><code class="javascript">// 以下会先打印冒泡然后是捕获
node.addEventListener(
  &#39;click&#39;,
  event =&gt; &#123;
    console.log(&#39;冒泡&#39;)
  &#125;,
  false
)

node.addEventListener(
  &#39;click&#39;,
  event =&gt; &#123;
    console.log(&#39;捕获&#39;)
  &#125;,
  true
)
</code></pre>
<p><code>addEventListener</code> 注册事件，第三个参数可以是 <code>boolean</code> 或者 <code>object</code> ， 默认为 <code>false</code> ，可以冒泡，但是阻止捕获。</p>
<p>事件代理</p>
<pre><code class="html">&lt;ul id=&quot;ul&quot;&gt;
  &lt;li&gt;1&lt;/li&gt;
  &lt;li&gt;2&lt;/li&gt;
  &lt;li&gt;3&lt;/li&gt;
  &lt;li&gt;4&lt;/li&gt;
  &lt;li&gt;5&lt;/li&gt;
&lt;/ul&gt;

&lt;script&gt;
  var ul = document.querySelector(&#39;#ul&#39;)
  ul.addEventListener(&#39;click&#39;,(event) =&gt; &#123;
    console.log(event.target) // li1、li2、li3等等
  &#125;)
&lt;script&gt;
</code></pre>
<p>优点：</p>
<ul>
<li>节省内存</li>
<li>不需要给子节点注销事件</li>
</ul>
<h1 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h1><p>JSONP</p>
<pre><code class="javascript">/**
 * url 链接返回的是：[callbackName](&#123;code:0, data:[], msg: &#39;&#39;&#125;)
 * 在执行栈这个函数会立即执行
 */
const jsonp = (url, callbackName, success) =&gt; &#123;
  let script = document.createElement(&#39;script&#39;)
  script.src = url
  script.async = true
  script.type = &#39;text/script&#39;
  window[callbackName] = function (data) &#123;
    success &amp;&amp; success(data)
  &#125;
  document.body.appendChild(script)
&#125;

jsonp(&#39;https://xxx&#39;, &#39;callback&#39;, function (value) &#123;
  console.log(value)
&#125;)
</code></pre>
<h1 id="浏览器缓存机制"><a href="#浏览器缓存机制" class="headerlink" title="浏览器缓存机制"></a>浏览器缓存机制</h1><p>我们认为览器存在一个缓存数据库，用于储存一些不经常变化的静态文件（图片、css、js 等）。我们将缓存分为强制缓存和协商缓存。</p>
<p>强制缓存</p>
<p>当缓存数据库中已有所请求的数据时。客户端直接从缓存数据库中获取数据。当缓存数据库中没有所请求的数据时，客户端的才会从服务端获取数据。</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/11/29/16007be6f64ff7f7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="强制缓存"></p>
<p>服务器响应的 header 中会用两个字段来表明进行强制缓存——Expires 和 Cache-Control 。</p>
<ul>
<li>Exprires 的值为服务端返回的数据到期时间。当再次请求时的请求时间小于返回的此时间，则直接使用缓存数据。但由于服务端时间和客户端时间可能有误差，这也将导致缓存命中的误差，另一方面，Expires 是 HTTP1.0 的产物，故现在大多数使用 Cache-Control 替代。</li>
<li>Cache-Control 有很多属性，不同的属性代表的意义也不同。<ul>
<li>private：客户端可以缓存</li>
<li>public：客户端和代理服务器都可以缓存</li>
<li>max-age=t：缓存内容将在 t 秒后失效</li>
<li>no-cache：需要使用协商缓存来验证缓存数据</li>
<li>no-store：所有内容都不会缓存。</li>
</ul>
</li>
</ul>
<p>协商缓存</p>
<p>又称对比缓存，客户端会先从缓存数据库中获取到一个缓存数据的标识，得到标识后请求服务端验证是否失效（新鲜），如果没有失效服务端会返回 304，此时客户端直接从缓存中获取所请求的数据，如果标识失效，服务端会返回更新后的数据。</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/11/29/16007d1c835d5461?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="协商缓存"></p>
<blockquote>
<p>两类缓存机制可以同时存在，强制缓存的优先级高于协商缓存，当执行强制缓存时，如若缓存命中，则直接使用缓存数据库数据，不在进行缓存协商。</p>
</blockquote>
<p>协商缓存需要进行对比判断是否可以使用缓存。浏览器第一次请求数据时，服务器会将缓存标识与数据一起响应给客户端，客户端将它们备份至缓存中。再次请求时，客户端会将缓存中的标识发送给服务器，服务器根据此标识判断。若未失效，返回 304 状态码，浏览器拿到此状态码就可以直接使用缓存数据了。<br>对于协商缓存来说，缓存标识我们需要着重理解一下，下面我们将着重介绍它的两种缓存方案。</p>
<p>Last-Modified</p>
<p>Last-Modified： 服务器在响应请求时，会告诉浏览器资源的最后修改时间。</p>
<p>if-Modified-Since:<br>浏览器再次请求服务器的时候，请求头会包含此字段，后面跟着在缓存中获得的最后修改时间。服务端收到此请求头发现有 if-Modified-Since，则与被请求资源的最后修改时间进行对比，如果一致则返回 304 和响应报文头，浏览器只需要从缓存中获取信息即可。从字面上看，就是说：从某个时间节点算起，是否文件被修改了</p>
<ol>
<li>如果真的被修改：那么开始传输响应一个整体，服务器返回：200 OK</li>
<li>如果没有被修改：那么只需传输响应 header，服务器返回：304 Not Modified</li>
</ol>
<p>if-Unmodified-Since:<br>从字面上看, 就是说: 从某个时间点算起, 是否文件没有被修改</p>
<ol>
<li>如果没有被修改:则开始’继续’传送文件: 服务器返回: 200 OK</li>
<li>如果文件被修改:则不传输,服务器返回: 412 Precondition failed (预处理错误)</li>
</ol>
<p>这两个的区别是一个是修改了才下载一个是没修改才下载。Last-Modified 说好却也不是特别好，因为如果在服务器上，一个资源被修改了，但其实际内容根本没发生改变，会因为 Last-Modified 时间匹配不上而返回了整个实体给客户端（即使客户端缓存里有个一模一样的资源）。为了解决这个问题，HTTP1.1 推出了 Etag。</p>
<p>Etag<br>Etag：服务器响应请求时，通过此字段告诉浏览器当前资源在服务器生成的唯一标识（生成规则由服务器决定）</p>
<p>If-None-Match：再次请求服务器时，浏览器的请求报文头部会包含此字段，后面的值为在缓存中获取的标识。服务器接收到次报文后发现 If-None-Match 则与被请求资源的唯一标识进行对比。</p>
<ol>
<li>不同，说明资源被改动过，则响应整个资源内容，返回状态码 200。</li>
<li>相同，说明资源无心修改，则响应 header，浏览器直接从缓存中获取数据信息。返回状态码 304。</li>
</ol>
<p>但是实际应用中由于 Etag 的计算是使用算法来得出的，而算法会占用服务端计算的资源，所有服务端的资源都是宝贵的，所以就很少使用 Etag 了。</p>
<p>缓存的优点</p>
<ol>
<li>减少了冗余的数据传递，节省宽带流量</li>
<li>减少了服务器的负担，大大提高了网站性能</li>
<li>加快了客户端加载网页的速度 这也正是 HTTP 缓存属于客户端缓存的原因</li>
</ol>
<p>不同刷新的请求执行过程</p>
<ol>
<li>浏览器地址栏中写入 URL，回车，浏览器发现缓存中有这个文件了，不用继续请求了，直接去缓存拿（最快）</li>
<li>F5，就是告诉浏览器，别偷懒，好歹去服务器看看这个文件是否有过期了。于是浏览器就胆胆襟襟的发送一个请求带上 If-Modify-since。</li>
<li>Ctrl+F5，告诉浏览器，你先把你缓存中的这个文件给我删了，然后再去服务器请求个完整的资源文件下来。于是客户端就完成了强行更新的操作</li>
</ol>
<p>实际场景应用缓存策略</p>
<p>频繁变动的资源</p>
<p>首先使用 <code>Cache-control: no-cache</code> 使浏览器每次都请求服务器，然后配合 ETag 或者 Last-Modified 来验证资源是否有效。这样的做法虽然不能节省流量，但是能显著减小响应数据的大小</p>
<p>代码文件</p>
<p>这里指除了 html 外的代码文件，因为 html 文件一般不缓存或者缓存时间很短</p>
<p>给代码文件设置一年有效期： <code>Cache-Control: max-age=31536000</code> ，这样只有文件 hash 值发生变化才会去请求文件，否则一直使用缓存</p>
<h1 id="浏览器渲染原理"><a href="#浏览器渲染原理" class="headerlink" title="浏览器渲染原理"></a>浏览器渲染原理</h1><h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><ul>
<li>图片加载优化：不使用图片，CSS 代替（三角形等）；不同的分辨率裁剪不同的图片；小图用 base64；雪碧图</li>
<li>DNS 预解析 <code>&lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://xxxxx&quot;</code></li>
<li>防抖</li>
</ul>
<pre><code class="javascript">/**
 * 防抖：事件触发，N秒之后执行。期间再次触发，则重新计算
 */
const debounce = (fn, wait, immediate) =&gt; &#123;
  let timer

  const debounced = function (...args) &#123;
    timer &amp;&amp; clearTimeout(timer)
    if (immediate) &#123;
      const callNow = !timer

      if (callNow) &#123;
        fn.apply(this, args)
      &#125;

      timer = setTimeout(() =&gt; &#123;
        timer = null
      &#125;, wait)
    &#125; else &#123;
      timer = setTimeout(() =&gt; &#123;
        fn.apply(this, args)
      &#125;, wait)
    &#125;
  &#125;

  return debounced
&#125;
</code></pre>
<ul>
<li>节流</li>
</ul>
<pre><code class="javascript">/**
 * 节流：事件触发，马上执行，N秒之内，事件不再执行，N秒结束之时，再执行一次
 */
const throttle = (fn, wait) =&gt; &#123;
  let timer,
    previous = 0
  const throttled = function (...args) &#123;
    const now = +new Date()
    const remaining = wait - (now - previous)

    if (remaining &lt;= 0 || remaining &gt; wait) &#123;
      if (timer) &#123;
        clearTimeout(timer)
        timer = null
      &#125;
      previous = now
      fn.apply(this, args)
    &#125; else if (!timer) &#123;
      timer = setTimeout(() =&gt; &#123;
        fn.apply(this, args)
        previous = +new Date()
        timer = null
      &#125;, remaining)
    &#125;
  &#125;

  return throttled
&#125;
</code></pre>
<ul>
<li>预加载 <code>&lt;link rel=&quot;preload&quot; href=&quot;http://xxxxx&quot;</code></li>
<li>预渲染 <code>&lt;link rel=&quot;prerender&quot; href=&quot;http://xxxxx&quot;</code></li>
<li>懒执行，某些逻辑需要时再计算，可以用于首屏优化，因为某些逻辑并不会在首页用到。</li>
<li>懒加载</li>
<li>CDN</li>
</ul>
<h1 id="Webpack-性能优化"><a href="#Webpack-性能优化" class="headerlink" title="Webpack 性能优化"></a>Webpack 性能优化</h1><p>减少 webpack 打包时间</p>
<ul>
<li>优化 loader</li>
</ul>
<pre><code class="javascript">module.export = &#123;
  module: &#123;
    rules: [
      &#123;
        test: /\.js$/,
        loader: &#39;babel-loader?cacheDirectory=true&#39;, // 便以后的文件缓存起来
        include: [resolve(&#39;src&#39;)],
        exclude: &#39;/node_modules/&#39;,
      &#125;,
    ],
  &#125;,
&#125;
</code></pre>
<ul>
<li>HappyPack： node 是单线程的，webpack 也是单线程的，HappyPack 可以将 Loader 的同步执行转换为并行的</li>
<li>DllPlugin： DllPlugin 可以将特定的类库提前打包引入</li>
<li>代码压缩</li>
</ul>
<p>减小打包体积</p>
<ul>
<li>按需加载</li>
<li>Tree Shaking 摇树优化</li>
</ul>
<h1 id="从输入-URL-到页面渲染"><a href="#从输入-URL-到页面渲染" class="headerlink" title="从输入 URL 到页面渲染"></a>从输入 URL 到页面渲染</h1><ul>
<li>DNS 查询，通过域名找到 IP</li>
<li>建立 TCP 连接，TCP 三次握手</li>
<li>发送 HTTP 请求</li>
<li>服务端处理并响应</li>
<li>浏览器解析并渲染<ul>
<li>200 开始解析，302 重定向，500 报错</li>
<li>HTML 文件解析成 DOM 树，CSS 解析成 CSSDOM 树，遇到 script 标签，判断是否有 async 或 defer 字段，前者并行下载，后者先下载，延后执行，若没有，下载并执行，阻塞渲染进程。然后 DOM 树和 CSSDOM 树合并成为 Render 树，确定页面元素的布局和样式等等</li>
<li>调用 GPU 开始绘制，合成图层，显示在屏幕上</li>
</ul>
</li>
<li>断开连接，TCP 连接结束</li>
</ul>
]]></content>
      <tags>
        <tag>Javascript</tag>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>面试资料</title>
    <url>/blog/interviews-interview/</url>
    <content><![CDATA[<h1 id="HTML-模块"><a href="#HTML-模块" class="headerlink" title="HTML 模块"></a>HTML 模块</h1><h2 id="HTML-语义化"><a href="#HTML-语义化" class="headerlink" title="HTML 语义化"></a>HTML 语义化</h2><p>语义化是指使⽤恰当语义的 <code>html</code> 标签，让⻚⾯具有良好的结构与含义，⽐如 <code>&lt;p&gt;</code> 标签就代表段落， <code>&lt;article&gt;</code> 代表正⽂</p>
<p>内容等等。</p>
<p>语义化的好处主要有两点：</p>
<ul>
<li>开发者友好：使⽤语义类标签增强了可读性，开发者也能够清晰地看出⽹⻚的结构，也更为便于团队的开发和维护</li>
<li>机器友好：带有语义的⽂字表现⼒丰富，更适合搜索引擎的爬⾍爬取有效信息，语义类还可以⽀持读屏软件，根据⽂章可以⾃动⽣成⽬录</li>
</ul>
<h2 id="常⽤的-meta-标签"><a href="#常⽤的-meta-标签" class="headerlink" title="常⽤的 meta 标签"></a>常⽤的 meta 标签</h2><ul>
<li>charset，⽤于描述 HTML ⽂档的编码形式</li>
</ul>
<pre><code class="html">&lt;meta charset=&quot;UTF-8&quot; /&gt;
</code></pre>
<ul>
<li>http-equiv，顾名思义，相当于 http 的⽂件头作⽤,⽐如下⾯的代码就可以设置 http 的缓存过期⽇期</li>
</ul>
<pre><code class="html">＜meta http-equiv=&quot;expires&quot; content=&quot;Wed, 20 Jun 2019 22:33:00 GMT&quot;＞
</code></pre>
<ul>
<li>viewport，移动前端最熟悉不过，Web 开发⼈员可以控制视⼝的⼤⼩和⽐例</li>
</ul>
<pre><code class="html">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot; /&gt;
</code></pre>
<ul>
<li>apple-mobile-web-app-status-bar-style,开发过 PWA 应⽤的开发者应该很熟悉，为了⾃定义评估⼯具栏的颜⾊。</li>
</ul>
<pre><code class="html">&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black-translucent&quot; /&gt;
</code></pre>
<h2 id="src-和-href-的区别"><a href="#src-和-href-的区别" class="headerlink" title="src 和 href 的区别"></a>src 和 href 的区别</h2><ul>
<li>src 是指向外部资源的位置，指向的内容会嵌⼊到⽂档中当前标签所在的位置，在请求 src 资源时会将其指向的资源下载并应⽤到⽂档内，如 js 脚本，img 图⽚和 frame 等元素。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执⾏完毕，所以⼀般 js 脚本会放在底部⽽不是头部。</li>
<li>href 是指向⽹络资源所在位置（的超链接），⽤来建⽴和当前元素或⽂档之间的连接，当浏览器识别到它他指向的 ⽂件时，就会并⾏下载资源，不会停⽌对当前⽂档的处理。</li>
</ul>
<h2 id="img-的-srcset-的作⽤是什么"><a href="#img-的-srcset-的作⽤是什么" class="headerlink" title="img 的 srcset 的作⽤是什么"></a>img 的 srcset 的作⽤是什么</h2><p>可以设计响应式图⽚，我们可以使⽤两个新的属性 srcset 和 sizes 来提供更多额外的资源图像和提示，帮助浏览器选择<br>正确的⼀个资源。</p>
<ul>
<li>srcset 定义了我们允许浏览器选择的图像集，以及每个图像的⼤⼩。</li>
<li>sizes 定义了⼀组媒体条件（例如屏幕宽度）并且指明当某些媒体条件为真时，什么样的图⽚尺⼨是最佳选择。</li>
</ul>
<p>所以，有了这些属性，浏览器会：</p>
<ul>
<li>查看设备宽度</li>
<li>检查 sizes 列表中哪个媒体条件是第⼀个为真</li>
<li>查看给予该媒体查询的槽⼤⼩</li>
<li>加载 srcset 列表中引⽤的最接近所选的槽⼤⼩的图像</li>
</ul>
<pre><code class="html">&lt;img
  src=&quot;clock-demo-thumb-200.png&quot;
  alt=&quot;Clock&quot;
  srcset=&quot;clock-demo-thumb-200.png 200w, clock-demo-thumb-400.png 400w&quot;
  sizes=&quot;(min-width: 600px) 200px, 50vw&quot;
/&gt;
</code></pre>
<h2 id="script-标签中-defer-和-async-的区别"><a href="#script-标签中-defer-和-async-的区别" class="headerlink" title="script 标签中 defer 和 async 的区别"></a>script 标签中 defer 和 async 的区别</h2><ul>
<li>defer：浏览器指示脚本在⽂档被解析后执⾏，script 被异步加载后并不会⽴刻执⾏，⽽是等待⽂档被解析完毕后执⾏。</li>
<li>async：同样是异步加载脚本，区别是脚本加载完毕后⽴即执⾏，这导致 async 属性下的脚本是乱序的，对于 script 有先后依赖关系的情况，并不适⽤。</li>
</ul>
<h2 id="前端储存的⽅式"><a href="#前端储存的⽅式" class="headerlink" title="前端储存的⽅式"></a>前端储存的⽅式</h2><p>cookies、localstorage、sessionstorage、Web SQL、IndexedDB</p>
<ul>
<li>cookies： 在 HTML5 标准前本地储存的主要⽅式，优点是兼容性好，请求头⾃带 cookie ⽅便，缺点是⼤⼩只有 4k，⾃动请求头加⼊ cookie 浪费流量，每个 domain 限制 20 个 cookie，使⽤起来麻烦需要⾃⾏封装</li>
<li>localStorage：HTML5 加⼊的以键值对(Key-Value)为标准的⽅式，优点是操作⽅便，永久性储存（除⾮⼿动删除），⼤⼩为 5M，兼容 IE8+</li>
<li>sessionStorage：与 localStorage 基本类似，区别是 sessionStorage 当⻚⾯关闭后会被清理，⽽且与 cookie、localStorage 不同，他不能在所有同源窗⼝中共享，是会话级别的储存⽅式</li>
<li>Web SQL：2010 年被 W3C 废弃的本地数据库数据存储⽅案，但是主流浏览器（⽕狐除外）都已经有了相关的实现，web sql 类似于 SQLite，是真正意义上的关系型数据库，⽤ sql 进⾏操作，当我们⽤ JavaScript 时要进⾏转换，较为繁琐。</li>
<li>IndexedDB： 是被正式纳⼊ HTML5 标准的数据库储存⽅案，它是 NoSQL 数据库，⽤键值对进⾏储存，可以进⾏快速读取操作，⾮常适合 web 场景，同时⽤ JavaScript 进⾏操作会⾮常⽅便。</li>
</ul>
<h1 id="CSS-模块"><a href="#CSS-模块" class="headerlink" title="CSS 模块"></a>CSS 模块</h1><h2 id="CSS-选择器的优先级"><a href="#CSS-选择器的优先级" class="headerlink" title="CSS 选择器的优先级"></a>CSS 选择器的优先级</h2><p>内联 &gt; ID 选择器 &gt; 类选择器 &gt; 标签选择器</p>
<h2 id="link-和-import-的区别"><a href="#link-和-import-的区别" class="headerlink" title="link 和@import 的区别"></a>link 和@import 的区别</h2><ul>
<li>link 属于 XHTML 标签，⽽ @import 是 CSS 提供的。</li>
<li>⻚⾯被加载时，link 会同时被加载，⽽@import 引⽤的 CSS 会等到⻚⾯被加载完再加载。</li>
<li>import 只在 IE 5 以上才能识别，⽽ link 是 XHTML 标签，⽆兼容问题。</li>
<li>link ⽅式的样式权重⾼于@import 的权重。</li>
<li>使⽤ dom 控制样式时的差别。当使⽤ javascript 控制 dom 去改变样式的时候，只能使⽤ link 标签，因为@import 不是 dom 可以控制的。</li>
</ul>
<h2 id="有哪些⽅式（CSS）可以隐藏⻚⾯元素"><a href="#有哪些⽅式（CSS）可以隐藏⻚⾯元素" class="headerlink" title="有哪些⽅式（CSS）可以隐藏⻚⾯元素"></a>有哪些⽅式（CSS）可以隐藏⻚⾯元素</h2><ul>
<li><code>opacity:0</code> 本质上是将元素的透明度将为 0，就看起来隐藏了，但是依然占据空间且可以交互</li>
<li><code>visibility:hidden</code> 与上⼀个⽅法类似的效果，占据空间，但是不可以交互了</li>
<li><code>overflow:hidden</code> 这个只隐藏元素溢出的部分，但是占据空间且不可交互</li>
<li><code>display:none</code> 这个是彻底隐藏了元素，元素从⽂档流中消失，既不占据空间也不交互，也不影响布局</li>
<li><code>z-index:-9999</code> 原理是将层级放到底部，这样就被覆盖了，看起来隐藏了</li>
<li><code>transform: scale(0,0)</code> 平⾯变换，将元素缩放为 0，但是依然占据空间，但不可交互</li>
</ul>
<h2 id="em、px、rem-区别"><a href="#em、px、rem-区别" class="headerlink" title="em、px、rem 区别"></a>em、px、rem 区别</h2><ul>
<li>px：绝对单位，⻚⾯按精确像素展示。</li>
<li>em：相对单位，基准点为⽗节点字体的⼤⼩，如果⾃身定义了 font-size 按⾃身来计算（浏览器默认字体是 16px），整个⻚⾯内 1em 不是⼀个固定的值。</li>
<li>rem：相对单位，可理解为“root em”, 相对根节点 html 的字体⼤⼩来计算，CSS3 新加属性，chrome、firefox、IE9+支持</li>
</ul>
<h2 id="块级元素⽔平居中的⽅法"><a href="#块级元素⽔平居中的⽅法" class="headerlink" title="块级元素⽔平居中的⽅法"></a>块级元素⽔平居中的⽅法</h2><ul>
<li><code>margin:0 auto</code> ⽅法</li>
<li><code>flex</code> 布局，⽬前主流⽅法</li>
</ul>
<p>扩展阅读：<a href="https://louiszhai.github.io/2016/03/12/css-center/#%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD">16 种方法实现水平居中垂直居中</a></p>
<h2 id="CSS-定位⽅式"><a href="#CSS-定位⽅式" class="headerlink" title="CSS 定位⽅式"></a>CSS 定位⽅式</h2><ul>
<li>static: 正常⽂档流定位，此时 top, right, bottom, left 和 z-index 属性⽆效，块级元素从上往下纵向排布，⾏级元素从左向右排列。</li>
<li>relative：相对定位，此时的『相对』是相对于正常⽂档流的位置。</li>
<li>absolute：相对于最近的⾮ static 定位祖先元素的偏移，来确定元素位置，⽐如⼀个绝对定位元素它的⽗级、和祖⽗级元素都为 relative，它会相对他的⽗级⽽产⽣偏移。</li>
<li>fixed：指定元素相对于屏幕视⼝（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变，⽐如那种回到顶部的按钮⼀般都是⽤此定位⽅式。</li>
<li>sticky：粘性定位，特性近似于 relative 和 fixed 的合体，其在实际应⽤中的近似效果就是 IOS 通讯录滚动的时候的『顶屁股』。</li>
</ul>
<h2 id="清除浮动⽅法"><a href="#清除浮动⽅法" class="headerlink" title="清除浮动⽅法"></a>清除浮动⽅法</h2><ul>
<li>空 div ⽅法： <code>&lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt;</code></li>
<li>clearfix ⽅法：上⽂使⽤ <code>.clearfix</code> 类已经提到</li>
<li><code>overflow: auto</code> 或 <code>overflow: hidden</code> ⽅法，使⽤ BFC</li>
</ul>
<h2 id="对媒体查询的理解"><a href="#对媒体查询的理解" class="headerlink" title="对媒体查询的理解"></a>对媒体查询的理解</h2><p>媒体查询由⼀个可选的媒体类型和零个或多个使⽤媒体功能的限制了样式表范围的表达式组成，例如宽度、⾼度和颜⾊。媒体查询，添加⾃ CSS3，允许内容的呈现针对⼀个特定范围的输出设备⽽进⾏裁剪，⽽不必改变内容本身,⾮常适合 web ⽹⻚应对不同型号的设备⽽做出对应的响应适配。</p>
<pre><code class="html">&lt;!-- link元素中的CSS媒体查询 --&gt;
&lt;link rel=&quot;stylesheet&quot; media=&quot;(max-width: 800px)&quot; href=&quot;example.css&quot; /&gt;
&lt;!-- 样式表中的CSS媒体查询 --&gt;
&lt;style&gt;
  @media (max-width: 600px) &#123;
    .facet_sidebar &#123;
      display: none;
    &#125;
  &#125;
&lt;/style&gt;
</code></pre>
<h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><p>盒模型由 content（内容）、padding（内边距）、border（边框）、margin（外边距）组成。</p>
<h2 id="标准盒模型和怪异盒模型的区别"><a href="#标准盒模型和怪异盒模型的区别" class="headerlink" title="标准盒模型和怪异盒模型的区别"></a>标准盒模型和怪异盒模型的区别</h2><p>在 W3C 标准下，我们定义元素的 width 值即为盒模型中的 content 的宽度值，height 值即为盒模型中的 content 的⾼度值。</p>
<p>因此，标准盒模型下：</p>
<blockquote>
<p>元素的总宽度 = margin-left + border-left + padding-left + width + padding-right + border-right + margin-right</p>
</blockquote>
<p>⽽ IE 怪异盒模型（IE8 以下）width 的宽度并不是 content 的宽度，⽽是 border-left + padding-left + content 的宽度值 + padding-right + border-right 之和，height 同理。</p>
<p>在怪异盒模型下：</p>
<blockquote>
<p>元素占据的宽度 = margin-left + width + margin-right</p>
</blockquote>
<p>虽然现代浏览器默认使⽤ W3C 的标准盒模型，但是在不少情况下怪异盒模型更好⽤，于是 W3C 在 css3 中加⼊ <code>box-sizing</code> 。</p>
<pre><code class="css">box-sizing: content-box // 标准盒模型
box-sizing: border-box // 怪异盒模型
box-sizing: padding-box // ⽕狐的私有模型，没⼈⽤
</code></pre>
<h2 id="BFC-块级上下文"><a href="#BFC-块级上下文" class="headerlink" title="BFC 块级上下文"></a>BFC 块级上下文</h2><p>BFC 触发条件:</p>
<ul>
<li>根元素，即 HTML 元素</li>
<li>position: fixed / absolute</li>
<li>float 不为 none</li>
<li>overflow 不为 visible</li>
<li>display 的值为 inline-block、table-cell、table-caption</li>
</ul>
<p>作用</p>
<ul>
<li>防⽌ margin 发⽣重叠</li>
<li>两栏布局，防⽌⽂字环绕等</li>
<li>防⽌元素塌陷</li>
</ul>
<h2 id="为什么有时候⼈们⽤-translate-来改变位置⽽不是定位"><a href="#为什么有时候⼈们⽤-translate-来改变位置⽽不是定位" class="headerlink" title="为什么有时候⼈们⽤ translate 来改变位置⽽不是定位"></a>为什么有时候⼈们⽤ translate 来改变位置⽽不是定位</h2><p><code>translate()</code> 是 transform 的⼀个值。改变 transform 或 opacity 不会触发浏览器重新布局（reflow）或重绘（repaint），只会触发复合（compositions）。⽽改变绝对定位会触发重新布局，进⽽触发重绘和复合。transform 使浏览器为元素创建⼀个 GPU 图层，但改变绝对定位会使⽤到 CPU。 因此 <code>translate()</code> 更⾼效，可以缩短平滑动画的绘制时间。</p>
<p>⽽ <code>translate()</code> 改变位置时，元素依然会占据其原始空间，绝对定位就不会发⽣这种情况。</p>
<h2 id="伪类和伪元素的区别"><a href="#伪类和伪元素的区别" class="headerlink" title="伪类和伪元素的区别"></a>伪类和伪元素的区别</h2><ul>
<li>伪类是⼀个以冒号<code>:</code>作为前缀，被添加到⼀个选择器末尾的关键字，当你希望样式在特定状态下才被呈现到指定的元素时，你可以往元素的选择器后⾯加上对应的伪类。</li>
<li>伪元素⽤于创建⼀些不在⽂档树中的元素，并为其添加样式。⽐如说，我们可以通过 <code>::before</code> 来在⼀个元素前增加⼀些⽂本，并为这些⽂本添加样式。虽然⽤户可以看到这些⽂本，但是这些⽂本实际上不在⽂档树中。</li>
</ul>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>其实上⽂已经表达清楚两者区别了，伪类是通过在元素选择器上加⼊伪类改变元素状态，⽽伪元素通过对元素的操作进⾏对元素的改变。</p>
<p>我们通过 <code>p::before</code> 对这段⽂本添加了额外的元素，通过 <code>p:first-child</code> 改变了⽂本的样式。</p>
<h2 id="关于-CSS-的动画与过渡问题"><a href="#关于-CSS-的动画与过渡问题" class="headerlink" title="关于 CSS 的动画与过渡问题"></a>关于 CSS 的动画与过渡问题</h2><p><a href="https://www.cnblogs.com/xiaohuochai/p/5391663.html">深入理解 CSS 动画 animation</a></p>
<p><a href="https://www.cnblogs.com/xiaohuochai/p/5347930.html">深入理解 CSS 过渡 transition</a></p>
<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="HTTP-有哪些⽅法"><a href="#HTTP-有哪些⽅法" class="headerlink" title="HTTP 有哪些⽅法"></a>HTTP 有哪些⽅法</h2><ul>
<li>GET: 通常⽤于请求服务器发送某些资源</li>
<li>HEAD: 请求资源的头部信息, 并且这些头部与 HTTP GET ⽅法请求时返回的⼀致. 该请求⽅法的⼀个使⽤场景是在下载⼀个⼤⽂件前先获取其⼤⼩再决定是否要下载, 以此可以节约带宽资源</li>
<li>OPTIONS: ⽤于获取⽬的资源所⽀持的通信选项</li>
<li>POST: 发送数据给服务器</li>
<li>PUT: ⽤于新增资源或者使⽤请求中的有效负载替换⽬标资源的表现形式</li>
<li>DELETE: ⽤于删除指定的资源</li>
<li>PATCH: ⽤于对资源进⾏部分修改</li>
<li>CONNECT: HTTP/1.1 协议中预留给能够将连接改为管道⽅式的代理服务器</li>
<li>TRACE: 回显服务器收到的请求，主要⽤于测试或诊断</li>
</ul>
<h2 id="GET-和-POST-区别"><a href="#GET-和-POST-区别" class="headerlink" title="GET 和 POST 区别"></a>GET 和 POST 区别</h2><ul>
<li>数据传输⽅式不同：GET 请求通过 URL 传输数据，⽽ POST 的数据通过请求体传输。</li>
<li>安全性不同：POST 的数据因为在请求主体内，所以有⼀定的安全性保证，⽽ GET 的数据在 URL 中，通过历史记<br>录，缓存很容易查到数据信息。</li>
<li>数据类型不同：GET 只允许 ASCII 字符，⽽ POST ⽆限制</li>
<li>GET ⽆害： 刷新、后退等浏览器操作 GET 请求是⽆害的，POST 可能重复提交表单</li>
<li>特性不同：GET 是安全（这⾥的安全是指只读特性，就是使⽤这个⽅法不会引起服务器状态变化）且幂等（幂等的概念是指同⼀个请求⽅法执⾏多次和仅执⾏⼀次的效果完全相同），⽽ POST 是⾮安全⾮幂等</li>
</ul>
<h2 id="PUT-和-POST-都是给服务器发送新增资源，有什么区别"><a href="#PUT-和-POST-都是给服务器发送新增资源，有什么区别" class="headerlink" title="PUT 和 POST 都是给服务器发送新增资源，有什么区别"></a>PUT 和 POST 都是给服务器发送新增资源，有什么区别</h2><p>PUT 和 POST ⽅法的区别是,PUT ⽅法是幂等的：连续调⽤⼀次或者多次的效果相同（⽆副作⽤），⽽ POST ⽅法是⾮幂<br>等的。</p>
<p>除此之外还有⼀个区别，通常情况下，PUT 的 URI 指向是具体单⼀资源，⽽ POST 可以指向资源集合。</p>
<p>举个例⼦，我们在开发⼀个博客系统，当我们要创建⼀篇⽂章的时候往往⽤ POST <a href="https://www.jianshu.com/articles%EF%BC%8C%E8%BF%99%E4%B8%AA%E8%AF%B7%E6%B1%82%E7%9A%84%E8%AF%AD%E4%B9%89%E6%98%AF%EF%BC%8C%E5%9C%A8">https://www.jianshu.com/articles，这个请求的语义是，在</a> articles 的资源集合下创建⼀篇新的⽂章，如果我们多次提交这个请求会创建多个⽂章，这是⾮幂等的。⽽ PUT <a href="https://www.jianshu.com/articles/820357430">https://www.jianshu.com/articles/820357430</a> 的语义是更新对应⽂章下的资源（⽐如修改作者名称等），这个 URI 指向的就是单⼀资源，⽽且是幂等的，⽐如你把『刘德华』修改成『蔡徐坤』，提交多少次都是修改成『蔡徐坤』</p>
<h2 id="PUT-和-PATCH-都是给服务器发送修改资源，有什么区别"><a href="#PUT-和-PATCH-都是给服务器发送修改资源，有什么区别" class="headerlink" title="PUT 和 PATCH 都是给服务器发送修改资源，有什么区别"></a>PUT 和 PATCH 都是给服务器发送修改资源，有什么区别</h2><p>PUT 和 PATCH 都是更新资源，⽽ PATCH ⽤来对已知资源进⾏局部更新。</p>
<p>⽐如我们有⼀篇⽂章的地址 <a href="https://www.jianshu.com/articles/820357430">https://www.jianshu.com/articles/820357430</a> ,这篇⽂章的可以表示为:</p>
<pre><code class="json">&#123;
  &quot;author&quot;: &quot;dxy&quot;,
  &quot;creationDate&quot;: &quot;2019-6-12&quot;,
  &quot;content&quot;: &quot;我写⽂章像蔡徐坤&quot;,
  &quot;id&quot;: 820357430
&#125;
</code></pre>
<p>当我们要修改⽂章的作者时，我们可以直接发送 PUT <a href="https://www.jianshu.com/articles/820357430">https://www.jianshu.com/articles/820357430</a> ，这个时候的数据应该是:</p>
<pre><code class="json">&#123;
  &quot;author&quot;: &quot;蔡徐坤&quot;,
  &quot;creationDate&quot;: &quot;2019-6-12&quot;,
  &quot;content&quot;: &quot;我写⽂章像蔡徐坤&quot;,
  &quot;id&quot;: 820357430
&#125;
</code></pre>
<p>这种直接覆盖资源的修改⽅式应该⽤ PUT，但是你觉得每次都带有这么多⽆⽤的信息，那么可以发送 PATCH<br><a href="https://www.jianshu.com/articles/820357430">https://www.jianshu.com/articles/820357430</a> ，这个时候只需要:</p>
<pre><code class="json">&#123;
  &quot;author&quot;: &quot;蔡徐坤&quot;
&#125;
</code></pre>
<h2 id="HTTP-的状态码"><a href="#HTTP-的状态码" class="headerlink" title="HTTP 的状态码"></a>HTTP 的状态码</h2><p>2XX 成功</p>
<ul>
<li>200 OK，表示从客户端发来的请求在服务器端被正确处理 ✨</li>
<li>201 Created 请求已经被实现，⽽且有⼀个新的资源已经依据请求的需要⽽建⽴</li>
<li>202 Accepted 请求已接受，但是还没执⾏，不保证完成请求</li>
<li>204 No content，表示请求成功，但响应报⽂不含实体的主体部分</li>
<li>206 Partial Content，进⾏范围请求 ✨</li>
</ul>
<p>3XX 重定向</p>
<ul>
<li>301 moved permanently，永久性重定向，表示资源已被分配了新的 URL</li>
<li>302 found，临时性重定向，表示资源临时被分配了新的 URL ✨</li>
<li>303 see other，表示资源存在着另⼀个 URL，应使⽤ GET ⽅法定向获取资源</li>
<li>304 not modified，表示服务器允许访问资源，但因发⽣请求未满⾜条件的情况</li>
<li>307 temporary redirect，临时重定向，和 302 含义相同</li>
</ul>
<p>4XX 客户端错误</p>
<ul>
<li>400 bad request，请求报⽂存在语法错误 ✨</li>
<li>401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息 ✨</li>
<li>403 forbidden，表示对请求资源的访问被服务器拒绝 ✨</li>
<li>404 not found，表示在服务器上没有找到请求的资源 ✨</li>
<li>408 Request timeout, 客户端请求超时</li>
<li>409 Confict, 请求的资源可能引起冲突</li>
</ul>
<p>5XX 服务器错误</p>
<ul>
<li>500 internal sever error，表示服务器端在执⾏请求时发⽣了错误 ✨</li>
<li>501 Not Implemented 请求超出服务器能⼒范围，例如服务器不⽀持当前请求所需要的某个功能，或者请求是服务器不⽀持的某个⽅法</li>
<li>503 service unavailable，表明服务器暂时处于超负载或正在停机维护，⽆法处理请求</li>
<li>505 http version not supported 服务器不⽀持，或者拒绝⽀持在请求中使⽤的 HTTP 版本</li>
</ul>
<h2 id="HTTP-的缓存的过程"><a href="#HTTP-的缓存的过程" class="headerlink" title="HTTP 的缓存的过程"></a>HTTP 的缓存的过程</h2><ol>
<li>客户端向服务器发出请求，请求资源</li>
<li>服务器返回资源，并通过响应头决定缓存策略</li>
<li>客户端根据响应头的策略决定是否缓存资源（这⾥假设是），并将响应头与资源缓存下来</li>
<li>在客户端再次请求且命中资源的时候，此时客户端去检查上次缓存的缓存策略，根据策略的不同、是否过期等判断是直接读取本地缓存还是与服务器协商缓存</li>
</ol>
<h2 id="什么时候会触发强缓存或者协商缓存"><a href="#什么时候会触发强缓存或者协商缓存" class="headerlink" title="什么时候会触发强缓存或者协商缓存"></a>什么时候会触发强缓存或者协商缓存</h2><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>强缓存离不开两个响应头 Expires 与 Cache-Control</p>
<ul>
<li>Expires：Expires 是 http1.0 提出的⼀个表示资源过期时间的 header，它描述的是⼀个绝对时间，由服务器返回，Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效 <code>Expires: Wed, 11 May 2018 07:20:00 GMT</code></li>
<li>Cache-Control: Cache-Control 出现于 HTTP / 1.1，优先级⾼于 Expires，表示的是相对时间 <code>Cache-Control: max-age=315360000</code></li>
</ul>
<p>⽬前主流的做法使⽤ Cache-Control 控制缓存，除了 max-age 控制过期时间外，还有⼀些不得不提</p>
<ul>
<li><code>Cache-Control: public</code> 可以被所有⽤户缓存，包括终端和 CDN 等中间代理服务器</li>
<li><code>Cache-Control: private</code> 只能被终端浏览器缓存，不允许中继缓存服务器进⾏缓存</li>
<li><code>Cache-Control: no-cache</code> 先缓存本地，但是在命中缓存之后必须与服务器验证缓存的新鲜度才能使⽤</li>
<li><code>Cache-Control: no-store</code> 不会产⽣任何缓存</li>
</ul>
<h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>当第⼀次请求时服务器返回的响应头中没有 Cache-Control 和 Expires 或者 Cache-Control 和 Expires 过期抑或它的属性设置为 no-cache 时，那么浏览器第⼆次请求时就会与服务器进⾏协商。</p>
<p>如果缓存和服务端资源的最新版本是⼀致的，那么就⽆需再次下载该资源，服务端直接返回 304 Not Modified 状态码，如果服务器发现浏览器中的缓存已经是旧版本了，那么服务器就会把最新资源的完整内容返回给浏览器，状态码就是<br>200 Ok。</p>
<h2 id="三次握⼿"><a href="#三次握⼿" class="headerlink" title="三次握⼿"></a>三次握⼿</h2><p>所谓三次握⼿(Three-way Handshake)，是指建⽴⼀个 TCP 连接时，需要客户端和服务器总共发送 3 个包。</p>
<p>三次握⼿的⽬的是连接服务器指定端⼝，建⽴ TCP 连接，并同步连接双⽅的序列号和确认号，交换 TCP 窗⼝⼤⼩信<br>息。在 socket 编程中，客户端执⾏ connect() 时，将触发三次握⼿。</p>
<ul>
<li><p>第⼀次握⼿(SYN=1, seq=x):</p>
<p>客户端发送⼀个 TCP 的 SYN 标志位置 1 的包，指明客户端打算连接的服务器的端⼝，以及初始序号 X，保存在包头的序列号(Sequence Number)字段⾥。发送完毕后，客户端进⼊ SYN_SEND 状态。</p>
</li>
<li><p>第⼆次握⼿(SYN=1, ACK=1, seq=y, ACKnum=x+1):</p>
<p>服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为 1。服务器端选择⾃⼰ ISN 序列号，放到 Seq 域⾥，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加 1，即 X+1。发送完毕后，服务器端进⼊ SYN_RCVD 状态。</p>
</li>
<li><p>第三次握⼿(ACK=1，ACKnum=y+1)</p>
<p>客户端再次发送确认包(ACK)，SYN 标志位为 0，ACK 标志位为 1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对⽅，并且在数据段放写 ISN 的+1 发送完毕后，客户端进⼊ ESTABLISHED 状态，当服务器端接收到这个包时，也进⼊ ESTABLISHED 状态，TCP 握⼿结束。</p>
</li>
</ul>
<h2 id="什么是浏览器同源策略"><a href="#什么是浏览器同源策略" class="headerlink" title="什么是浏览器同源策略"></a>什么是浏览器同源策略</h2><p>同源策略限制了从同⼀个源加载的⽂档或脚本如何与来⾃另⼀个源的资源进⾏交互。这是⼀个⽤于隔离潜在恶意⽂件的<br>重要安全机制。</p>
<p>同源是指”协议+域名+端⼝”三者相同，即便两个不同的域名指向同⼀个 ip 地址，也⾮同源。</p>
<p>浏览器中的⼤部分内容都是受同源策略限制的，但是以下三个标签可以不受限制：</p>
<ul>
<li><code>&lt;img src=XXX&gt;</code></li>
<li><code>&lt;link href=XXX&gt;</code></li>
<li><code>&lt;script src=XXX&gt;</code></li>
</ul>
<h2 id="如何实现跨域"><a href="#如何实现跨域" class="headerlink" title="如何实现跨域"></a>如何实现跨域</h2><h3 id="最经典的跨域⽅案-jsonp"><a href="#最经典的跨域⽅案-jsonp" class="headerlink" title="最经典的跨域⽅案 jsonp"></a>最经典的跨域⽅案 jsonp</h3><p>jsonp 本质上是⼀个 Hack，它利⽤ <code>&lt;script&gt;</code> 标签不受同源策略限制的特性进⾏跨域操作。<br>jsonp 优点：</p>
<ul>
<li>实现简单</li>
<li>兼容性⾮常好</li>
</ul>
<p>jsonp 的缺点：</p>
<ul>
<li>只⽀持 get 请求（因为 <code>&lt;script&gt;</code> 标签只能 get）</li>
<li>有安全性问题，容易遭受 xss 攻击</li>
<li>需要服务端配合 jsonp 进⾏⼀定程度的改造</li>
</ul>
<pre><code class="js">function JSONP(&#123; url, params, callbackKey, callback &#125;) &#123;
  // 在参数⾥制定 callback 的名字
  params = params || &#123;&#125;
  params[callbackKey] = &#39;jsonpCallback&#39;
  // 预留 callback
  window.jsonpCallback = callback
  // 拼接参数字符串
  const paramKeys = Object.keys(params)
  const paramString = paramKeys.map(key =&gt; `$&#123;key&#125;=$&#123;params[key]&#125;`).join(&#39;&amp;&#39;)
  // 插⼊ DOM 元素
  const script = document.createElement(&#39;script&#39;)
  script.setAttribute(&#39;src&#39;, `$&#123;url&#125;?$&#123;paramString&#125;`)
  document.body.appendChild(script)
&#125;

JSONP(&#123;
  url: &#39;http://s.weibo.com/ajax/jsonp/suggestion&#39;,
  params: &#123;
    key: &#39;test&#39;,
  &#125;,
  callbackKey: &#39;_cb&#39;,
  callback(result) &#123;
    console.log(result.data)
  &#125;,
&#125;)
</code></pre>
<h3 id="最流⾏的跨域⽅案-cors"><a href="#最流⾏的跨域⽅案-cors" class="headerlink" title="最流⾏的跨域⽅案 cors"></a>最流⾏的跨域⽅案 cors</h3><h3 id="最⽅便的跨域⽅案-Nginx"><a href="#最⽅便的跨域⽅案-Nginx" class="headerlink" title="最⽅便的跨域⽅案 Nginx"></a>最⽅便的跨域⽅案 Nginx</h3><h3 id="其它跨域⽅案"><a href="#其它跨域⽅案" class="headerlink" title="其它跨域⽅案"></a>其它跨域⽅案</h3><ol>
<li>HTML5 XMLHttpRequest 有⼀个 API，postMessage()⽅法允许来⾃不同源的脚本采⽤异步⽅式进⾏有限的通信，可以实现跨⽂本档、多窗⼝、跨域消息传递。</li>
<li>WebSocket 是⼀种双向通信协议，在建⽴连接之后，WebSocket 的 server 与 client 都能主动向对⽅发送或接收数据，连接建⽴好了之后 client 与 server 之间的双向通信就与 HTTP ⽆关了，因此可以跨域。</li>
<li>window.name + iframe：window.name 属性值在不同的⻚⾯（甚⾄不同域名）加载后依旧存在，并且可以⽀持⾮常⻓的 name 值，我们可以利⽤这个特点进⾏跨域。</li>
<li>location.hash + iframe：a.html 欲与 c.html 跨域相互通信，通过中间⻚ b.html 来实现。 三个⻚⾯，不同域之间利⽤ iframe 的 location.hash 传值，相同域之间直接 js 访问来通信。</li>
<li>document.domain + iframe： 该⽅式只能⽤于⼆级域名相同的情况下，⽐如 a.test.com 和 b.test.com 适⽤于该⽅式，我们只需要给⻚⾯添加 document.domain =’test.com’ 表示⼆级域名都相同就可以实现跨域，两个⻚⾯都通过 js 强制设置 document.domain 为基础主域，就实现了同域。</li>
</ol>
<h1 id="前端⼯程化"><a href="#前端⼯程化" class="headerlink" title="前端⼯程化"></a>前端⼯程化</h1><h2 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h2><h1 id="Vue-面试题"><a href="#Vue-面试题" class="headerlink" title="Vue 面试题"></a>Vue 面试题</h1><h2 id="对-MVVM-的理解"><a href="#对-MVVM-的理解" class="headerlink" title="对 MVVM 的理解"></a>对 MVVM 的理解</h2><p>MVVM 模式，顾名思义即 Model-View-ViewModel 模式。</p>
<ul>
<li>Model 层：对应数据层的域模型，它主要做域模型的同步。通过 Ajax/fetch 等 API 完成客户端和服务端业务 Model 的同步。在层间关系⾥，它主要⽤于抽象出 ViewModel 中视图的 Model。</li>
<li>View 层：作为视图模板存在，在 MVVM ⾥，整个 View 是⼀个动态模板。除了定义结构、布局外，它展示的是 ViewModel 层的数据和状态。View 层不负责处理状态，View 层做的是 数据绑定的声明、 指令的声明、 事件绑定的声明。</li>
<li>ViewModel 层:把 View 需要的层数据暴露，并对 View 层的 数据绑定声明、 指令声明、 事件绑定声明 负责，也就是处理 View 层的具体业务逻辑。ViewModel 底层会做好绑定属性的监听。当 ViewModel 中数据变化，View 层会得到更新；⽽当 View 中声明了数据的双向绑定（通常是表单元素），框架也会监听 View 层（表单）值的变化。⼀旦值变化，View 层绑定的 ViewModel 中的数据也会得到⾃动更新。</li>
</ul>
<p><a href="https://cdn.jsdelivr.net/gh/chivesssss/picture-store@master/uPic/2021/03/28/15/17/1ceV0u.png">示例</a></p>
<p>优点:</p>
<ol>
<li>分离视图（View）和模型（Model），降低代码耦合，提⾼视图或者逻辑的重⽤性: ⽐如视图（View）可以独⽴于 Model 变化和修改，⼀个 ViewModel 可以绑定不同的 “View” 上，当 View 变化的时候 Model 不可以不变，当 Model 变化的时候 View 也可以不变。你可以把⼀些视图逻辑放在⼀个 ViewModel ⾥⾯，让很多 view 重⽤这段视图逻辑</li>
<li>提⾼可测试性: ViewModel 的存在可以帮助开发者更好地编写测试代码</li>
<li>⾃动更新 dom: 利⽤双向绑定,数据更新后视图⾃动更新,让开发者从繁琐的⼿动 dom 中解放</li>
</ol>
<p>缺点:</p>
<ol>
<li>Bug 很难被调试: 因为使⽤双向绑定的模式，当你看到界⾯异常了，有可能是你 View 的代码有 Bug，也可能是 Model 的代码有问题。数据绑定使得⼀个位置的 Bug 被快速传递到别的位置，要定位原始出问题的地⽅就变得不那么容易了。另外，数据绑定的声明是指令式地写在 View 的模版当中的，这些内容是没办法去打断点 debug 的</li>
<li>⼀个⼤的模块中 model 也会很⼤，虽然使⽤⽅便了也很容易保证了数据的⼀致性，当时⻓期持有，不释放内存就造成了花费更多的内存</li>
<li>对于⼤型的图形应⽤程序，视图状态较多，ViewModel 的构建和维护的成本都会⽐较⾼</li>
</ol>
<h2 id="Vue-组件如何通信"><a href="#Vue-组件如何通信" class="headerlink" title="Vue 组件如何通信"></a>Vue 组件如何通信</h2><ul>
<li><code>props/$emit+v-on</code>: 通过 props 将数据⾃上⽽下传递，⽽通过$emit 和 v-on 来向上传递信息。</li>
<li><code>EventBus</code>: 通过 EventBus 进⾏信息的发布与订阅</li>
<li><code>vuex</code>: 是全局数据管理库，可以通过 vuex 管理全局的数据流</li>
<li><code>$attrs/$listeners</code>: Vue 2.4 中加⼊的 <code>$attrs/$listeners</code> 可以进⾏跨级的组件通信</li>
<li><code>provide/inject</code>：以允许⼀个祖先组件向其所有⼦孙后代注⼊⼀个依赖，不论组件层次有多深，并在起上下游关系成⽴的时间⾥始终⽣效，这成为了跨组件通信的基础</li>
</ul>
<h2 id="computed-和-watch-有什么区别"><a href="#computed-和-watch-有什么区别" class="headerlink" title="computed 和 watch 有什么区别"></a>computed 和 watch 有什么区别</h2><p>computed:</p>
<ol>
<li>computed 是计算属性，也就是计算值，它更多⽤于计算值的场景</li>
<li>computed 具有缓存性，computed 的值在 getter 执⾏后是会缓存的，只有在它依赖的属性值改变之后，下⼀次获取 computed 的值时才会重新调⽤对应的 getter 来计算</li>
<li>computed 适⽤于计算⽐较消耗性能的计算场景</li>
</ol>
<p>watch:</p>
<ol>
<li>更多的是「观察」的作⽤，类似于某些数据的监听回调，⽤于观察 <code>props</code>、 <code>$emit</code> 或者本组件的值，当数据变化时来执⾏回调进⾏后续操作</li>
<li>⽆缓存性，⻚⾯重新渲染时值不变化也会执⾏</li>
</ol>
<p>⼩结:</p>
<ol>
<li>当我们要进⾏数值计算，⽽且依赖于其他数据，那么把这个数据设计为 computed</li>
<li>如果你需要在某个数据变化时做⼀些事情，使⽤ watch 来观察这个数据变化</li>
</ol>
<h2 id="Vue-是如何实现双向绑定的"><a href="#Vue-是如何实现双向绑定的" class="headerlink" title="Vue 是如何实现双向绑定的"></a>Vue 是如何实现双向绑定的</h2><p>利⽤ <code>Object.defineProperty</code> 劫持对象的访问器，在属性值发⽣变化时我们可以获取变化，然后根据变化进⾏后续响应，在 Vue 3.0 中通过 <code>Proxy</code> 代理对象进⾏类似的操作。</p>
<pre><code class="js">// 这是将要被劫持的对象
const data = &#123;
  name: &#39;&#39;,
&#125;

function say(name) &#123;
  if (name === &#39;古天乐&#39;) &#123;
    console.log(&#39;给⼤家推荐⼀款超好玩的游戏&#39;)
  &#125; else if (name === &#39;渣渣辉&#39;) &#123;
    console.log(&#39;戏我演过很多,可游戏我只玩贪玩懒⽉&#39;)
  &#125; else &#123;
    console.log(&#39;来做我的兄弟&#39;)
  &#125;
&#125;
// 遍历对象，对其属性值进⾏劫持
Object.keys(data).forEach(function (key) &#123;
  Object.defineProperty(data, key, &#123;
    enumerable: true,
    configurable: true,
    get: function () &#123;
      console.log(&#39;get&#39;)
    &#125;,
    set: function (newVal) &#123;
      // 当属性值发⽣变化时我们可以进⾏额外操作
      console.log(`⼤家好,我系$&#123;newVal&#125;`)
      say(newVal)
    &#125;,
  &#125;)
&#125;)
data.name = &#39;渣渣辉&#39;
//⼤家好,我系渣渣辉
//戏我演过很多,可游戏我只玩贪玩懒⽉
</code></pre>
<h2 id="Proxy-与-Object-defineProperty-的优劣对⽐"><a href="#Proxy-与-Object-defineProperty-的优劣对⽐" class="headerlink" title="Proxy 与 Object.defineProperty 的优劣对⽐"></a>Proxy 与 Object.defineProperty 的优劣对⽐</h2><p>Proxy 的优势如下:</p>
<ul>
<li>Proxy 可以直接监听对象⽽⾮属性</li>
<li>Proxy 可以直接监听数组的变化</li>
<li>Proxy 有多达 13 种拦截⽅法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的</li>
<li>Proxy 返回的是⼀个新对象,我们可以只操作新的对象达到⽬的,⽽ Object.defineProperty 只能遍历对象属性直接修改</li>
<li>Proxy 作为新标准将受到浏览器⼚商重点持续的性能优化，也就是传说中的新标准的性能红利</li>
</ul>
<p>Object.defineProperty 的优势如下:</p>
<ul>
<li>兼容性好,⽀持 IE9</li>
</ul>
<h2 id="既然-Vue-通过数据劫持可以精准探测数据变化-为什么还需要虚拟-DOM-进⾏-diff-检测差异"><a href="#既然-Vue-通过数据劫持可以精准探测数据变化-为什么还需要虚拟-DOM-进⾏-diff-检测差异" class="headerlink" title="既然 Vue 通过数据劫持可以精准探测数据变化,为什么还需要虚拟 DOM 进⾏ diff 检测差异"></a>既然 Vue 通过数据劫持可以精准探测数据变化,为什么还需要虚拟 DOM 进⾏ diff 检测差异</h2><h2 id="Vue-中的-key-到底有什么⽤"><a href="#Vue-中的-key-到底有什么⽤" class="headerlink" title="Vue 中的 key 到底有什么⽤"></a>Vue 中的 key 到底有什么⽤</h2><p>key 是为 Vue 中的 vnode 标记的唯⼀ id,通过这个 key,我们的 diff 操作可以更准确、更快速</p>
<h1 id="Webpack-⾯试题"><a href="#Webpack-⾯试题" class="headerlink" title="Webpack ⾯试题"></a>Webpack ⾯试题</h1><h2 id="有哪些常⻅的-Loader"><a href="#有哪些常⻅的-Loader" class="headerlink" title="有哪些常⻅的 Loader"></a>有哪些常⻅的 Loader</h2><ul>
<li>file-loader：把⽂件输出到⼀个⽂件夹中，在代码中通过相对 URL 去引⽤输出的⽂件</li>
<li>url-loader：和 file-loader 类似，但是能在⽂件很⼩的情况下以 base64 的⽅式把⽂件内容注⼊到代码中去</li>
<li>source-map-loader：加载额外的 Source Map ⽂件，以⽅便断点调试</li>
<li>image-loader：加载并且压缩图⽚⽂件</li>
<li>babel-loader：把 ES6 转换成 ES5</li>
<li>css-loader：加载 CSS，⽀持模块化、压缩、⽂件导⼊等特性</li>
<li>style-loader：把 CSS 代码注⼊到 JavaScript 中，通过 DOM 操作去加载 CSS。</li>
<li>eslint-loader：通过 ESLint 检查 JavaScript 代码</li>
</ul>
<h2 id="有哪些常⻅的-Plugin"><a href="#有哪些常⻅的-Plugin" class="headerlink" title="有哪些常⻅的 Plugin"></a>有哪些常⻅的 Plugin</h2><ul>
<li>define-plugin：定义环境变量</li>
<li>html-webpack-plugin：简化 html ⽂件创建</li>
<li>uglifyjs-webpack-plugin：通过 UglifyES 压缩 ES6 代码</li>
<li>webpack-parallel-uglify-plugin: 多核压缩,提⾼压缩速度</li>
<li>webpack-bundle-analyzer: 可视化 webpack 输出⽂件的体积</li>
<li>mini-css-extract-plugin: CSS 提取到单独的⽂件中,⽀持按需加载</li>
</ul>
<h2 id="Loader-和-Plugin-的不同"><a href="#Loader-和-Plugin-的不同" class="headerlink" title="Loader 和 Plugin 的不同"></a>Loader 和 Plugin 的不同</h2><p>不同的作⽤:</p>
<ul>
<li>Loader 直译为”加载器”。Webpack 将⼀切⽂件视为模块，但是 webpack 原⽣是只能解析 js ⽂件，如果想将其他⽂件也打包的话，就会⽤到 loader 。 所以 Loader 的作⽤是让 webpack 拥有了加载和解析⾮ JavaScript ⽂件的能⼒。</li>
<li>Plugin 直译为”插件”。Plugin 可以扩展 webpack 的功能，让 webpack 具有更多的灵活性。 在 Webpack 运⾏的⽣命周期中会⼴播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</li>
</ul>
<p>不同的⽤法:</p>
<ul>
<li>Loader 在 module.rules 中配置，也就是说他作为模块的解析规则⽽存在。 类型为数组，每⼀项都是⼀个 Object ，⾥⾯描述了对于什么类型的⽂件（ test ），使⽤什么加载( loader )和使⽤的参数（ options ）</li>
<li>Plugin 在 plugins 中单独配置。 类型为数组，每⼀项是⼀个 plugin 的实例，参数都通过构造函数传⼊。</li>
</ul>
<h2 id="如何⽤-webpack-来优化前端性能"><a href="#如何⽤-webpack-来优化前端性能" class="headerlink" title="如何⽤ webpack 来优化前端性能"></a>如何⽤ webpack 来优化前端性能</h2><p>⽤ webpack 优化前端性能是指优化 webpack 的输出结果，让打包的最终结果在浏览器运⾏快速⾼效。</p>
<ul>
<li>压缩代码：删除多余的代码、注释、简化代码的写法等等⽅式。可以利⽤ webpack 的 UglifyJsPlugin 和 ParallelUglifyPlugin 来压缩 JS ⽂件， 利⽤ cssnano （css-loader?minimize）来压缩 css</li>
<li>利⽤ CDN 加速： 在构建过程中，将引⽤的静态资源路径修改为 CDN 上对应的路径。可以利⽤ webpack 对于 output 参数和各 loader 的 publicPath 参数来修改资源路径</li>
<li>Tree Shaking： 将代码中永远不会⾛到的⽚段删除掉。可以通过在启动 webpack 时追加参数 <code>--optimize-minimize</code> 来实现</li>
<li>Code Splitting： 将代码按路由维度或者组件分块(chunk)，这样做到按需加载，同时可以充分利⽤浏览器缓存</li>
<li>提取公共第三⽅库: SplitChunksPlugin 插件来进⾏公共模块抽取，利⽤浏览器缓存可以⻓期缓存这些⽆需频繁变动的公共代码</li>
</ul>
<h2 id="解析-URL-Params"><a href="#解析-URL-Params" class="headerlink" title="解析 URL Params"></a>解析 URL Params</h2><pre><code class="js">function parseParam(url) &#123;
  const paramsStr = /.+\?(.+)$/.exec(url)[1] // 将 ? 后⾯的字符串取出来
  const paramsArr = paramsStr.split(&#39;&amp;&#39;) // 将字符串以 &amp; 分割后存到数组中
  let paramsObj = &#123;&#125;
  // 将 params 存到对象中
  paramsArr.forEach(param =&gt; &#123;
    if (/=/.test(param)) &#123;
      // 处理有 value 的参数
      let [key, val] = param.split(&#39;=&#39;) // 分割 key 和 value
      val = decodeURIComponent(val) // 解码
      val = /^\d+$/.test(val) ? parseFloat(val) : val // 判断是否转为数字
      if (paramsObj.hasOwnProperty(key)) &#123;
        // 如果对象有 key，则添加⼀个值
        paramsObj[key] = [].concat(paramsObj[key], val)
      &#125; else &#123;
        // 如果对象没有这个 key，创建 key 并设置值
        paramsObj[key] = val
      &#125;
    &#125; else &#123;
      // 处理没有 value 的参数
      paramsObj[param] = true
    &#125;
  &#125;)
  return paramsObj
&#125;
</code></pre>
<h2 id="实现防抖函数（debounce）"><a href="#实现防抖函数（debounce）" class="headerlink" title="实现防抖函数（debounce）"></a>实现防抖函数（debounce）</h2><pre><code class="js">// 防抖函数
const debounce = (fn, delay) =&gt; &#123;
  let timer = null
  return (...args) =&gt; &#123;
    clearTimeout(timer)
    timer = setTimeout(() =&gt; &#123;
      fn.apply(this, args)
    &#125;, delay)
  &#125;
&#125;
</code></pre>
<p>按钮提交场景：防⽌多次提交按钮，只执⾏最后提交的⼀次</p>
<h2 id="实现节流函数（throttle）"><a href="#实现节流函数（throttle）" class="headerlink" title="实现节流函数（throttle）"></a>实现节流函数（throttle）</h2><p>防抖函数原理：规定在⼀个单位时间内，只能触发⼀次函数。如果这个单位时间内触发多次函数，只有⼀次⽣效。</p>
<pre><code class="js">// 节流函数
const throttle = (fn, delay = 500) =&gt; &#123;
  let flag = true
  return (...args) =&gt; &#123;
    if (!flag) return
    flag = false
    setTimeout(() =&gt; &#123;
      fn.apply(this, args)
      flag = true
    &#125;, delay)
  &#125;
&#125;
</code></pre>
<h2 id="实现一个-Promise"><a href="#实现一个-Promise" class="headerlink" title="实现一个 Promise"></a>实现一个 Promise</h2><h2 id="请求二次重发"><a href="#请求二次重发" class="headerlink" title="请求二次重发"></a>请求二次重发</h2><blockquote>
<p>135 页前后各种方法的自定义实现值得深入学习</p>
</blockquote>
<h1 id="原始类型、引用类型"><a href="#原始类型、引用类型" class="headerlink" title="原始类型、引用类型"></a>原始类型、引用类型</h1><p>原始类型：<code>undefined</code>、<code>null</code>、<code>boolean</code>、 <code>string</code>、 <code>number</code>、 <code>symbol</code></p>
<p><code>typeof null === &#39;object&#39;</code> 是一个历史悠久的 bug，因为 <code>000</code> 开始表示对象， <code>null</code> 也是全零</p>
<p>原始类型存储的是值，引用类型存储的是指针</p>
<p><code>typeof</code> 可以判断除了 <code>null</code> 以外的原始类型。 <code>instanceof</code> 可以判对象的正确类型，但是不能判断原始类型，因为它是通过<code>原型链</code>去判断的。</p>
<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><p>略，详见掘金小册</p>
<h1 id="this"><a href="#this" class="headerlink" title="this"></a>this</h1><ol>
<li>定义一个函数 <code>foo()</code>，如果直接调用 <code>foo</code> ，不管 <code>foo</code> 函数放在了什么地方， <code>this</code> 一定是 <code>window</code></li>
<li>对于 <code>obj.foo()</code> 等情形，谁调用了函数，谁就是 <code>this</code> 。这里 <code>this</code> 就是 <code>obj</code> 对象</li>
<li>对于 <code>const f = new foo()</code> 的方式来说， <code>this</code> 永远指向 <code>f</code> ，不会有任何改变</li>
<li>箭头函数是没有 <code>this</code> 的，箭头函数的 <code>this</code> 取决于包裹箭头函数的第一个普通函数的 <code>this</code> 。另外，箭头函数使用 <code>bind</code> 、 <code>new</code> 这类函数是无效的</li>
<li>对于 <code>bind</code> 这些改变上下文的 API， <code>this</code> 只取决于第一个参数，如果第一个参数为空，那么就是 <code>window</code> 。注意，一个函数无论我们 <code>bind</code> 几次， <code>this</code> 永远由第一次 bind 决定</li>
</ol>
<pre><code class="javascript">const a = &#123;&#125;
const fn = function () &#123;
  console.log(this)
&#125;
fn.bind().bind(a)()

// 换种写法
const fn2 = function () &#123;
  return function () &#123;
    return fn.apply()
  &#125;.apply(a)
&#125;
</code></pre>
<ol start="6">
<li>综上： <strong><code>new</code> 的方式优先级最高，其次 <code>bind</code> 等函数，然后是 <code>obj.foo()</code> 这种方式的调用，最后是 <code>直接调用</code>。同时，箭头函数的 <code>this</code> 一旦绑定，就不会再改变了</strong></li>
</ol>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>定义：函数和 <code>声明</code> 这个函数时的作用域结合起来，就是闭包</p>
<pre><code class="js">;(function () &#123;
  var a = 1
  function add() &#123;
    var b = 2
    var sum = b + a
    console.log(sum) // 3
  &#125;
  add()
&#125;)()
</code></pre>
<p><code>add</code> 函数本身，以及其内部可访问的变量，即 <code>a = 1</code> ，这两个组合在⼀起就被称为闭包，仅此⽽已。</p>
<p>闭包最⼤的作⽤就是<strong>隐藏变量</strong>，闭包的⼀⼤特性就是<strong>内部函数总是可以访问其所在的外部函数中声明的参数和变量</strong>，即使在其外部函数被返回（寿命终结）了之后也可以访问。</p>
<p>基于此特性，JavaScript 可以实现<strong>私有变量</strong>、<strong>特权变量</strong>、<strong>储存变量</strong>等</p>
<p>我们就以<strong>私有变量</strong>举例，私有变量的实现⽅法很多，有靠约定的（变量名前加<code>_</code>）,有靠 <code>Proxy</code> 代理的，也有靠 <code>Symbol</code> 这种新数据类型的。</p>
<p>但是真正⼴泛流⾏的其实是使⽤闭包。</p>
<pre><code class="js">function Person() &#123;
  var name = &#39;Jim&#39;
  this.getName = function () &#123;
    return name
  &#125;
  this.setName = function (value) &#123;
    name = value
  &#125;
&#125;
const Jim = new Person()
console.log(Jim.getName()) // Jim
Jim.setName(&#39;Tom&#39;)
console.log(Jim.getName()) // Tom
console.log(name) //name is not defined
</code></pre>
<p>其他例子</p>
<pre><code class="javascript">// 第一题
;(function () &#123;
  function createIncrement() &#123;
    let count = 0
    function increment() &#123;
      count++
    &#125;

    let message = `Count is $&#123;count&#125;`
    function log() &#123;
      console.log(message)
    &#125;

    return [increment, log]
  &#125;

  const [increment, log] = createIncrement()
  increment()
  increment()
  increment()
  log() // =&gt; ?
&#125;)()

// 第二题
;(function () &#123;
  function fn() &#123;
    a = 0
    return function (b) &#123;
      return b + a++
    &#125;
  &#125;
  var f = fn()
  console.log(f(5)) // 5
  console.log(fn()(5)) // 5
  console.log(f(5)) // 6
  console.log(a) // 2
&#125;)()
</code></pre>
<h1 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h1><p>浅拷贝： <code>Object.assign</code> ， <code>&#123;...someObject&#125;</code></p>
<p>深拷贝： <code>JSON.parse(JSON.stringfy(object))</code> ，但是也有局限性</p>
<ul>
<li>会忽略 <code>undefined</code></li>
<li>会忽略 <code>symbol</code></li>
<li>不能序列化函数</li>
<li>不能解决循环引用的对象</li>
</ul>
<pre><code class="javascript">/**
 * 简易版深拷贝函数
 */
const deepClone = obj =&gt; &#123;
  if (typeof obj !== &#39;object&#39;) &#123;
    throw new Error(&#39;发生错误&#39;)
  &#125;

  const newObj = obj instanceof Array ? [] : &#123;&#125;

  for (const key in obj) &#123;
    if (Object.hasOwnProperty.call(obj, key)) &#123;
      const value = obj[key]
      newObj[key] = typeof value === &#39;object&#39; ? deepClone(value) : value
    &#125;
  &#125;
  return newObj
&#125;
</code></pre>
<h1 id="原型及原型链"><a href="#原型及原型链" class="headerlink" title="原型及原型链"></a>原型及原型链</h1><p>当我们创建一个<strong>实例</strong>时 <code>let person = new Person(&#39;Jim&#39;, &#39;25&#39;, &#39;football player&#39;)</code> ，我们可以发现能使用很多种函数，但是我们明明没有定义过它们，对于这种情况你是否有过疑惑？</p>
<p>当我们在浏览器中打印 <code>person</code> 时你会发现，在 <code>person</code> 上居然还有一个 <code>__proto__</code> 属性。其实每个 JS 对象都有 <code>__proto__</code> 属性，这个属性指向了该对象 <code>Person</code> 的原型 <code>Person.prototype</code>。</p>
<p>原型也是一个对象，并且这个对象中包含了很多函数，所以我们可以得出一个结论：对于 <code>person</code> 来说，可以通过 <code>__proto__</code> 找到一个原型对象，在该对象中定义了很多函数让我们来使用。</p>
<p>在 <code>__proto__</code> 对象中还有一个 <code>constructor</code> 属性，也就是构造函数。打开 <code>constructor</code> 属性我们又可以发现其中还有一个 <code>prototype</code> 属性，并且这个属性对应的值和先前我们在 <code>__proto__</code> 中看到的一模一样。所以我们又可以得出一个结论：原型的 <code>constructor</code> 属性指向构造函数，构造函数又通过 <code>prototype</code> 属性指回原型，但是并不是所有函数都具有这个属性，<code>Function.prototype.bind()</code> 就没有这个属性。</p>
<p><img src="https://cdn.jsdelivr.net/gh/chivesssss/picture-store@master/uPic/2021/03/28/13/27/CUIOOY.png" alt="示意图"></p>
<p>总结：</p>
<ul>
<li><code>Object</code> 是所有对象的爸爸，所有对象都可以通过 <code>__proto__</code> 找到它</li>
<li><code>Function</code> 是所有函数的爸爸，所有函数都可以通过 <code>__proto__</code> 找到它</li>
<li>函数的 prototype 是一个对象</li>
<li>对象的 <code>__proto__</code> 属性指向原型， <code>__proto__</code> 将对象和原型连接起来组成了原型链</li>
</ul>
<h1 id="作用域及作用域链"><a href="#作用域及作用域链" class="headerlink" title="作用域及作用域链"></a>作用域及作用域链</h1><p>作用域就是一个<strong>独立的地盘</strong>，最大的用处就是<strong>隔离变量</strong>，不同作用域下同名变量不会有冲突。</p>
<p><code>ES6</code> 之前 <code>JavaScript</code> 没有块级作用域，只有全局作用域和函数作用域。<code>ES6</code>的到来，为我们提供了<code>块级作用域</code>，可通过新增命令 <code>let</code> 和 <code>const</code> 来体现。</p>
<p>全局作用域</p>
<ul>
<li>最外层函数 和在最外层函数外面定义的变量拥有全局作用域</li>
<li>所有末定义直接赋值的变量自动声明为拥有全局作用域</li>
<li>所有 window 对象的属性拥有全局作用域</li>
</ul>
<p>块级作用域</p>
<p>块级作用域可通过新增命令 let 和 const 声明，所声明的变量在指定块的作用域外无法被访问。块级作用域在如下情况被创建：</p>
<ul>
<li>在一个函数内部</li>
<li>在一个代码块（由一对花括号包裹）内部</li>
</ul>
<p>块级作用域有以下几个特点：</p>
<ul>
<li>声明变量不会提升到代码块顶部，所以会暂时性锁区</li>
<li>禁止重复声明</li>
</ul>
<p>作用域链</p>
<p>当在当前作用域中取值失败时，就要到<strong>创建</strong>这个函数的那个作用域中取值，这里强调的是“创建”，而不是“调用”。如果还是取值失败，继续往上，形成的链条，就叫作用域链。</p>
<p>什么是变量提升</p>
<p>JavaScript 引擎的⼯作⽅式是，先解析代码，获取所有被声明的变量，然后再⼀⾏⼀⾏地运⾏。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。存在提升的原因：解决函数之间的相互调用。</p>
<pre><code class="javascript">console.log(a) // undefined
var a = 1
function b() &#123;
  console.log(a)
&#125;
b() // 1
</code></pre>
<p>上⾯的代码实际执⾏顺序是这样的:</p>
<p>第⼀步： 引擎将 <code>var a = 1</code> 拆解为 <code>var a = undefined</code> 和 <code>a = 1</code> ，并将 <code>var a = undefined</code> 放到最顶端， <code>a = 1</code> 还在原来的位置，这样⼀来代码就是这样:</p>
<pre><code class="javascript">var a = undefined
console.log(a) // undefined
a = 1
function b() &#123;
  console.log(a)
&#125;
b() // 1
</code></pre>
<p>第⼆步就是执⾏，因此 js 引擎⼀⾏⼀⾏从上往下执⾏就造成了当前的结果，这就叫变量提升。</p>
<blockquote>
<p>函数提升优于变量提升，函数提升会把 <code>整个函数</code> 挪到作用域顶部，变量提升只会把 <code>变量声明</code> 挪到作用域顶部</p>
</blockquote>
<p>var、let 及 const</p>
<ul>
<li><code>var</code> 存在提升，我们能在声明之前使用。 <code>let</code> <code>、const</code> 因为暂时性死区，不能在声明之前使用</li>
<li>全局作用域下使用 <code>let</code> 和 <code>const</code> 声明变量，变量不会被挂载到 <code>window</code> 上，这和 <code>var</code> 不一样</li>
<li><code>let</code> 和 <code>const</code> 作用基本一致，但是后者声明的变量不能再次赋值</li>
</ul>
<h1 id="原型继承和-Class-继承"><a href="#原型继承和-Class-继承" class="headerlink" title="原型继承和 Class 继承"></a>原型继承和 Class 继承</h1><pre><code class="javascript">/**
 * 组合继承：子类的构造函数中通过 Parent.call(this) 继承父类的属性，
 * 然后改变子类的原型为 new Parent() 来继承父类的函数
 */
function Parent(value) &#123;
  this.value = value
&#125;

Parent.prototype.getValue = function () &#123;
  console.log(this.value)
&#125;

function Child(value) &#123;
  Parent.call(this, value) // 构造函数可以传参，不会与父类引用属性共享
&#125;

Child.prototype = new Parent() // 可以复用父类的函数，但是子类原型上多了不需要的父类的属性

const child = new Child(1)

child.getValue() // 1

child instanceof Parent // true
</code></pre>
<pre><code class="javascript">/**
 * Class 继承，关键点在于 extends、super
*/
class Parent &#123;
  constructor(value) &#123;
    this.value = value
  &#125;

  getValue() &#123;
    console.log(this.value)
  &#125;
&#125;

Class Child extends Parent &#123;
  constructor(value)&#123;
    super(value)
    this.value = value
  &#125;
&#125;

const child = new Child(1)

child.getValue() // 1

child instanceof Parent // true
</code></pre>
<h1 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h1><h1 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h1><p><code>Proxy</code> 可以理解成，在目标对象之前架设一层<code>“拦截”</code>，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</p>
<pre><code class="javascript">let proxy = new Proxy(target, handler)
</code></pre>
<ul>
<li><code>target</code> —— 是要包装的<code>对象</code>，可以是任何东西，包括函数。</li>
<li><code>handler</code> —— 代理配置：带有“钩子”（“traps”，即拦截操作的方法）的<code>对象</code>。比如 <code>get</code> 钩子用于读取 <code>target</code> 属性， <code>set</code> 钩子写入 <code>target</code> 属性等等。</li>
</ul>
<blockquote>
<p>对 <code>proxy</code> 进行操作，如果在 <code>handler</code> 中存在相应的钩子，则它将运行，并且 <code>Proxy</code> 有机会对其进行处理，否则将直接对 <code>target</code> 进行处理。</p>
</blockquote>
<p>Handler 对象包含的方法：<code>get</code> 、 <code>set</code> 、 <code>has</code> （in 运算符） 、 <code>deleteProperty</code> （delete 操作） 、 <code>apply</code> （proxy 对象作为函数被调用）、 <code>construct</code> （new 操作）、 <code>defineProperty</code></p>
<pre><code class="javascript">/**
 * 通过自定义 set 和 get 函数的方式，在原本的逻辑中插入了我们的函数
 * 逻辑（回调函数），实现了在对对象任何属性进行读写时发出通知
 */
let obj = &#123; a: 1 &#125;

let onWatch = (target, setCallback, getCallback) =&gt; &#123;
  return new Proxy(target, &#123;
    set(target, key, value, receiver) &#123;
      setCallback(key, value)
      return Reflect.set(target, key, value, receiver)
    &#125;,
    get(target, key, receiver) &#123;
      getCallback(target, key)

      // return target[key]
      return Reflect.get(target, key, receiver)
    &#125;,
  &#125;)
&#125;

let p = onWtch(
  obj,
  (k, v) =&gt; &#123;
    // 数据变化，响应式监听
    console.log(`监测到属性$&#123;k&#125;改变为$&#123;V&#125;`)
  &#125;,
  (t, k) =&gt; &#123;
    // 数据读取，响应式派发
    console.log(`&#39;$&#123;k&#125;&#39; = $&#123;t[k]&#125;`)
  &#125;
)

p.a = 3 // 监测到属性a改变为3
p.a // &#39;a&#39; = 3
</code></pre>
<p>Proxy 有一些局限：</p>
<ul>
<li>内置对象（<code>Map</code>、<code>Set</code>、<code>Promise</code>、<code>Date</code>）具有“内部插槽”，对这些对象的访问无法被代理。</li>
<li>私有类字段也是如此，因为它们是在内部使用插槽实现的。因此，代理方法的调用必须具有目标对象 this 才能访问它们</li>
<li>对象相等性测试 === 不能被拦截</li>
<li>性能：基准测试取决于引擎，但通常使用最简单的代理访问属性所需的时间要长几倍。实际上，这仅对某些“瓶颈”对象重要</li>
</ul>
<h1 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h1><ol>
<li>将 <code>Object</code> 对象的一些明显属于语言内部的方法（比如 <code>Object.defineProperty</code> ），放到 <code>Reflect</code> 对象上。现阶段，某些方法同时在 <code>Object</code> 和 <code>Reflect</code> 对象上部署，未来的新方法将只部署在 <code>Reflect</code> 对象上</li>
<li>修改某些 <code>Object</code> 方法的返回结果，让其变得更合理。比如，<code>Object.defineProperty(obj, name, desc)</code> 在无法定义属性时，会抛出一个错误，而 <code>Reflect.defineProperty(obj, name, desc)</code> 则会返回 <code>false</code> 。</li>
<li>让 <code>Object</code> 操作都变成函数行为。某些 <code>Object</code> 操作是命令式，比如 <code>name in obj</code> 和 <code>delete obj[name]</code>，而 <code>Reflect.has(obj, name)</code> 和 <code>Reflect.deleteProperty(obj, name)</code> 让它们变成了函数行为</li>
<li><code>Reflect</code> 对象的方法与 <code>Proxy</code> 对象的方法一一对应，只要是 <code>Proxy</code> 对象的方法，就能在 <code>Reflect</code> 对象上找到对应的方法。这就让 <code>Proxy</code> 对象可以方便地调用对应的 <code>Reflect</code> 方法，完成<strong>原始对象的默认行为</strong>，作为修改行为的基础。也就是说，不管 <code>Proxy</code> 怎么修改默认行为（e.g. <code>set()、get()</code>），你总可以在 <code>Reflect</code> 上获取原始对象的默认行为。</li>
</ol>
<blockquote>
<p>在大多数情况下，我们可以不使用 <code>Reflect</code> 完成相同的事情，例如，使用 <code>Reflect.get(target, prop, receiver)</code> 读取属性可以替换为 <code>target[prop]</code> 。尽管有一些细微的差别。</p>
</blockquote>
<pre><code class="javascript">let user = &#123;
  _name: &#39;Guest&#39;,
  get name() &#123;
    return this._name
  &#125;,
&#125;

let userProxy = new Proxy(user, &#123;
  get(target, prop, receiver) &#123;
    return target[prop]
  &#125;,
&#125;)

console.log(userProxy.name) // Guest
</code></pre>
<p>该 <code>get</code> 钩子在这里是“ <code>透明的</code> ”，它返回原来的属性，不会做别的任何事情。对于我们的示例而言，这就足够了。</p>
<p>但是对象 <code>admin</code> 从 <code>user</code> 继承后，我们可以观察到错误的行为</p>
<pre><code class="javascript">let user = &#123;
  _name: &#39;Guest&#39;,
  get name() &#123;
    return this._name
  &#125;,
&#125;

let userProxy = new Proxy(user, &#123;
  get(target, prop, receiver) &#123;
    return target[prop] // (*) target = user
  &#125;,
&#125;)

let admin = &#123;
  __proto__: userProxy,
  _name: &#39;Admin&#39;,
&#125;

// Expected: Admin
alert(admin.name) // 输出：Guest （？！？）
</code></pre>
<p>问题实际上出在代理中，在 <code>(*)</code> 行</p>
<ol>
<li>当我们读取 <code>admin.name</code> ，由于 <code>admin</code> 对象自身没有对应的的属性，搜索将转到其原型</li>
<li>原型是 <code>userProxy</code></li>
<li>从代理读取 <code>name</code> 属性时， <code>get</code> 钩子会触发并从原始对象返回 <code>target[prop]</code> 属性，在 <code>(*)</code> 行当调用 <code>target[prop]</code> 时，若 <code>prop</code> 是一个 <code>getter</code> ，它将在 <code>this=target</code> 上下文中运行其代码。因此，结果是来自原始对象 <code>target</code> 的 <code>this._name</code> 即来自 <code>user</code> 。</li>
</ol>
<p>更正后的变体</p>
<pre><code class="javascript">let user = &#123;
  _name: &#39;Guest&#39;,
  get name() &#123;
    return this._name
  &#125;,
&#125;

let userProxy = new Proxy(user, &#123;
  get(target, prop, receiver) &#123;
    // receiver = admin
    return Reflect.get(target, prop, receiver) // (*)
    // return Reflect.get(...arguments)
  &#125;,
&#125;)

let admin = &#123;
  __proto__: userProxy,
  _name: &#39;Admin&#39;,
&#125;

alert(admin.name) // Admin
</code></pre>
<h1 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h1><p>回调地狱：</p>
<ul>
<li>嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身</li>
<li>嵌套函数一多，就很难处理错误</li>
</ul>
<h1 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h1><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>特点：</p>
<ul>
<li>三种状态（ <code>pending</code> 、 <code>resolved</code> 、 <code>rejected</code> ），状态一旦切换，不能改变</li>
<li><code>new Promise</code> 立即执行</li>
<li>链式调用，<code>.then</code> 都是返回一个全新的 <code>Promise</code> 对象</li>
<li>解决了回调地狱</li>
</ul>
<p>缺点：</p>
<ul>
<li><code>Promise</code> 无法取消</li>
<li>错误只能在回调函数里面捕获</li>
</ul>
<pre><code class="javascript">/**
 * 手写 Promise
 * 作用：1、消灭嵌套调用；2、合并多个任务的请求结果
 * API： Promise.resolve, Promise.reject, Promise.prototype.catch,
 * Promise.prototype.finally, Promise.all, Promise.race
 */
const PENDING = &#39;pending&#39;
const RESOLVED = &#39;resolved&#39;
const REJECTED = &#39;rejected&#39;
function MyPromise(executor) &#123;
  this.status = PENDING
  this.value = undefined
  this.reason = undefined

  this.onResolvedCallbacks = []
  this.onRejectedCallbacks = []

  const resolve = value =&gt; &#123;
    if (this.status === PENDING) &#123;
      this.value = value
      this.status = RESOLVED

      this.onResolvedCallbacks.forEach(fn =&gt; fn())
    &#125;
  &#125;

  const reject = reason =&gt; &#123;
    if (this.status === PENDING) &#123;
      this.reason = reason
      this.status = REJECTED

      this.onRejectedCallbacks.forEach(fn =&gt; fn())
    &#125;
  &#125;

  try &#123;
    executor(resolve, reject)
  &#125; catch (error) &#123;
    reject(error)
  &#125;
&#125;

MyPromise.prototype.then = function (onResolved, onRejected) &#123;
  onResolved = typeof onResolved === &#39;function&#39; ? onResolved : v =&gt; v
  onRejected =
    typeof onRejected === &#39;function&#39;
      ? onRejected
      : err =&gt; &#123;
          throw err
        &#125;

  if (this.status === RESOLVED) &#123;
    onResolved(this.value)
  &#125;

  if (this.status === REJECTED) &#123;
    onRejected(this.reason)
  &#125;

  if (this.status === PENDING) &#123;
    this.onResolvedCallbacks.push(() =&gt; &#123;
      onResolved(this.value)
    &#125;)

    this.onRejectedCallbacks.push(() =&gt; &#123;
      onRejected(this.reason)
    &#125;)
  &#125;
&#125;
</code></pre>
<h1 id="async-await"><a href="#async-await" class="headerlink" title="async / await"></a>async / await</h1><p>async 函数，就是 Generator 函数的语法糖，它建⽴在 Promises 上，并且与所有现有的基于 Promise 的 API 兼容。</p>
<ol>
<li><code>async</code> 声明⼀个异步函数(async function someName(){…})</li>
<li>⾃动将常规函数转换成 Promise 函数，返回值也是⼀个 Promise 对象</li>
<li>只有 async 函数内部的异步操作执⾏完，才会执⾏ then ⽅法指定的回调函数</li>
<li>异步函数内部可以使⽤ await</li>
<li><code>await</code> 暂停异步的功能执⾏(var result = await someAsyncCall();)</li>
<li>放置在 Promise 调⽤之前，await 强制其他代码等待，直到 Promise 完成并返回结果</li>
<li>只能与 Promise ⼀起使⽤，不适⽤与回调</li>
<li>await 只能在 async 函数内部使⽤</li>
</ol>
<p>async/await 相⽐于 promise 的优势与劣势</p>
<ol>
<li>代码读起来更加同步，Promise 虽然摆脱了回调地狱，但是 then 的链式调⽤也会带来额外的阅读负担</li>
<li>Promise 传递中间值⾮常麻烦，⽽ async/await ⼏乎是同步的写法，⾮常优雅</li>
<li>错误处理友好，async/await 可以⽤成熟的 try/catch，Promise 的错误捕获⾮常冗余</li>
<li>调试友好，Promise 的调试很差，由于没有代码块，你不能在⼀个返回表达式的箭头函数中设置断点，如果你在⼀个 <code>.then</code> 代码块中使⽤调试器的步进(step-over)功能，调试器并不会进⼊后续的 <code>.then</code> 代码块，因为调试器只能跟踪同步代码的『每⼀步』</li>
<li>多个异步代码变为同步，浪费性能</li>
</ol>
<h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><p><code>setTimeout</code> 、 <code>setInterval</code> 、 <code>requestAnimationFrame</code>，其中前两者的时间并不准确。但是最后 <code>requestAnimationFrame</code> 自带函数节流功能，基本可以保证 16.6 毫秒只执行一次，并且该函数的定时效果是精确的，不会有定时器时间不准的问题。</p>
<pre><code class="javascript">function mySetInterval(callback, interval) &#123;
  let timer
  const now = Date.now
  let startTime = now()
  let endTime = startTime

  const loop = () =&gt; &#123;
    timer = window.requestAnimationFrame(loop)
    endTime = now()
    if (endTime - startTime &gt;= interval) &#123;
      startTime = endTime = now()
      callback(timer)
    &#125;
  &#125;

  timer = window.requestAnimationFrame(loop)
  return timer
&#125;

let a = 0
mySetInterval(timer =&gt; &#123;
  console.log(&#39;1&#39;)
  a++
  if (a === 3) &#123;
    window.cancelAnimationFrame(timer)
  &#125;
&#125;, 1000)
</code></pre>
<h1 id="事件循环-Event-Loop"><a href="#事件循环-Event-Loop" class="headerlink" title="事件循环 (Event Loop)"></a>事件循环 (Event Loop)</h1><p>渲染 Renderer 进程的主要线程</p>
<ul>
<li>GUI 渲染线程</li>
<li>JS 引擎线程</li>
<li>事件触发线程</li>
<li>定时触发器线程</li>
<li>异步 http 请求线程</li>
</ul>
<p>常见的宏任务(<code>macrotask</code>)</p>
<ul>
<li>主代码块 <code>script</code></li>
<li>setTimeout</li>
<li>setInterval</li>
<li>setImmediate - Node</li>
<li>requestAnimationFrame - 浏览器</li>
</ul>
<p>常见微任务(<code>microtask</code>)</p>
<ul>
<li>process.nextTick() - Node</li>
<li>Promise.then()</li>
<li>catch</li>
<li>finally</li>
<li>Object.observe</li>
<li>MutationObserver</li>
</ul>
<h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><ul>
<li>首先，整体的<code>script</code>(作为第一个宏任务)开始执行之前，会把所有代码分为同步任务、异步任务两部分，其中异步任务会再分为宏任务和微任务</li>
<li>同步任务会直接进入主线程依次执行</li>
<li>当主线程内的任务执行完毕，主线程为空时，会检查微任务，如果有任务，就<code>全部执行</code></li>
<li>执行完微任务，就渲染页面</li>
<li>开始下一轮 Event Loop，执行<code>下一个宏任务</code>（异步代码： <code>setTimeout</code> 诸如此类）</li>
</ul>
<blockquote>
<p>PS: 我们可以看到 <code>setTimeout</code> 等宏任务的回调函数在主线程执行，因此，回调函数的执行上下文（<code>this</code>）为 <code>window</code></p>
</blockquote>
<pre><code class="javascript">/**
 * Event loop（执行一个宏任务，执行所有微任务，再继续如此循环）
 * log:1,4,8,7,3,9,6,5,2
 */
;(function () &#123;
  function test() &#123;
    console.log(1)
    setTimeout(function () &#123;
      console.log(2)
    &#125;, 1000)
  &#125;

  test()

  setTimeout(function () &#123;
    Promise.resolve().then(() =&gt; &#123;
      console.log(9)
    &#125;)
    console.log(3)
  &#125;)

  new Promise(function (resolve) &#123;
    console.log(4)
    setTimeout(function () &#123;
      console.log(5)
    &#125;, 100)
    resolve()
  &#125;).then(function () &#123;
    setTimeout(function () &#123;
      console.log(6)
    &#125;, 0)
    console.log(7)
  &#125;)

  console.log(8)
&#125;)()
</code></pre>
<h1 id="手写-apply-、-call-、-bind-函数"><a href="#手写-apply-、-call-、-bind-函数" class="headerlink" title="手写 apply 、 call 、 bind 函数"></a>手写 <code>apply</code> 、 <code>call</code> 、 <code>bind</code> 函数</h1><pre><code class="javascript">/**
 * apply、call 的模拟实现，这两个方法被调用时，函数会立即执行，并返回结果
 */
Function.prototype.myCall = function (context) &#123;
  const context = context || window
  context.fn = this
  const args = []
  for (let i = 1; i &lt; arguments.length; i++) &#123;
    args.push(&#39;arguments[&#39; + i + &#39;]&#39;) // 由于后面会使用 eval 表达式，所以不能直接 push 具体的值
  &#125;
  const result = eval(&#39;context.fn(&#39; + args + &#39;)&#39;)
  delete context.fn
  return result
&#125;

Function.prototype.myApply = function (context, arr) &#123;
  const context = Object(context) || window
  context.fn = this
  let result
  if (!arr) &#123;
    result = context.fn()
  &#125; else &#123;
    const args = []
    for (let i = 0; i &lt; arr.length; i++) &#123;
      args.push(&#39;arr[&#39; + i + &#39;]&#39;)
    &#125;
    result = eval(&#39;context.fn(&#39; + args + &#39;)&#39;)
  &#125;
  delete context.fn
  return result
&#125;
/**
 * bind 的模拟实现。bind 方法会创建一个新函数，这个函数并不会立即执行。当这个新函数被调用时，bind的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。
 */
Function.prototype.myBind = function (context) &#123;
  if (typeof this !== &#39;function&#39;) &#123;
    throw new Error(&#39;Function.prototype.bind - what is trying to be bound is not callable&#39;)
  &#125;

  const self = this
  const args = Array.prototype.slice.call(arguments, 1) // 此处的 arguments 为 bind 时传递的参数
  const fNOP = function () &#123;&#125;

  const fbound = function () &#123;
    /**
     * 当作为构造函数时，this 指向实例，self 指向绑定函数，因为下面修改了 fbound.prototype 为 绑定函数的
     * prototype，此时结果为 true，当结果为 true 的时候，this 指向实例。
     *
     * 当作为普通函数时，this 指向 window，self 指向绑定函数，此时结果为 false，当结果为 false 的时候，
     * this 指向绑定的 context。
     */
    self.apply(this instanceof self ? this : context, args.concat(Array.prototype.slice.call(arguments))) // 此处的 arguments 返回的函数执行时的参数,两处参数合并起来成为 bind 函数完整的参数
  &#125;

  fNOP.prototype = this.prototype // 空函数中转，防止改变 fbound 函数的 prototype 时改变了原来函数的原型
  fbound.prototype = new fNOP()

  return fbound
&#125;
</code></pre>
<h1 id="new"><a href="#new" class="headerlink" title="new"></a>new</h1><p>new 过程中发生的四件事儿</p>
<ol>
<li>创建了一个空对象</li>
<li>链接到原型</li>
<li>绑定 this</li>
<li>返回对象</li>
</ol>
<pre><code class="javascript">/**
 * 模拟实现 new 操作。e.g. myNew(Person,18)
 * @returns 新对象
 */
function myNew() &#123;
  const obj = new Object(), // 用new Object() 的方式新建了一个对象 obj
    Constructor = [].shift.call(arguments) // 取出第一个参数，就是我们要传入的构造函数。此外因为 shift 会修改原数组，所以 arguments 会被去除第一个参数

  obj.__proto__ = Constructor.prototype

  // function Person(name, age) &#123;
  //   this.strength = 60
  //   this.age = age

  //   return &#123;
  //     name: name,
  //     habit: &#39;Games&#39;,
  //   &#125;
  // &#125;

  // var person = new Person(&#39;Kevin&#39;, &#39;18&#39;)

  // console.log(person.name) // Kevin
  // console.log(person.habit) // Games
  // console.log(person.strength) // undefined
  // console.log(person.age) // undefined

  const result = Constructor.apply(obj, arguments)

  return typeof result === &#39;object&#39; ? result : obj // 构造函数返回值如果是一个对象，就返回这个对象，如果不是，就该返回什么就返回什么
&#125;
</code></pre>
<h1 id="instanceof-原理"><a href="#instanceof-原理" class="headerlink" title="instanceof 原理"></a>instanceof 原理</h1><p>通过判断对象（<code>左边</code>）的原型链（<code>__proto__</code>）是不是能找到类型（<code>右边</code>）的 <code>prototype</code></p>
<pre><code class="javascript">/**
 * 自定义instanceof函数
 */
function myInstanceof(left, right) &#123;
  const prototype = right.prototype
  let left = left.__proto__

  while (true) &#123;
    if (left === null || left === undefined) &#123;
      return false
    &#125;

    if (prototype === left) &#123;
      return true
    &#125;

    left = left.__proto__
  &#125;
&#125;
</code></pre>
<h1 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h1><pre><code class="javascript">/**
 * 防抖：事件触发，N秒之后执行。期间再次触发，则重新计算
 */
const debounce = (fn, wait, immediate) =&gt; &#123;
  let timer

  const debounced = function (...args) &#123;
    timer &amp;&amp; clearTimeout(timer)
    if (immediate) &#123;
      const callNow = !timer

      if (callNow) &#123;
        fn.apply(this, args)
      &#125;

      timer = setTimeout(() =&gt; &#123;
        timer = null
      &#125;, wait)
    &#125; else &#123;
      timer = setTimeout(() =&gt; &#123;
        fn.apply(this, args)
      &#125;, wait)
    &#125;
  &#125;

  return debounced
&#125;

/**
 * 节流：事件触发，马上执行，N秒之内，事件不再执行，N秒结束之时，再执行一次
 */
const throttle = (fn, wait) =&gt; &#123;
  let timer,
    previous = 0
  const throttled = function (...args) &#123;
    const now = +new Date()
    const remaining = wait - (now - previous)

    if (remaining &lt;= 0 || remaining &gt; wait) &#123;
      if (timer) &#123;
        clearTimeout(timer)
        timer = null
      &#125;
      previous = now
      fn.apply(this, args)
    &#125; else if (!timer) &#123;
      timer = setTimeout(() =&gt; &#123;
        fn.apply(this, args)
        previous = +new Date()
        timer = null
      &#125;, remaining)
    &#125;
  &#125;

  return throttled
&#125;
</code></pre>
<h1 id="虚拟滚动的原理"><a href="#虚拟滚动的原理" class="headerlink" title="虚拟滚动的原理"></a>虚拟滚动的原理</h1><ol>
<li>起始状态，根据视窗的高度以及元素的高度，确定元素的数量（N），渲染 N 个元素</li>
<li>监听滚轮事件/触摸事件，记录列表的总偏移量。</li>
<li>根据总偏移量计算列表的可视元素起始索引。</li>
<li>从起始索引渲染元素至视口底部。</li>
<li>当总偏移量更新时，重新渲染可视元素列表。</li>
<li>为可视元素列表前后加入缓冲元素。</li>
<li>在滚动量比较小时，直接修改可视元素列表的偏移量。</li>
<li>在滚动量比较大时（比如拖动滚动条），会重新渲染整个列表。</li>
<li>事件节流。</li>
</ol>
<h1 id="Webpack-优化"><a href="#Webpack-优化" class="headerlink" title="Webpack 优化"></a>Webpack 优化</h1><h2 id="减少-webpack-打包时间"><a href="#减少-webpack-打包时间" class="headerlink" title="减少 webpack 打包时间"></a>减少 webpack 打包时间</h2><ol>
<li>优化 loader，转化的代码越多，需要的时间越久，可以优化、配置 loader 搜索文件的范围</li>
<li>happypack，将 loader 的同步执行转化为并行</li>
<li>DllPlugin，将特定的类库提前打包并引入。可以极大的减少打包类库的次数</li>
</ol>
<h2 id="减少-Webpack-打包后文件的体积"><a href="#减少-Webpack-打包后文件的体积" class="headerlink" title="减少 Webpack 打包后文件的体积"></a>减少 Webpack 打包后文件的体积</h2><ol>
<li>按需加载</li>
<li>Tree Shaking</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>前端问题汇总</title>
    <url>/blog/interviews-front-end-issues/</url>
    <content><![CDATA[<h2 id="JS-值的类型"><a href="#JS-值的类型" class="headerlink" title="JS 值的类型"></a>JS 值的类型</h2><h3 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h3><p>在 JS 中，存在着 6 种原始值，分别是：<code>null</code>、<code>undefind</code>、 <code>string</code>、 <code>number</code>、 <code>boolean</code>、 <code>symbol</code>。</p>
<p>原始类型存储的都是值，是没有函数可以调用的。</p>
<span id="more"></span>

<p>此时你肯定会有疑问，这不对呀，明明 <code>&#39;1&#39;.toString()</code> 是可以使用的。其实在这种情况下，<code>&#39;1&#39;</code> 已经不是原始类型了，而是被强制转换成了 String 类型也就是对象类型，所以可以调用 <code>toString</code> 函数。</p>
<p>除了会在必要的情况下强转类型以外，原始类型还有一些坑。</p>
<p>其中 JS 的 <code>number</code> 类型是浮点类型的，在使用中会遇到某些 Bug，比如 <code>0.1 + 0.2 !== 0.3</code>， <code>string</code> 类型是不可变的，无论你在 <code>string</code> 类型上调用何种方法，都不会对值有改变。</p>
<p>另外对于 <code>null</code> 来说，很多人会认为他是个对象类型，其实这是错误的。虽然 <code>typeof null</code> 会输出 <code>object</code> ，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 <code>object</code> 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。</p>
<h3 id="引用类型（对象类型）"><a href="#引用类型（对象类型）" class="headerlink" title="引用类型（对象类型）"></a>引用类型（对象类型）</h3><blockquote>
<p>对象类型和原始类型的不同之处？函数参数是对象会发生什么问题？</p>
</blockquote>
<p>在 JS 中，除了原始类型那么其他的都是对象类型了。对象类型和原始类型不同的是，原始类型存储的是值，对象类型存储的是地址（指针）。当你创建了一个对象类型的时候，计算机会在内存中帮我们开辟一个空间来存放值，但是我们需要找到这个空间，这个空间会拥有一个地址（指针）。</p>
<pre><code class="js">function test(person) &#123;
  person.age = 26
  // 重新为 person 分配了一个对象
  person = &#123;
    name: &#39;yyy&#39;,
    age: 30,
  &#125;

  return person
&#125;
const p1 = &#123;
  name: &#39;yck&#39;,
  age: 25,
&#125;
const p2 = test(p1)
// p1 的 age 属性在函数中被修改
console.log(p1) // -&gt; &#123; name: &#39;yck&#39;, age: 26 &#125;
// p2 是被 return 回来的一个新对象
console.log(p2) // -&gt; &#123; name: &#39;yyy&#39;, age: 30 &#125;
</code></pre>
<h2 id="JS-中的-typeof-vs-instanceof"><a href="#JS-中的-typeof-vs-instanceof" class="headerlink" title="JS 中的 typeof vs instanceof"></a>JS 中的 typeof vs instanceof</h2><blockquote>
<p>typeof 是否能正确判断类型？instanceof 能正确判断对象的原理是什么？</p>
</blockquote>
<p><code>typeof</code> 对于原始类型来说，除了 <code>null</code> 都可以显示正确的类型</p>
<pre><code class="js">typeof 1 // &#39;number&#39;
typeof &#39;1&#39; // &#39;string&#39;
typeof undefined // &#39;undefined&#39;
typeof true // &#39;boolean&#39;
typeof Symbol() // &#39;symbol&#39;
</code></pre>
<p><code>typeof</code> 对于对象来说，除了函数都会显示 <code>object</code> ，所以说 <code>typeof</code> 并不能准确判断变量到底是什么类型</p>
<pre><code class="js">typeof [] // &#39;object&#39;
typeof &#123;&#125; // &#39;object&#39;
typeof console.log // &#39;function&#39;
</code></pre>
<p>如果我们想判断一个对象的正确类型，这时候可以考虑使用 <code>instanceof</code> ，因为内部机制是通过原型链来判断的。</p>
<pre><code class="js">const Person = function () &#123;&#125;
const p1 = new Person()
p1 instanceof Person // true

var str = &#39;hello world&#39;
str instanceof String // false

var str1 = new String(&#39;hello world&#39;)
str1 instanceof String // true
</code></pre>
<p>对于 <strong>原始类型</strong> 来说，你想直接通过 <code>instanceof</code> 来判断类型是不行的，当然我们还是有办法让 <code>instanceof</code> 判断原始类型的</p>
<pre><code class="js">class PrimitiveString &#123;
  static [Symbol.hasInstance](x) &#123;
    return typeof x === &#39;string&#39;
  &#125;
&#125;
console.log(&#39;hello world&#39; instanceof PrimitiveString) // true
</code></pre>
<h2 id="JS-中的类型转换"><a href="#JS-中的类型转换" class="headerlink" title="JS 中的类型转换"></a>JS 中的类型转换</h2><blockquote>
<p>该知识点常在笔试题中见到，熟悉了转换规则就不惧怕此类题目了。</p>
</blockquote>
<p>首先我们要知道，在 JS 中类型转换只有三种情况，分别是：</p>
<ul>
<li>转换为布尔值</li>
<li>转换为数字</li>
<li>转换为字符串</li>
</ul>
<p>我们先来看一个类型转换表格，然后再进入正题</p>
<p><img src="https://cdn.jsdelivr.net/gh/chivesssss/picture-store@master/uPic/type-conversion.png" alt="类型转换表格"></p>
<h3 id="四则运算符"><a href="#四则运算符" class="headerlink" title="四则运算符"></a>四则运算符</h3><p>加法运算符不同于其他几个运算符，它有以下几个特点：</p>
<ul>
<li>运算中其中一方为字符串，那么就会把另一方也转换为字符串</li>
<li>如果一方不是字符串或者数字，那么会将它转换为数字或者字符串</li>
</ul>
<pre><code class="js">1 + &#39;1&#39; // &#39;11&#39;
true + true // 2
4 + [1, 2, 3] // &quot;41,2,3&quot;
</code></pre>
<p>另外对于加法还需要注意这个表达式 <code>&#39;a&#39; + + &#39;b&#39;</code></p>
<pre><code class="js">// &#39;a&#39; + ( + &#39;b&#39; ) 括号内的看成一个表达式
&#39;a&#39; + +&#39;b&#39; // -&gt; &quot;aNaN&quot;
</code></pre>
<p>因为 <code>+ &#39;b&#39;</code> 等于 <code>NaN</code> ，所以结果为 <code>&quot;aNaN&quot;</code>，你可能也会在一些代码中看到过 <code>+ &#39;1&#39;</code> 的形式来快速获取 <code>number</code> 类型。</p>
<p>那么对于 <strong>除了加法的运算符</strong> 来说，只要其中一方是数字，那么另一方就会被转为数字</p>
<pre><code class="js">4 * &#39;3&#39; // 12
4 * [] // 0
4 * [1, 2] // NaN
</code></pre>
<h2 id="JS-中的-this-对象"><a href="#JS-中的-this-对象" class="headerlink" title="JS 中的 this 对象"></a>JS 中的 this 对象</h2><blockquote>
<p>如何正确判断 this？箭头函数的 this 是什么？</p>
</blockquote>
<ul>
<li><code>this</code> 总是指向函数的直接调用者（而非间接调用者）；</li>
<li>如果有 <code>new</code> 关键字， <code>this</code> 指向 <code>new</code> 出来的那个对象；</li>
<li>在事件中， <code>this</code> 指向触发这个事件的对象，特殊的是，IE 中的 attachEvent 中的 <code>this</code> 总是指向全局对象 <code>window</code> ；</li>
</ul>
<pre><code class="js">function a() &#123;
  return () =&gt; &#123;
    return () =&gt; &#123;
      console.log(this)
    &#125;
  &#125;
&#125;
console.log(a()()())
</code></pre>
<p>箭头函数其实是没有 <code>this</code> 的，<strong>箭头函数中的 <code>this</code> 只取决包裹箭头函数的第一个普通函数的 <code>this</code></strong> 。在这个例子中，因为包裹箭头函数的第一个普通函数是 <code>a</code> ，所以此时的 <code>this</code> 是 <code>window</code> 。另外对箭头函数使用 <code>bind</code> 这类函数是无效的。</p>
<p>如果对一个函数进行多次 bind，那么上下文会是什么呢？</p>
<pre><code class="js">let a = &#123;&#125;
let fn = function () &#123;
  console.log(this)
&#125;
fn.bind().bind(a)() // =&gt; ?
</code></pre>
<p>可以从上述代码中发现，不管我们给函数 <code>bind</code> 几次， <code>fn</code> 中的 <code>this</code> 永远由第一次 <code>bind</code> 决定，所以结果永远是 <code>window</code> 。</p>
<p>以上就是 <code>this</code> 的规则了，但是可能会发生多个规则同时出现的情况，这时候不同的规则之间会根据优先级最高的来决定 <code>this</code> 最终指向哪里。</p>
<p>首先， <code>new</code> 的方式优先级最高，接下来是 <code>bind</code> 这些函数，然后是 <code>obj.foo()</code> 这种调用方式，最后是 <code>foo</code> 这种调用方式，同时，箭头函数的 <code>this</code> 一旦被绑定，就不会再被任何方式所改变。</p>
<p><img src="https://cdn.jsdelivr.net/gh/chivesssss/picture-store@master/uPic/this.png" alt="This指向流程"></p>
<h2 id="和-有什么区别？"><a href="#和-有什么区别？" class="headerlink" title="== 和 === 有什么区别？"></a>== 和 === 有什么区别？</h2><p>对于 <code>==</code> 来说，如果对比双方的类型不一样的话，就会进行类型转换。</p>
<p>假如我们需要对比 <code>x</code> 和 <code>y</code> 是否相同，就会进行如下判断流程：</p>
<ol>
<li><p>首先会判断两者类型是否相同。相同的话就是比大小了</p>
</li>
<li><p>类型不相同的话，那么就会进行类型转换</p>
</li>
<li><p>会先判断是否在对比 <code>null</code> 和 <code>undefined</code> ，是的话就会返回 true</p>
</li>
<li><p>判断两者类型是否为 <code>string</code> 和 <code>number</code> ，是的话就会将字符串转换为 <code>number</code></p>
<pre><code class="js">1 == &#39;1&#39;
      ↓
1 ==  1
</code></pre>
</li>
<li><p>判断其中一方是否为 <code>boolean</code> ，是的话就会把 <code>boolean</code> 转为 <code>number</code> 再进行判断</p>
<pre><code class="js">&#39;1&#39; == true
        ↓
&#39;1&#39; ==  1
        ↓
 1  ==  1
</code></pre>
</li>
<li><p>判断其中一方是否为 object 且另一方为 string、number 或者 symbol，是的话就会把 object 转为原始类型再进行判断</p>
<pre><code class="js">&#39;1&#39; == &#123; name: &#39;yck&#39; &#125;
        ↓
&#39;1&#39; == &#39;[object Object]&#39;
</code></pre>
</li>
</ol>
<blockquote>
<p>看完了上面的步骤，对于 [] == ![] 你是否能正确写出答案呢？</p>
<p>步骤：1、 0 == false –&gt; 2、 0 == 0</p>
<p>结果为：true</p>
</blockquote>
<h2 id="JS-闭包函数及其应用场景"><a href="#JS-闭包函数及其应用场景" class="headerlink" title="JS 闭包函数及其应用场景"></a>JS 闭包函数及其应用场景</h2><p>闭包的定义其实很简单：函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。</p>
<pre><code class="js">function A() &#123;
  let a = 1
  window.B = function () &#123;
    console.log(a)
  &#125;
&#125;
A()
B() // 1
</code></pre>
<p>很多人对于闭包的解释可能是函数嵌套了函数，然后返回一个函数。其实这个解释是不完整的，就比如我上面这个例子就可以反驳这个观点。</p>
<blockquote>
<p>在 JS 中，闭包存在的意义就是让我们可以间接访问函数内部的变量。</p>
</blockquote>
<h3 id="经典面试题，循环中使用闭包解决-var-定义函数的问题"><a href="#经典面试题，循环中使用闭包解决-var-定义函数的问题" class="headerlink" title="经典面试题，循环中使用闭包解决 var 定义函数的问题"></a>经典面试题，循环中使用闭包解决 <code>var</code> 定义函数的问题</h3><pre><code class="js">for (var i = 1; i &lt;= 5; i++) &#123;
  setTimeout(function timer() &#123;
    console.log(i)
  &#125;, i * 1000)
&#125;
</code></pre>
<p>首先因为 <code>setTimeout</code> 是个异步函数，所以会先把循环全部执行完毕，这时候 <code>i</code> 就是 <code>6</code> 了，所以会输出一堆 <code>6</code> 。</p>
<p>解决办法有三种，第一种是使用闭包的方式</p>
<pre><code class="js">for (var i = 1; i &lt;= 5; i++) &#123;
  ;(function (j) &#123;
    // 立即执行函数，可以看作函数A
    setTimeout(function timer() &#123;
      // 函数B，访问了函数A的变量
      console.log(j)
    &#125;, j * 1000)
  &#125;)(i)
&#125;
</code></pre>
<p>在上述代码中，我们首先使用了立即执行函数将 <code>i</code> 传入函数内部，这个时候值就被固定在了参数 <code>j</code> 上面不会改变，当下次执行 <code>timer</code> 这个闭包的时候，就可以使用外部函数的变量 <code>j</code> ，从而达到目的。</p>
<p>第二种就是使用 <code>setTimeout</code> 的第三个参数，这个参数会被当成 <code>timer</code> 函数的参数传入。</p>
<pre><code class="js">for (var i = 1; i &lt;= 5; i++) &#123;
  setTimeout(
    function timer(j) &#123;
      console.log(j)
    &#125;,
    i * 1000,
    i
  )
&#125;
</code></pre>
<p>第三种就是使用 let 定义 i 了来解决问题了，这个也是最为推荐的方式</p>
<pre><code class="js">for (let i = 1; i &lt;= 5; i++) &#123;
  setTimeout(function timer() &#123;
    console.log(i)
  &#125;, i * 1000)
&#125;
</code></pre>
<h2 id="JS-中的深浅拷贝"><a href="#JS-中的深浅拷贝" class="headerlink" title="JS 中的深浅拷贝"></a>JS 中的深浅拷贝</h2><blockquote>
<p>什么是浅拷贝？如何实现浅拷贝？什么是深拷贝？如何实现深拷贝？</p>
</blockquote>
<p>我们了解了对象类型在赋值的过程中其实是复制了地址，从而会导致改变了一方其他也都被改变的情况。通常在开发中我们不希望出现这样的问题，我们可以使用浅拷贝来解决这个情况。</p>
<h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>首先可以通过 <code>Object.assign</code> 来解决这个问题，很多人认为这个函数是用来深拷贝的。其实并不是， <code>Object.assign</code> 只会拷贝所有的属性值到新的对象中，如果属性值是对象的话，拷贝的是地址，所以并不是深拷贝。</p>
<pre><code class="js">let a = &#123;
  age: 1,
&#125;
let b = Object.assign(&#123;&#125;, a)
a.age = 2
console.log(b.age) // 1
</code></pre>
<p>另外我们还可以通过展开运算符 <code>...</code> 来实现浅拷贝</p>
<pre><code class="js">let a = &#123;
  age: 1,
&#125;
let b = &#123; ...a &#125;
a.age = 2
console.log(b.age) // 1
</code></pre>
<p>通常浅拷贝就能解决大部分问题了，但是当我们遇到如下情况就可能需要使用到深拷贝了</p>
<pre><code class="js">let a = &#123;
  age: 1,
  jobs: &#123;
    first: &#39;FE&#39;,
  &#125;,
&#125;
let b = &#123; ...a &#125;
a.jobs.first = &#39;native&#39;
console.log(b.jobs.first) // native
</code></pre>
<p>浅拷贝只解决了第一层的问题，如果接下去的值中还有对象的话，那么就又回到最开始的话题了，两者享有相同的地址。要解决这个问题，我们就得使用深拷贝了。</p>
<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>这个问题通常可以通过 JSON.parse(JSON.stringify(object)) 来解决。</p>
<pre><code class="js">let a = &#123;
  age: 1,
  jobs: &#123;
    first: &#39;FE&#39;,
  &#125;,
&#125;
let b = JSON.parse(JSON.stringify(a))
a.jobs.first = &#39;native&#39;
console.log(b.jobs.first) // FE
</code></pre>
<p>但是该方法也是有局限性的：</p>
<ul>
<li>会忽略 <code>undefined</code></li>
<li>会忽略 <code>symbol</code></li>
<li>不能序列化函数</li>
<li>不能解决循环引用的对象</li>
</ul>
<p>当然你可能想自己来实现一个深拷贝，但是其实实现一个深拷贝是很困难的，需要我们考虑好多种边界情况，比如原型链如何处理、DOM 如何处理等等，所以这里我们实现的深拷贝只是简易版，并且我其实更推荐使用 <a href="https://lodash.com/docs/4.17.11#cloneDeep">lodash 的深拷贝函数</a>。</p>
<pre><code class="js">function deepClone(obj) &#123;
  function isObject(o) &#123;
    return (typeof o === &#39;object&#39; || typeof o === &#39;function&#39;) &amp;&amp; o !== null
  &#125;

  if (!isObject(obj)) &#123;
    throw new Error(&#39;非对象&#39;)
  &#125;

  let isArray = Array.isArray(obj)
  let newObj = isArray ? [...obj] : &#123; ...obj &#125;
  Reflect.ownKeys(newObj).forEach(key =&gt; &#123;
    newObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key]
  &#125;)

  return newObj
&#125;

let obj = &#123;
  a: [1, 2, 3],
  b: &#123;
    c: 2,
    d: 3,
  &#125;,
&#125;
let newObj = deepClone(obj)
newObj.b.c = 1
console.log(obj.b.c) // 2
</code></pre>
<h2 id="JS-中的原型、原型链"><a href="#JS-中的原型、原型链" class="headerlink" title="JS 中的原型、原型链"></a>JS 中的原型、原型链</h2><blockquote>
<p>如何理解原型？如何理解原型链？</p>
</blockquote>
<p>当我们创建一个对象时 <code>let obj = &#123; age: 25 &#125;</code> ，我们可以发现能使用很多种函数，但是我们明明没有定义过它们，对于这种情况你是否有过疑惑？</p>
<p>当我们在浏览器中打印 <code>obj</code> 时你会发现，在 <code>obj</code> 上居然还有一个 <code>__proto__</code> 属性。其实每个 JS 对象都有 <code>__proto__</code> 属性，这个属性指向了原型。</p>
<p>原型也是一个对象，并且这个对象中包含了很多函数，所以我们可以得出一个结论：对于 <code>obj</code> 来说，可以通过 <code>__proto__</code> 找到一个原型对象，在该对象中定义了很多函数让我们来使用。</p>
<p>在 <code>__proto__</code> 对象中还有一个 <code>constructor</code> 属性，也就是构造函数。打开 <code>constructor</code> 属性我们又可以发现其中还有一个 <code>prototype</code> 属性，并且这个属性对应的值和先前我们在 <code>__proto__</code> 中看到的一模一样。所以我们又可以得出一个结论：原型的 <code>constructor</code> 属性指向构造函数，构造函数又通过 <code>prototype</code> 属性指回原型，但是并不是所有函数都具有这个属性，<code>Function.prototype.bind()</code> 就没有这个属性。</p>
<p><img src="https://cdn.jsdelivr.net/gh/chivesssss/picture-store@master/uPic/prototype-chain.png" alt="原型及原型链"></p>
<p>总结起来就是以下几点：</p>
<ul>
<li><code>Object</code> 是所有对象的爸爸，所有对象都可以通过 <code>__proto__</code> 找到它</li>
<li><code>Function</code> 是所有函数的爸爸，所有函数都可以通过 <code>__proto__</code> 找到它</li>
<li>函数的 <code>prototype</code> 是一个对象</li>
<li>对象的 <code>__proto__</code> 属性指向原型， <code>__proto__</code> 将对象和原型连接起来组成了原型链</li>
</ul>
<h3 id="经典面试题"><a href="#经典面试题" class="headerlink" title="经典面试题"></a>经典面试题</h3><pre><code class="js">function Foo() &#123;
  getName = function () &#123;
    console.log(1)
  &#125;
  return this
&#125;

Foo.getName = function () &#123;
  console.log(2)
&#125;

Foo.prototype.getName = function () &#123;
  console.log(3)
&#125;

var getName = function () &#123;
  console.log(4)
&#125;

function getName() &#123;
  console.log(5)
&#125;

Foo.getName() // 2

getName() // 4

Foo().getName() // 1

getName() // 1

new Foo.getName() // 2

new Foo().getName() // 3

new new Foo().getName() // 3
</code></pre>
<h2 id="var、let-及-const-区别"><a href="#var、let-及-const-区别" class="headerlink" title="var、let 及 const 区别"></a>var、let 及 const 区别</h2><blockquote>
<p>什么是提升？什么是暂时性死区？var、let 及 const 区别？</p>
</blockquote>
<pre><code class="js">console.log(a) // undefined
var a = 1
</code></pre>
<p>从上述代码中我们可以发现，虽然变量还没有被声明，但是我们却可以使用这个未被声明的变量，这种情况就叫做提升，并且提升的是声明。</p>
<p>对于这种情况，我们可以把代码这样来看</p>
<pre><code class="js">var a
console.log(a) // undefined
a = 1
</code></pre>
<p>接下来我们再来看一个例子</p>
<pre><code class="js">var a = 10
var a
console.log(a)
</code></pre>
<p>对于这个例子，如果你认为打印的值为 <code>undefined</code> 那么就错了，答案应该是 <code>10</code> ，对于这种情况，我们这样来看代码</p>
<pre><code class="js">var a
var a
a = 10
console.log(a)
</code></pre>
<p>到这里为止，我们已经了解了 <code>var</code> 声明的变量会发生提升的情况，其实不仅变量会提升函数也会被提升。</p>
<pre><code class="js">console.log(a) // ƒ a() &#123;&#125;
function a() &#123;&#125;
var a = 1
</code></pre>
<p>对于上述代码，打印结果会是 <code>ƒ a() &#123;&#125;</code>，即使变量声明在函数之后，这也说明了函数会被提升，并且优先于变量提升。</p>
<p>说完了这些，想必大家也知道 <code>var</code> 存在的问题了，使用 <code>var</code> 声明的变量会被提升到作用域的顶部。</p>
<p>我们再来看 let 和 const 的例子</p>
<pre><code class="js">var a = 1
let b = 1
const c = 1
console.log(window.b) // undefined
console.log(window.c) // undefined

function test() &#123;
  console.log(a)
  let a
&#125;
test()
</code></pre>
<p>首先在全局作用域下使用 <code>let</code> 和 <code>const</code> 声明变量，变量并不会被挂载到 <code>window</code> 上，这一点就和 <code>var</code> 声明有了区别。</p>
<p>再者当我们在声明 <code>a</code> 之前如果使用了 <code>a</code> ，就会出现报错的情况。报错的原因是因为存在 <strong>暂时性死区</strong> ，我们不能在声明前就使用变量，这也是 <code>let</code> 和 <code>const</code> 优于 <code>var</code> 的一点。</p>
<p>总结一下：</p>
<ul>
<li>函数提升优先于变量提升，函数提升会把整个函数挪到作用域顶部，变量提升只会把声明挪到作用域顶部</li>
<li>var 存在提升，我们能在声明之前使用。let、const 因为暂时性死区的原因，不能在声明前使用</li>
<li>var 在全局作用域下声明变量会导致变量挂载在 window 上，其他两者不会</li>
<li>let 和 const 作用基本一致，但是后者声明的变量不能再次赋值</li>
</ul>
<h2 id="原型继承和-Class-继承"><a href="#原型继承和-Class-继承" class="headerlink" title="原型继承和 Class 继承"></a>原型继承和 Class 继承</h2><blockquote>
<p>原型如何实现继承？Class 如何实现继承？Class 本质是什么？</p>
</blockquote>
<p>首先先来讲下 <code>class</code> ，其实在 JS 中并不存在类， <code>class</code> 只是语法糖，本质还是函数。</p>
<pre><code class="js">class Person &#123;&#125;
Person instanceof Function // true
</code></pre>
<h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>组合继承是最常用的继承方式</p>
<pre><code class="js">function Parent(value) &#123;
  this.val = value
&#125;
Parent.prototype.getValue = function () &#123;
  console.log(this.val)
&#125;
function Child(value) &#123;
  Parent.call(this, value) // 继承属性
&#125;
Child.prototype = new Parent() // 继承函数

const child = new Child(1)

child.getValue() // 1
child instanceof Parent // true
</code></pre>
<p>以上继承的方式核心是在子类的构造函数中通过 <code>Parent.call(this)</code> 继承父类的属性，然后改变子类的原型为 <code>new Parent()</code> 来继承父类的函数。</p>
<p>这种继承方式优点在于构造函数可以传参，不会与父类引用属性共享，可以复用父类的函数，但是也存在一个缺点就是在继承父类函数的时候调用了父类构造函数，导致子类的原型上多了不需要的父类属性，存在内存上的浪费。</p>
<h3 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h3><p>这种继承方式对组合继承进行了优化，组合继承缺点在于继承父类函数时调用了构造函数，我们只需要优化掉这点就行了。</p>
<pre><code class="js">function Parent(value) &#123;
  this.val = value
&#125;
Parent.prototype.getValue = function () &#123;
  console.log(this.val)
&#125;

function Child(value) &#123;
  Parent.call(this, value)
&#125;
Child.prototype = Object.create(Parent.prototype, &#123;
  constructor: &#123;
    value: Child,
    enumerable: false,
    writable: true,
    configurable: true,
  &#125;,
&#125;)

const child = new Child(1)

child.getValue() // 1
child instanceof Parent // true
</code></pre>
<p>以上继承实现的核心就是将父类的原型赋值给了子类，并且将构造函数设置为子类，这样既解决了无用的父类属性问题，还能正确的找到子类的构造函数。</p>
<h2 id="Class-继承"><a href="#Class-继承" class="headerlink" title="Class 继承"></a>Class 继承</h2><p>以上两种继承方式都是通过原型去解决的，在 ES6 中，我们可以使用 <code>class</code> 去实现继承，并且实现起来很简单</p>
<pre><code class="js">class Parent &#123;
  constructor(value) &#123;
    this.val = value
  &#125;
  getValue() &#123;
    console.log(this.val)
  &#125;
&#125;
class Child extends Parent &#123;
  constructor(value) &#123;
    super(value)
    this.val = value
  &#125;
&#125;
let child = new Child(1)
child.getValue() // 1
child instanceof Parent // true
</code></pre>
<p><code>class</code> 实现继承的核心在于使用 <code>extends</code> 表明继承自哪个父类，并且在子类构造函数中必须调用 <code>super</code> ，因为这段代码可以看成 <code>Parent.call(this, value)</code>。</p>
<p>当然了，之前也说了在 JS 中并不存在类， <code>class</code> 的本质就是函数。</p>
<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><blockquote>
<p>为什么要使用模块化？都有哪几种方式可以实现模块化，各有什么特点？</p>
</blockquote>
<p>使用模块化可以给我们带来以下好处</p>
<ul>
<li>解决命名冲突</li>
<li>提供复用性</li>
<li>提高代码可维护性</li>
</ul>
<h3 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h3><p>在早期，使用立即执行函数实现模块化是常见的手段，通过函数作用域解决了命名冲突、污染全局作用域的问题</p>
<pre><code class="js">;(function (globalVariable) &#123;
  globalVariable.test = function () &#123;&#125;
  // ... 声明各种变量、函数都不会污染全局作用域
&#125;)(globalVariable)
</code></pre>
<h3 id="AMD-和-CMD"><a href="#AMD-和-CMD" class="headerlink" title="AMD 和 CMD"></a>AMD 和 CMD</h3><p>鉴于目前这两种实现方式已经很少见到，所以不再对具体特性细聊，只需要了解这两者是如何使用的。</p>
<pre><code class="js">// AMD
define([&#39;./a&#39;, &#39;./b&#39;], function (a, b) &#123;
  // 加载模块完毕可以使用
  a.do()
  b.do()
&#125;)
// CMD
define(function (require, exports, module) &#123;
  // 加载模块
  // 可以把 require 写在函数体的任意地方实现延迟加载
  var a = require(&#39;./a&#39;)
  a.doSomething()
&#125;)
</code></pre>
<h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><p>CommonJS 最早是 Node 在使用，目前也仍然广泛使用，比如在 Webpack 中你就能见到它，当然目前在 Node 中的模块管理已经和 CommonJS 有一些区别了。</p>
<pre><code class="js">// a.js
module.exports = &#123;
  a: 1,
&#125;
// or
exports.a = 1

// b.js
var module = require(&#39;./a.js&#39;)
module.a // -&gt; log 1
</code></pre>
<p>因为 CommonJS 还是会使用到的，所以这里会对一些疑难点进行解析</p>
<p>先说 <code>require</code> 吧</p>
<pre><code class="js">var module = require(&#39;./a.js&#39;)
module.a
// 这里其实就是包装了一层立即执行函数，这样就不会污染全局变量了，
// 重要的是 module 这里，module 是 Node 独有的一个变量
module.exports = &#123;
  a: 1,
&#125;
// module 基本实现
var module = &#123;
  id: &#39;xxxx&#39;, // 我总得知道怎么去找到他吧
  exports: &#123;&#125;, // exports 就是个空对象
&#125;
// 这个是为什么 exports 和 module.exports 用法相似的原因
var exports = module.exports
var load = function (module) &#123;
  // 导出的东西
  var a = 1
  module.exports = a
  return module.exports
&#125;
// 然后当我 require 的时候去找到独特的
// id，然后将要使用的东西用立即执行函数包装下，over
</code></pre>
<p>另外虽然 <code>exports</code> 和 <code>module.exports</code> 用法相似，但是不能对 <code>exports</code> 直接赋值。因为 <code>var exports = module.exports</code> 这句代码表明了 <code>exports</code> 和 <code>module.exports</code> 享有相同地址，通过改变对象的属性值会对两者都起效，但是如果直接对 <code>exports</code> 赋值就会导致两者不再指向同一个内存地址，修改并不会对 <code>module.exports</code> 起效。</p>
<h3 id="ES-Module"><a href="#ES-Module" class="headerlink" title="ES Module"></a>ES Module</h3><p>ES Module 是原生实现的模块化方案，与 CommonJS 有以下几个区别</p>
<ul>
<li><p>CommonJS 支持动态导入，也就是 <code>require($&#123;path&#125;/xx.js)</code>，后者目前不支持，但是已有提案</p>
</li>
<li><p>CommonJS 是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响</p>
</li>
<li><p>CommonJS 在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。但是 ES Module 采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化</p>
</li>
<li><p>ES Module 会编译成 require/exports 来执行的</p>
<pre><code class="js">// 引入模块 API
import XXX from &#39;./a.js&#39;
import &#123; XXX &#125; from &#39;./a.js&#39;
// 导出模块 API
export function a() &#123;&#125;
export default function() &#123;&#125;
```
</code></pre>
</li>
</ul>
<h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><blockquote>
<p>Proxy 可以实现什么功能？</p>
</blockquote>
<p>在 Vue3.0 中将会通过 <code>Proxy</code> 来替换原本的 <code>Object.defineProperty</code> 来实现数据响应式。 <code>Proxy</code> 是 ES6 中新增的功能，它可以用来自定义对象中的操作。</p>
<pre><code class="js">let p = new Proxy(target, handler)
</code></pre>
<p><code>target</code> 代表需要添加代理的对象， <code>handler</code> 用来自定义对象中的操作，比如可以用来自定义 <code>set</code> 或者 <code>get</code> 函数。</p>
<p>之所以 Vue3.0 要使用 <code>Proxy</code> 替换原本的 API 原因在于 <code>Proxy</code> 无需一层层递归为每个属性添加代理，一次即可完成以上操作，性能上更好，并且原本的实现有一些数据更新不能监听到，但是 <code>Proxy</code> 可以完美监听到任何方式的数据改变，唯一缺陷可能就是浏览器的兼容性不好了。</p>
<h2 id="map-filter-reduce"><a href="#map-filter-reduce" class="headerlink" title="map, filter, reduce"></a>map, filter, reduce</h2><blockquote>
<p>map, filter, reduce<br><code>map</code> 作用是生成一个新数组，遍历原数组，将每个元素拿出来做一些变换然后放入到新的数组中。</p>
</blockquote>
<p>另外 <code>map</code> 的回调函数接受三个参数，分别是<strong>当前索引元素</strong>，<strong>索引</strong>，<strong>原数组</strong></p>
<pre><code class="js">;[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;].map(parseInt)
</code></pre>
<ul>
<li>第一轮遍历 parseInt(‘1’, 0) -&gt; 1</li>
<li>第二轮遍历 parseInt(‘2’, 1) -&gt; NaN</li>
<li>第三轮遍历 parseInt(‘3’, 2) -&gt; NaN</li>
</ul>
<p><code>filter</code> 的作用也是生成一个新数组，在遍历数组的时候将返回值为 <code>true</code> 的元素放入新数组，我们可以利用这个函数删除一些不需要的元素</p>
<pre><code class="js">let array = [1, 2, 4, 6]
let newArray = array.filter(item =&gt; item !== 6)
console.log(newArray) // [1, 2, 4]
</code></pre>
<p>和 <code>map</code> 一样， <code>filter</code> 的回调函数也接受三个参数，用处也相同。</p>
<p>最后我们来讲解 <code>reduce</code> 这块的内容，同时也是最难理解的一块内容。 <code>reduce</code> 可以将数组中的元素通过回调函数最终转换为一个值。</p>
<p>如果我们想实现一个功能将函数里的元素全部相加得到一个值，可能会这样写代码</p>
<pre><code class="js">const arr = [1, 2, 3]
let total = 0
for (let i = 0; i &lt; arr.length; i++) &#123;
  total += arr[i]
&#125;
console.log(total) //6
</code></pre>
<p>但是如果我们使用 <code>reduce</code> 的话就可以将遍历部分的代码优化为一行代码</p>
<pre><code class="js">const arr = [1, 2, 3]
const sum = arr.reduce((acc, current) =&gt; acc + current, 0)
console.log(sum)
</code></pre>
<p>对于 <code>reduce</code> 来说，它接受两个参数，分别是回调函数和初始值，接下来我们来分解上述代码中 <code>reduce</code> 的过程</p>
<ul>
<li>首先初始值为 0，该值会在执行第一次回调函数时作为第一个参数传入</li>
<li>回调函数接受四个参数，分别为累计值、当前元素、当前索引、原数组，后三者想必大家都可以明白作用，这里着重分析第一个参数</li>
<li>在一次执行回调函数时，当前值和初始值相加得出结果 1，该结果会在第二次执行回调函数时当做第一个参数传入</li>
<li>所以在第二次执行回调函数时，相加的值就分别是 1 和 2，以此类推，循环结束后得到结果 6</li>
</ul>
<p>想必通过以上的解析大家应该明白 <code>reduce</code> 是如何通过回调函数将所有元素最终转换为一个值的，当然 <code>reduce</code> 还可以实现很多功能，接下来我们就通过 <code>reduce</code> 来实现 <code>map</code> 函数</p>
<pre><code class="js">const arr = [1, 2, 3]
const mapArray = arr.map(value =&gt; value * 2)
const reduceArray = arr.reduce((acc, current) =&gt; &#123;
  acc.push(current * 2)
  return acc
&#125;, [])
console.log(mapArray, reduceArray) // [2, 4, 6]
</code></pre>
<h2 id="回调函数（Callback）"><a href="#回调函数（Callback）" class="headerlink" title="回调函数（Callback）"></a>回调函数（Callback）</h2><blockquote>
<p>什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？</p>
</blockquote>
<p>回调函数应该是大家经常使用到的，以下代码就是一个回调函数的例子：</p>
<pre><code class="js">ajax(url, () =&gt; &#123;
  // 处理逻辑
&#125;)
</code></pre>
<p>但是回调函数有一个致命的弱点，就是容易写出回调地狱（Callback hell）。假设多个请求存在依赖性，你可能就会写出如下代码：</p>
<pre><code class="js">ajax(url, () =&gt; &#123;
  // 处理逻辑
  ajax(url1, () =&gt; &#123;
    // 处理逻辑
    ajax(url2, () =&gt; &#123;
      // 处理逻辑
    &#125;)
  &#125;)
&#125;)
</code></pre>
<p>回调地狱的根本问题就是：</p>
<ul>
<li>嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身</li>
<li>嵌套函数一多，就很难处理错误</li>
</ul>
<p>当然，回调函数还存在着别的几个缺点，比如不能使用 <code>try catch</code> 捕获错误，不能直接 <code>return</code> 。</p>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><blockquote>
<p>Promise 的特点是什么，分别有什么优缺点？什么是 Promise 链？Promise 构造函数执行和 then 函数执行有什么区别？</p>
</blockquote>
<p><code>Promise</code> 翻译过来就是承诺的意思，这个承诺会在未来有一个确切的答复，并且该承诺有三种状态，分别是：</p>
<ol>
<li>等待中（pending）</li>
<li>完成了（resolved）</li>
<li>拒绝了（rejected）<br>这个承诺一旦从等待状态变成为其他状态就永远不能更改状态了，也就是说一旦状态变为 resolved 后，就不能再次改变</li>
</ol>
<pre><code class="js">new Promise((resolve, reject) =&gt; &#123;
  resolve(&#39;success&#39;)
  // 无效
  reject(&#39;reject&#39;)
&#125;)
</code></pre>
<p>当我们在构造 <code>Promise</code> 的时候，构造函数内部的代码是立即执行的</p>
<pre><code class="js">new Promise((resolve, reject) =&gt; &#123;
  console.log(&#39;new Promise&#39;)
  resolve(&#39;success&#39;)
&#125;)
console.log(&#39;finifsh&#39;)
// new Promise -&gt; finifsh
</code></pre>
<p><code>Promise</code> 实现了链式调用，也就是说每次调用 <code>then</code> 之后返回的都是一个 <code>Promise</code> ，并且是一个全新的 <code>Promise</code> ，原因也是因为状态不可变。如果你在 <code>then</code> 中 使用了 <code>return</code> ，那么 <code>return</code> 的值会被 <code>Promise.resolve()</code> 包装</p>
<pre><code class="js">Promise.resolve(1)
  .then(res =&gt; &#123;
    console.log(res) // =&gt; 1
    return 2 // 包装成 Promise.resolve(2)
  &#125;)
  .then(res =&gt; &#123;
    console.log(res) // =&gt; 2
  &#125;)
</code></pre>
<p>当然了， <code>Promise</code> 也很好地解决了回调地狱的问题，可以把之前的回调地狱例子改写为如下代码：</p>
<pre><code class="js">ajax(url)
  .then(res =&gt; &#123;
    console.log(res)
    return ajax(url1)
  &#125;)
  .then(res =&gt; &#123;
    console.log(res)
    return ajax(url2)
  &#125;)
  .then(res =&gt; console.log(res))
</code></pre>
<p><code>Promise.all</code> 可以将多个 <code>Promise</code> 实例包装成一个新的 <code>Promise</code> 实例。同时，成功和失败的返回值是不同的，<strong>成功的时候返回的是一个结果数组，而失败的时候则返回最先被 <code>reject</code> 失败状态的值</strong>。</p>
<pre><code class="js">let p1 = new Promise((resolve, reject) =&gt; &#123;
  resolve(&#39;成功了&#39;)
&#125;)

let p2 = new Promise((resolve, reject) =&gt; &#123;
  resolve(&#39;success&#39;)
&#125;)

let p3 = Promise.reject(&#39;失败了&#39;)

let p4 = Promise.reject(&#39;fail&#39;)

Promise.all([p1, p2])
  .then(result =&gt; &#123;
    console.log(result) //[&#39;成功了&#39;, &#39;success&#39;]
  &#125;)
  .catch(error =&gt; &#123;
    console.log(error)
  &#125;)

Promise.all([p1, p3, p2, p4])
  .then(result =&gt; &#123;
    console.log(result)
  &#125;)
  .catch(error =&gt; &#123;
    console.log(error) // 失败了，打出 &#39;失败了&#39;
  &#125;)
</code></pre>
<p><code>Promse.all</code> 在处理多个异步处理时非常有用，比如说一个页面上需要等两个或多个 <code>ajax</code> 的数据回来以后才正常显示，在此之前只显示 <code>loading</code> 图标。</p>
<pre><code class="js">let wake = time =&gt; &#123;
  return new Promise((resolve, reject) =&gt; &#123;
    setTimeout(() =&gt; &#123;
      resolve(`$&#123;time / 1000&#125;秒后醒来`)
    &#125;, time)
  &#125;)
&#125;

let p1 = wake(3000)
let p2 = wake(2000)

Promise.all([p1, p2])
  .then(result =&gt; &#123;
    console.log(result) // [ &#39;3秒后醒来&#39;, &#39;2秒后醒来&#39; ]
  &#125;)
  .catch(error =&gt; &#123;
    console.log(error)
  &#125;)
</code></pre>
<p>需要特别注意的是， <code>Promise.all</code> 获得的成功结果的数组里面的数据顺序和 <code>Promise.all</code> 接收到的数组顺序是一致的，即 <code>p1</code> 的结果在前，即便 <code>p1</code> 的结果获取的比 <code>p2</code> 要晚。这带来了一个绝大的好处：在前端开发请求数据的过程中，偶尔会遇到发送多个请求并根据请求顺序获取和使用数据的场景，使用 <code>Promise.all</code> 毫无疑问可以解决这个问题。</p>
<p>前面都是在讲述 <code>Promise</code> 的一些优点和特点，其实它也是存在一些缺点的，比如无法取消 <code>Promise</code> ，错误需要通过回调函数捕获。</p>
<h2 id="async-及-await"><a href="#async-及-await" class="headerlink" title="async 及 await"></a>async 及 await</h2><blockquote>
<p>async 及 await 的特点，它们的优点和缺点分别是什么？await 原理是什么？</p>
</blockquote>
<p>一个函数如果加上 <code>async</code> ，那么该函数就会返回一个 <code>Promise</code></p>
<pre><code class="js">async function test() &#123;
  return &#39;1&#39;
&#125;
console.log(test()) // -&gt; Promise &#123;&lt;resolved&gt;: &quot;1&quot;&#125;
</code></pre>
<p><code>async</code> 就是将函数返回值使用 <code>Promise.resolve()</code> 包裹了下，和 <code>then</code> 中处理返回值一样，并且 <code>await</code> 只能配套 <code>async</code> 使用</p>
<pre><code class="js">async function test() &#123;
  let value = await sleep()
&#125;
</code></pre>
<p><code>async</code> 和 <code>await</code> 可以说是异步终极解决方案了，相比直接使用 <code>Promise</code> 来说，优势在于处理 <code>then</code> 的调用链，能够更清晰准确的写出代码，毕竟写一大堆 <code>then</code> 也很恶心，并且也能优雅地解决回调地狱问题。当然也存在一些缺点，因为 <code>await</code> 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 <code>await</code> 会导致性能上的降低。</p>
<pre><code class="js">async function test() &#123;
  // 以下代码没有依赖性的话，完全可以使用 Promise.all 的方式
  // 如果有依赖性的话，其实就是解决回调地狱的例子了
  await fetch(url)
  await fetch(url1)
  await fetch(url2)
&#125;
</code></pre>
<p>下面来看一个使用 <code>await</code> 的例子：</p>
<pre><code class="js">let a = 0
let b = async () =&gt; &#123;
  a = a + (await 10)
  console.log(&#39;2&#39;, a) // -&gt; &#39;2&#39; 10
&#125;
b()
a++
console.log(&#39;1&#39;, a) // -&gt; &#39;1&#39; 1
</code></pre>
<p>对于以上代码你可能会有疑惑，让我来解释下原因</p>
<p>首先函数 <code>b</code> 先执行，在执行到 <code>await 1</code>0 之前变量 <code>a</code> 还是 <code>0</code> ，因为 <code>await</code> 内部实现了 <code>generator</code> ， <code>generator</code> 会保留堆栈中东西，所以这时候 <code>a = 0</code> 被保存了下来<br>因为 <code>await</code> 是异步操作，后来的表达式不返回 <code>Promise</code> 的话，就会包装成 <code>Promise.reslove(返回值)</code> ，然后会去执行函数外的同步代码<br>同步代码执行完毕后开始执行异步代码，将保存下来的值拿出来使用，这时候 <code>a = 0 + 10</code></p>
<h2 id="常用定时器函数"><a href="#常用定时器函数" class="headerlink" title="常用定时器函数"></a>常用定时器函数</h2><blockquote>
<p>setTimeout、setInterval、requestAnimationFrame 各有什么特点？</p>
</blockquote>
<p>异步编程当然少不了定时器了，常见的定时器函数有 <code>setTimeout</code> 、 <code>setInterval</code> 、 <code>requestAnimationFrame</code> 。我们先来讲讲最常用的 <code>setTimeout</code> ，很多人认为 <code>setTimeout</code> 是延时多久，那就应该是多久后执行。</p>
<p>其实这个观点是错误的，因为 JS 是单线程执行的，如果前面的代码影响了性能，就会导致 <code>setTimeout</code> 不会按期执行。当然了，我们可以通过代码去修正 <code>setTimeout</code> ，从而使定时器相对准确</p>
<p>接下来我们来看 <code>setInterval</code> ，其实这个函数作用和 <code>setTimeout</code> 基本一致，只是该函数是每隔一段时间执行一次回调函数。</p>
<p>通常来说不建议使用 <code>setInterval</code> 。第一，它和 <code>setTimeout</code> 一样，不能保证在预期的时间执行任务。第二，它存在执行累积的问题，请看以下伪代码</p>
<pre><code class="js">function demo() &#123;
  setInterval(function () &#123;
    console.log(2)
  &#125;, 1000)
  sleep(2000)
&#125;
demo()
</code></pre>
<p>以上代码在浏览器环境中，如果定时器执行过程中出现了耗时操作，多个回调函数会在耗时操作结束以后同时执行，这样可能就会带来性能上的问题。</p>
<p>如果你有循环定时器的需求，其实完全可以通过 <code>requestAnimationFrame</code> 来实现</p>
<pre><code class="js">function setInterval(callback, interval) &#123;
  let timer
  const now = Date.now
  let startTime = now()
  let endTime = startTime
  const loop = () =&gt; &#123;
    timer = window.requestAnimationFrame(loop)
    endTime = now()
    if (endTime - startTime &gt;= interval) &#123;
      startTime = endTime = now()
      callback(timer)
    &#125;
  &#125;
  timer = window.requestAnimationFrame(loop)
  return timer
&#125;

let a = 0
setInterval(timer =&gt; &#123;
  console.log(1)
  a++
  if (a === 3) cancelAnimationFrame(timer)
&#125;, 1000)
</code></pre>
<p>首先 <code>requestAnimationFrame</code> 自带函数节流功能，基本可以保证在 16.6 毫秒内只执行一次（不掉帧的情况下），并且该函数的延时效果是精确的，没有其他定时器时间不准的问题，当然你也可以通过该函数来实现 <code>setTimeout</code> 。</p>
<h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><blockquote>
<p>new 的原理是什么？通过 new 的方式创建对象和通过字面量创建有什么区别？</p>
</blockquote>
<p>在调用 <code>new</code> 的过程中会发生以上四件事情：</p>
<ol>
<li>创建一个新对象：</li>
</ol>
<p><code>var obj = &#123;&#125;;</code></p>
<ol start="2">
<li>设置新对象的 constructor 属性为构造函数的名称，设置新对象的<strong>proto</strong>属性指向构造函数的 prototype 对象；</li>
</ol>
<p><code>obj.__proto__ = ClassA.prototype;</code></p>
<ol start="3">
<li>使用新对象调用函数，函数中的 this 被指向新实例对象：</li>
</ol>
<p><code>ClassA.call(obj); //&#123;&#125;.构造函数()</code></p>
<ol start="4">
<li>将初始化完毕的新对象地址，保存到等号左边的变量中</li>
</ol>
<blockquote>
<p>注意：若构造函数中返回 this 或返回值是基本类型（number、string、boolean、null、undefined）的值，则返回新实例对象；若返回值是引用类型的值，则实际返回值为这个引用类型。</p>
</blockquote>
<p>对于对象来说，其实都是通过 <code>new</code> 产生的，无论是 <code>function Foo()</code> 还是 <code>let a = &#123; b : 1 &#125;</code> 。</p>
<p>对于创建一个对象来说，更推荐使用字面量的方式创建对象（无论性能上还是可读性）。因为你使用 <code>new Object()</code> 的方式创建对象需要通过作用域链一层层找到 <code>Object</code> ，但是你使用字面量的方式就没这个问题。</p>
<pre><code class="js">function Foo() &#123;&#125;
// function 就是个语法糖
// 内部等同于 new Function()
let a = &#123; b: 1 &#125;
// 这个字面量内部也是使用了 new Object()
</code></pre>
<h2 id="instanceof-的原理"><a href="#instanceof-的原理" class="headerlink" title="instanceof 的原理"></a>instanceof 的原理</h2><p><code>instanceof</code> 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 <code>prototype</code> 。</p>
<h2 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h2><blockquote>
<p>事件的触发过程是怎么样的？知道什么是事件代理吗？</p>
</blockquote>
<h3 id="事件触发三阶段"><a href="#事件触发三阶段" class="headerlink" title="事件触发三阶段"></a>事件触发三阶段</h3><p>事件触发有三个阶段：</p>
<ol>
<li>window 往事件触发处传播，遇到注册的捕获事件会触发</li>
<li>传播到事件触发处时触发注册的事件</li>
<li>从事件触发处往 window 传播，遇到注册的冒泡事件会触发</li>
</ol>
<p>事件触发一般来说会按照上面的顺序进行，但是也有特例，如果给一个 <code>body</code> 中的子节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。</p>
<pre><code class="js">// 以下会先打印冒泡然后是捕获
node.addEventListener(
  &#39;click&#39;,
  event =&gt; &#123;
    console.log(&#39;冒泡&#39;)
  &#125;,
  false
)
node.addEventListener(
  &#39;click&#39;,
  event =&gt; &#123;
    console.log(&#39;捕获 &#39;)
  &#125;,
  true
)
</code></pre>
<h3 id="注册事件"><a href="#注册事件" class="headerlink" title="注册事件"></a>注册事件</h3><p>通常我们使用 <code>addEventListener</code> 注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 <code>useCapture</code> 参数来说，该参数默认值为 <code>false</code> <code>，useCapture</code> 决定了注册的事件是捕获事件还是冒泡事件。对于对象参数来说，可以使用以下几个属性</p>
<ul>
<li><code>capture</code> ：布尔值，和 <code>useCapture</code> 作用一样</li>
<li><code>once</code> ：布尔值，值为 <code>true</code> 表示该回调只会调用一次，调用后会移除监听</li>
<li><code>passive</code> ：布尔值，表示永远不会调用 <code>preventDefault</code></li>
</ul>
<p>一般来说，如果我们只希望事件只触发在目标上，这时候可以使用 <code>stopPropagation</code> 来阻止事件的进一步传播。通常我们认为 <code>stopPropagation</code> 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。 <code>stopImmediatePropagation</code> 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件。</p>
<pre><code class="js">node.addEventListener(
  &#39;click&#39;,
  event =&gt; &#123;
    event.stopImmediatePropagation()
    console.log(&#39;冒泡&#39;)
  &#125;,
  false
)
// 点击 node 只会执行上面的函数，该函数不会执行
node.addEventListener(
  &#39;click&#39;,
  event =&gt; &#123;
    console.log(&#39;捕获 &#39;)
  &#125;,
  true
)
</code></pre>
<h3 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h3><p>如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上</p>
<pre><code class="html">&lt;ul id=&quot;ul&quot;&gt;
  &lt;li&gt;1&lt;/li&gt;
  &lt;li&gt;2&lt;/li&gt;
  &lt;li&gt;3&lt;/li&gt;
  &lt;li&gt;4&lt;/li&gt;
  &lt;li&gt;5&lt;/li&gt;
&lt;/ul&gt;
&lt;script&gt;
  let ul = document.querySelector(&#39;#ul&#39;)
  ul.addEventListener(&#39;click&#39;, event =&gt; &#123;
    console.log(event.target)
  &#125;)
&lt;/script&gt;
</code></pre>
<p>事件代理的方式相较于直接给目标注册事件来说，有以下优点：</p>
<ul>
<li>节省内存</li>
<li>不需要给子节点注销事件</li>
</ul>
<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><blockquote>
<p>什么是跨域？为什么浏览器要使用同源策略？你有几种方式可以解决跨域问题？了解预检请求嘛？</p>
</blockquote>
<p>因为浏览器出于安全考虑，有<strong>同源策略</strong>。也就是说，如果协议、域名或者端口有一个不同就是跨域，Ajax 请求会失败。</p>
<p><strong>那么是出于什么安全考虑才会引入这种机制呢？</strong> 其实主要是用来防止 CSRF 攻击的。简单点说，CSRF 攻击是利用用户的登录态发起恶意请求。</p>
<p><strong>然后我们来考虑一个问题，请求跨域了，那么请求到底发出去没有？</strong> 请求必然是发出去了，但是浏览器 <strong>拦截了响应</strong> 。你可能会疑问明明通过表单的方式可以发起跨域请求，为什么 Ajax 就不会。因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，<strong>浏览器认为这不安全，所以拦截了响应</strong>。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了。</p>
<h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>JSONP 的原理很简单，就是利用 <code>&lt;script&gt;</code> 标签没有跨域限制的漏洞。通过 <code>&lt;script&gt;</code> 标签指向一个需要访问的地址并提供一个回调函数来接收数据。</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;GoJSONP&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
      // 定义回调函数
      function jsonhandle(data) &#123;
        alert(&#39;age:&#39; + data.age + &#39;name:&#39; + data.name)
      &#125;
    &lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;jquery-1.8.3.min.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;http://www.practice-zhao.com/remote.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>这里调用了跨域的 remote.js 脚本，remote.js 代码如下：</p>
<pre><code class="javascript">jsonhandle(&#123;
  age: 15,
  name: &#39;John&#39;,
&#125;)
</code></pre>
<p><strong>这段远程的 js 代码执行了上面定义的函数，弹出了提示框</strong></p>
<p><strong>JSONP 只能执行 <code>get</code> 方法，因为 script 引用的资源请求方式只能是 <code>get</code> 方法</strong></p>
<p>在开发中可能会遇到多个 <code>JSONP</code> 请求的回调函数名是相同的，这时候就需要自己封装一个 <code>JSONP</code> ，以下是简单实现</p>
<pre><code class="js">function jsonp(url, jsonpCallback, success) &#123;
  let script = document.createElement(&#39;script&#39;)
  script.src = url
  script.async = true
  script.type = &#39;text/javascript&#39;
  window[jsonpCallback] = function (data) &#123;
    success &amp;&amp; success(data)
  &#125;
  document.body.appendChild(script)
&#125;
jsonp(&#39;http://xxx&#39;, &#39;callback&#39;, function (value) &#123;
  console.log(value)
&#125;)
</code></pre>
<h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p><code>CORS</code> 需要浏览器和后端同时支持。IE 8 和 9 需要通过 <code>XDomainRequest</code> 来实现。</p>
<p>浏览器会自动进行 <code>CORS</code> 通信，实现 <code>CORS</code> 通信的关键是后端。只要后端实现了 <code>CORS</code> ，就实现了跨域。</p>
<p>服务端设置 <code>Access-Control-Allow-Origin</code> 就可以开启 <code>CORS</code> 。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。</p>
<h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><blockquote>
<p>有几种方式可以实现存储功能，分别有什么优缺点？</p>
</blockquote>
<h3 id="cookie，localStorage，sessionStorage，indexDB"><a href="#cookie，localStorage，sessionStorage，indexDB" class="headerlink" title="cookie，localStorage，sessionStorage，indexDB"></a>cookie，localStorage，sessionStorage，indexDB</h3><p><img src="https://cdn.jsdelivr.net/gh/chivesssss/picture-store@master/uPic/browse-storage.png" alt="浏览器存储"></p>
<p>从上表可以看到， <code>cookie</code> 已经不建议用于存储。如果没有大量数据存储需求的话，可以使用 <code>localStorage</code> 和 <code>sessionStorage</code> 。对于不怎么改变的数据尽量使用 <code>localStorage</code> 存储，否则可以用 <code>sessionStorage</code> 存储。</p>
<h2 id="创建-Ajax-的过程"><a href="#创建-Ajax-的过程" class="headerlink" title="创建 Ajax 的过程"></a>创建 Ajax 的过程</h2><ol>
<li>创建 XMLHttpRequest 对象，也就是创建一个异步调用对象</li>
<li>创建一个新的 HTTP 请求，并指定改 HTTP 请求的方法、URL 以及验证信息</li>
<li>设置响应 HTTP 状态变化的函数</li>
<li>发送 HTTP 请求</li>
<li>获取异步调用返回的数据</li>
<li>使用 javascript 和 DOM 实现局部刷新</li>
</ol>
<pre><code class="html">&lt;html&gt;
  &lt;head&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
    &lt;title&gt;AJAX实例&lt;/title&gt;
    &lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt;
      var xmlHttpRequest //定义一个变量用于存放XMLHttpRequest对象
      //定义一个用于创建XMLHttpRequest对象的函数
      function createXMLHttpRequest() &#123;
        if (window.ActiveXObject) &#123;
          //IE浏览器的创建方式
          xmlHttpRequest = new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;)
        &#125; else if (window.XMLHttpRequest) &#123;
          //Netscape浏览器中的创建方式
          xmlHttpRequest = new XMLHttpRequest()
        &#125;
      &#125;

      //响应HTTP请求状态变化的函数
      function httpStateChange() &#123;
        //判断异步调用是否完成
        if (xmlHttpRequest.readyState == 4) &#123;
          //判断异步调用是否成功,如果成功开始局部更新数据
          if (xmlHttpRequest.status == 200 || xmlHttpRequest.status == 0) &#123;
            //查找节点
            var node = document.getElementById(&#39;myDIv&#39;) //更新数据
            node.firstChild.nodeValue = xmlHttpRequest.responseText
          &#125; else &#123;
            //如果异步调用未成功,弹出警告框,并显示出错信息
            alert(
              &#39;异步调用出错/n返回的HTTP状态码为:&#39; +
                xmlHttpRequest.status +
                &#39;/n返回的HTTP状态信息为:&#39; +
                xmlHttpRequest.statusText
            )
          &#125;
        &#125;
      &#125;
      //异步调用服务器段数据
      function getData(name, value) &#123;
        //创建XMLHttpRequest对象
        createXMLHttpRequest()
        if (xmlHttpRequest != null) &#123;
          //创建HTTP请求
          xmlHttpRequest.open(&#39;get&#39;, &#39;ajax.text&#39;, true)
          //设置HTTP请求状态变化的函数
          xmlHttpRequest.onreadystatechange = httpStateChange
          //发送请求
          xmlHttpRequest.send(null)
        &#125;
      &#125;
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;myDiv&quot;&gt;原数据&lt;/div&gt;

    &lt;input type=&quot;button&quot; value=&quot;更新数据&quot; onclick=&quot;getData()&quot; /&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="输入-URL-到页面渲染的整个流程"><a href="#输入-URL-到页面渲染的整个流程" class="headerlink" title="输入 URL 到页面渲染的整个流程"></a>输入 URL 到页面渲染的整个流程</h2><ol>
<li>浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理;</li>
<li>调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法;</li>
<li>通过 DNS 解析获取网址的 IP 地址，设置 UA 等信息发出第二个 GET 请求;</li>
<li>进行 HTTP 协议会话，客户端发送报头(请求报头);</li>
<li>进入到 web 服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器;</li>
<li>进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理;</li>
<li>处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回 304;</li>
<li>浏览器开始下载 html 文档(响应报头，状态码 200)，同时使用缓存;</li>
<li>文档树建立，根据标记请求所需指定 MIME 类型的文件（比如 css、js）,同时设置了 cookie;</li>
<li>页面开始渲染 DOM，JS 根据 DOM API 操作 DOM,执行事件绑定等，页面显示完成。</li>
</ol>
<h2 id="JS-中的作用域、作用域链"><a href="#JS-中的作用域、作用域链" class="headerlink" title="JS 中的作用域、作用域链"></a>JS 中的作用域、作用域链</h2><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>作用域是指程序源代码中定义变量的区域。</p>
<p>作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。</p>
<p>JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。</p>
<h3 id="静态作用域与动态作用域"><a href="#静态作用域与动态作用域" class="headerlink" title="静态作用域与动态作用域"></a>静态作用域与动态作用域</h3><p>因为 JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了。</p>
<p>而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。</p>
<p>让我们认真看个例子就能明白之间的区别：</p>
<pre><code class="js">var value = 1

function foo() &#123;
  console.log(value)
&#125;

function bar() &#123;
  var value = 2
  foo()
&#125;

bar()

// 结果是 1
</code></pre>
<p>JavaScript 采用静态作用域，让我们分析下执行过程：</p>
<p>执行 <code>foo</code> 函数，先从 <code>foo</code> 函数内部查找是否有局部变量 <code>value</code> ，如果没有，就根据书写的位置，查找上面一层的代码，也就是 <code>value</code> 等于 <code>1</code> ，所以结果会打印 <code>1</code> 。</p>
<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节。当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找，直至全局函数，这种组织形式就是作用域链。</p>
<h2 id="Session-与-Cookie-的区别"><a href="#Session-与-Cookie-的区别" class="headerlink" title="Session 与 Cookie 的区别"></a>Session 与 Cookie 的区别</h2><p><img src="https://cdn.jsdelivr.net/gh/chivesssss/picture-store@master/uPic/cookie-session.png" alt="Cookie及Session的区别"></p>
<h2 id="http-状态码"><a href="#http-状态码" class="headerlink" title="http 状态码"></a>http 状态码</h2><ul>
<li>100 Continue 继续，一般在发送 post 请求时，已发送了 http header 之后服务端将返回此信息，表示确认，之后发送具体参数信息</li>
<li>200 OK 正常返回信息</li>
<li>201 Created 请求成功并且服务器创建了新的资源</li>
<li>202 Accepted 服务器已接受请求，但尚未处理</li>
<li>301 Moved Permanently 请求的网页已永久移动到新位置。</li>
<li>302 Found 临时性重定向。</li>
<li>303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。</li>
<li>304 Not Modified 自从上次请求后，请求的网页未修改过。</li>
<li>400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。</li>
<li>401 Unauthorized 请求未授权。</li>
<li>403 Forbidden 禁止访问。</li>
<li>404 Not Found 找不到如何与 URI 相匹配的资源。</li>
<li>500 Internal Server Error 最常见的服务器端错误。</li>
<li>502 - 网关错误</li>
<li>503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。</li>
</ul>
<h2 id="常见的浏览器内核"><a href="#常见的浏览器内核" class="headerlink" title="常见的浏览器内核"></a>常见的浏览器内核</h2><ul>
<li>Trident 内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。（又称 MSHTML）</li>
<li>Gecko 内核：Netscape6 及以上版本，FF,MozillaSuite/SeaMonkey 等</li>
<li>Presto 内核：Opera7 及以上。（Opera 内核原为：Presto，现为：Blink;）</li>
<li>Webkit 内核：Safari,Chrome 等。（Chrome 的：Blink（WebKit 的分支））</li>
</ul>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><ul>
<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>
<li>针对所有的元素重复以上的步骤，除了最后一个；</li>
<li>重复步骤 1~3，直到排序完成。</li>
</ul>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><ul>
<li>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li>
<li>从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾</li>
<li>以此类推，直到所有元素均排序完毕。</li>
</ul>
<pre><code class="javascript">function selectionSort(arr) &#123;
  var len = arr.length
  var minIndex, temp
  console.time(&#39;选择排序耗时&#39;)
  for (var i = 0; i &lt; len - 1; i++) &#123;
    minIndex = i
    for (var j = i + 1; j &lt; len; j++) &#123;
      if (arr[j] &lt; arr[minIndex]) &#123;
        //寻找最小的数
        minIndex = j //将最小数的索引保存
      &#125;
    &#125;
    temp = arr[i]
    arr[i] = arr[minIndex]
    arr[minIndex] = temp
  &#125;
  console.timeEnd(&#39;选择排序耗时&#39;)
  return arr
&#125;
var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48]
console.log(selectionSort(arr)) //[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]
</code></pre>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><ul>
<li>从第一个元素开始，该元素可以认为已经被排序；</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>
<li>重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>将新元素插入到该位置后；</li>
<li>重复步骤 2~5。</li>
</ul>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><ul>
<li>从数列中挑出一个元素，称为 “基准”（pivot）；</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ul>
<h2 id="移动端-viewport"><a href="#移动端-viewport" class="headerlink" title="移动端 viewport"></a>移动端 viewport</h2><pre><code class="javascript">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;&gt;
</code></pre>
<h2 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h2><pre><code class="javascript">@media (max-width: 767px) &#123; ...css代码... &#125;
@media (min-width: 768px) and (max-width: 991px) &#123; ...css代码... &#125;
@media (min-width: 992px) and (max-width: 1199px) &#123; ...css代码... &#125;
@media (min-width: 1200px) &#123; ...css代码... &#125;
</code></pre>
<blockquote>
<p>vw —— 视口宽度的 1/100；vh —— 视口高度的 1/100</p>
</blockquote>
<h2 id="多行省略"><a href="#多行省略" class="headerlink" title="多行省略"></a>多行省略</h2><pre><code class="css">&lt;style&gt;
div
&#123;
    width:400px;
    margin:0 auto;
    overflow : hidden;
    border:1px solid #ccc;
    text-overflow: ellipsis;
    padding:0 10px;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    line-height:30px;
    height:60px;
&#125;
&lt;/style&gt;
</code></pre>
<h2 id="CSS3-新特性"><a href="#CSS3-新特性" class="headerlink" title="CSS3 新特性"></a>CSS3 新特性</h2><ul>
<li><p>transition</p>
</li>
<li><p>transform</p>
</li>
<li><p>border-radius</p>
</li>
<li><p>box-shaow</p>
</li>
<li><p>animation</p>
</li>
<li><p>flex</p>
</li>
<li><p>box-sizing</p>
<p>box-sizing:border-box 的时候，边框和 padding 包含在元素的宽高之内；<br>box-sizing:content-box 的时候，边框和 padding 不包含在元素的宽高之内</p>
</li>
</ul>
<h2 id="不定宽高的-DIV-如何垂直水平居中"><a href="#不定宽高的-DIV-如何垂直水平居中" class="headerlink" title="不定宽高的 DIV 如何垂直水平居中"></a>不定宽高的 DIV 如何垂直水平居中</h2><ul>
<li><p>使用 Flex</p>
<p>只需要在父盒子设置：display: flex; justify-content: center;align-items: center;</p>
</li>
<li><p>使用 CSS3 transform</p>
<p>父盒子设置:display:relative<br>Div 设置: transform: translate(-50%，-50%);position: absolute;top: 50%;left: 50%;</p>
</li>
<li><p>使用 display:table-cell 方法</p>
<p>父盒子设置:display:table-cell; text-align:center;vertical-align:middle;<br>Div 设置: display:inline-block;vertical-align:middle;</p>
</li>
</ul>
<h2 id="对于-MVVM-的理解"><a href="#对于-MVVM-的理解" class="headerlink" title="对于 MVVM 的理解"></a>对于 MVVM 的理解</h2><blockquote>
<p>MVVM 是 Model-View-ViewModel 的缩写。<br>Model 代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑。<br>View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来。<br>ViewModel 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步 View 和 Model 的对象，连接 Model 和 View。<br>在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互是双向的， 因此 View 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上。<br>ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</p>
</blockquote>
<h2 id="Vue-实现数据双向绑定的原理：Object-defineProperty（）"><a href="#Vue-实现数据双向绑定的原理：Object-defineProperty（）" class="headerlink" title="Vue 实现数据双向绑定的原理：Object.defineProperty（）"></a>Vue 实现数据双向绑定的原理：Object.defineProperty（）</h2><blockquote>
<p>vue 实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty（）来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。</p>
<p>vue 的数据双向绑定 将 MVVM 作为数据绑定的入口，整合 Observer，Compile 和 Watcher 三者，通过 Observer 来监听自己的 model 的数据变化，通过 Compile 来解析编译模板指令（vue 中是用来解析 <code>&#123;&#123;&#125;&#125;</code>），最终利用 watcher 搭起 observer 和 Compile 之间的通信桥梁，达到数据变化 —&gt;视图更新；视图交互变化（input）—&gt;数据 model 变更双向绑定效果。</p>
<p>不能检测到增加或删除的属性。</p>
<p>数组方面的变动，如根据索引改变元素，以及直接改变数组长度时的变化，不能被检测到。</p>
</blockquote>
<h2 id="JavaScript-实现简单的双向绑定"><a href="#JavaScript-实现简单的双向绑定" class="headerlink" title="JavaScript 实现简单的双向绑定"></a>JavaScript 实现简单的双向绑定</h2><pre><code class="html">&lt;body&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;input type=&quot;text&quot; id=&quot;txt&quot; /&gt;
    &lt;p id=&quot;show&quot;&gt;&lt;/p&gt;
  &lt;/div&gt;
&lt;/body&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  var obj = &#123;&#125;
  Object.defineProperty(obj, &#39;txt&#39;, &#123;
    get: function () &#123;
      return obj
    &#125;,
    set: function (newValue) &#123;
      document.getElementById(&#39;txt&#39;).value = newValue
      document.getElementById(&#39;show&#39;).innerHTML = newValue
    &#125;,
  &#125;)
  document.addEventListener(&#39;keyup&#39;, function (e) &#123;
    obj.txt = e.target.value
  &#125;)
&lt;/script&gt;
</code></pre>
<h2 id="生命周期钩子函数"><a href="#生命周期钩子函数" class="headerlink" title="生命周期钩子函数"></a>生命周期钩子函数</h2><p>在 <code>beforeCreate</code> 钩子函数调用的时候，是获取不到 <code>props</code> 或者 <code>data</code> 中的数据的，因为这些数据的初始化都在 <code>initState</code> 中。</p>
<p>然后会执行 <code>created</code> 钩子函数，在这一步的时候已经可以访问到之前不能访问到的数据，但是这时候组件还没被挂载，所以是看不到的。</p>
<p>接下来会先执行 <code>beforeMount</code> 钩子函数，开始创建 <code>VDOM</code> ，最后执行 <code>mounted</code> 钩子，并将 <code>VDOM</code> 渲染为真实 <code>DOM</code> 并且渲染数据。组件中如果有子组件的话，会递归挂载子组件，只有当所有子组件全部挂载完毕，才会执行根组件的挂载钩子。</p>
<p>接下来是数据更新时会调用的钩子函数 <code>beforeUpdate</code> 和 <code>updated</code> ，这两个钩子函数没什么好说的，就是分别在 <strong>数据更新前和更新后会调用</strong> 。</p>
<p>另外还有 <code>keep-alive</code> 独有的生命周期，分别为 <code>activated</code> 和 <code>deactivated</code> 。用 <code>keep-alive</code> 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 <code>deactivated</code> 钩子函数，命中缓存渲染后会执行 <code>actived</code> 钩子函数。</p>
<p>最后就是销毁组件的钩子函数 <code>beforeDestroy</code> 和 <code>destroyed</code> 。前者适合移除事件、定时器等等，否则可能会引起内存泄露的问题。然后进行一系列的销毁操作，如果有子组件的话，也会递归销毁子组件，所有子组件都销毁完毕后才会执行根组件的 <code>destroyed</code> 钩子函数。</p>
<h2 id="computed-和-watch-区别"><a href="#computed-和-watch-区别" class="headerlink" title="computed 和 watch 区别"></a>computed 和 watch 区别</h2><p><code>computed</code> 是计算属性，依赖其他属性计算值，并且 <code>computed</code> 的值有缓存，只有当计算值变化才会返回内容。</p>
<p><code>watch</code> 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。</p>
<p>所以一般来说需要依赖别的属性来动态获得值的时候可以使用 <code>computed</code> ，对于监听到值的变化需要做一些复杂业务逻辑的情况可以使用 <code>watch</code> 。</p>
<p>另外 <code>computed</code> 和 <code>watch</code> 还都支持对象的写法。</p>
<pre><code class="js">vm.$watch(&#39;obj&#39;, &#123;
  // 深度遍历
  deep: true,
  // 立即触发
  immediate: true,
  // 执行的函数
  handler: function (val, oldVal) &#123;&#125;,
&#125;)
var vm = new Vue(&#123;
  data: &#123; a: 1 &#125;,
  computed: &#123;
    aPlus: &#123;
      // this.aPlus 时触发
      get: function () &#123;
        return this.a + 1
      &#125;,
      // this.aPlus = 1 时触发
      set: function (v) &#123;
        this.a = v - 1
      &#125;,
    &#125;,
  &#125;,
&#125;)
</code></pre>
<h2 id="keep-alive-组件有什么作用"><a href="#keep-alive-组件有什么作用" class="headerlink" title="keep-alive 组件有什么作用"></a>keep-alive 组件有什么作用</h2><p>如果你需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 <code>keep-alive</code> 组件包裹需要保存的组件。</p>
<p>对于 <code>keep-alive</code> 组件来说，它拥有两个独有的生命周期钩子函数，分别为 <code>activated</code> 和 <code>deactivated</code> 。用 <code>keep-alive</code> 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 <code>deactivated</code> 钩子函数，命中缓存渲染后会执行 <code>actived</code> 钩子函数。</p>
<h2 id="v-show-与-v-if-区别"><a href="#v-show-与-v-if-区别" class="headerlink" title="v-show 与 v-if 区别"></a>v-show 与 v-if 区别</h2><p><code>v-show</code> 只是在 <code>display: none</code> 和 <code>display: block</code> 之间切换。无论初始条件是什么都会被渲染出来，后面只需要切换 CSS，DOM 还是一直保留着的。所以总的来说 <code>v-show</code> 在初始渲染时有更高的开销，但是切换开销很小，更适合于频繁切换的场景。</p>
<p><code>v-if</code> 的话就得说到 Vue 底层的编译了。当属性初始为 <code>false</code> 时，组件就不会被渲染，直到条件为 <code>true</code> ，并且切换条件时会触发销毁/挂载组件，所以总的来说在切换时开销更高，更适合不经常切换的场景。</p>
<p>并且基于 <code>v-if</code> 的这种惰性渲染机制，可以在必要的时候才去渲染组件，减少整个页面的初始渲染开销。</p>
<h2 id="Vue-的路由实现：hash-模式-和-history-模式"><a href="#Vue-的路由实现：hash-模式-和-history-模式" class="headerlink" title="Vue 的路由实现：hash 模式 和 history 模式"></a>Vue 的路由实现：hash 模式 和 history 模式</h2><p>hash 模式：在浏览器中符号“#”，#以及#后面的字符称之为 hash，用 window.location.hash 读取；<br>特点：hash 虽然在 URL 中，但不被包括在 HTTP 请求中；用来指导浏览器动作，对服务端安全无用，hash 不会重加载页面。<br>hash 模式下，仅 hash 符号之前的内容会被包含在请求中，如 <a href="http://www.xxx.com,因此对于后端来说,即使没有做到对路由的全覆盖,也不会返回/">http://www.xxx.com，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回</a> 404 错误。</p>
<p>history 模式：history 采用 HTML5 的新特性；且提供了两个新方法：pushState（），replaceState（）可以对浏览器历史记录栈进行修改，以及 popState 事件的监听到状态变更。<br>history 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致，如 <a href="http://www.xxx.com/items/id%E3%80%82%E5%90%8E%E7%AB%AF%E5%A6%82%E6%9E%9C%E7%BC%BA%E5%B0%91%E5%AF%B9">http://www.xxx.com/items/id。后端如果缺少对</a> /items/id 的路由处理，将返回 404 错误。Vue-Router 官网里如此描述：“不过这种模式要玩好，还需要后台配置支持……所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。”</p>
<h2 id="route-和-router的区别"><a href="#route-和-router的区别" class="headerlink" title="$route 和 $router的区别"></a><code>$route</code> 和 <code>$router</code>的区别</h2><p>$route是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数。而$router 是“路由实例”对象包括了路由的跳转方法，钩子函数等。</p>
<h2 id="vue-常用的修饰符"><a href="#vue-常用的修饰符" class="headerlink" title="vue 常用的修饰符"></a>vue 常用的修饰符</h2><p>.prevent: 阻止默认行为；.stop: 阻止单击事件冒泡；.self: 当事件发生在该元素本身而不是子元素的时候会触发；.capture: 事件侦听，事件发生的时候会调用</p>
<h2 id="vue-中-key-值的作用"><a href="#vue-中-key-值的作用" class="headerlink" title="vue 中 key 值的作用"></a>vue 中 key 值的作用</h2><p>当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。key 的作用主要是为了高效的更新虚拟 DOM。</p>
<h2 id="什么是-vue-的计算属性"><a href="#什么是-vue-的计算属性" class="headerlink" title="什么是 vue 的计算属性"></a>什么是 vue 的计算属性</h2><p>在模板中放入太多的逻辑会让模板过重且难以维护，在需要对数据进行复杂处理，且可能多次使用的情况下，尽量采取计算属性的方式。好处：① 使得数据处理结构清晰；② 依赖于数据，数据更新，处理结果自动更新；③ 计算属性内部 this 指向 vm 实例；④ 在 template 调用时，直接写计算属性名即可；⑤ 常用的是 getter 方法，获取数据，也可以使用 set 方法改变数据；⑥ 相较于 methods，不管依赖的数据变不变，methods 都会重新计算，但是依赖数据不变的时候 computed 从缓存中获取，不会重新计算。</p>
<h2 id="Vue-组件-data-为什么必须是函数"><a href="#Vue-组件-data-为什么必须是函数" class="headerlink" title="Vue 组件 data 为什么必须是函数"></a>Vue 组件 data 为什么必须是函数</h2><ul>
<li>每个组件都是 Vue 的实例。</li>
<li>组件共享 data 属性，当 data 的值是同一个引用类型的值时，改变其中一个会影响其他。</li>
</ul>
<h3 id="组件中-data-什么时候可以使用对象"><a href="#组件中-data-什么时候可以使用对象" class="headerlink" title="组件中 data 什么时候可以使用对象"></a>组件中 data 什么时候可以使用对象</h3><p>组件复用时所有组件实例都会共享 <code>data</code> ，如果 <code>data</code> 是对象的话，就会造成一个组件修改 <code>data</code> 以后会影响到其他所有组件，所以需要将 <code>data</code> 写成函数，每次用到就调用一次函数获得新的数据。</p>
<p>当我们使用 <code>new Vue()</code> 的方式的时候，无论我们将 <code>data</code> 设置为对象还是函数都是可以的，因为 <code>new Vue()</code> 的方式是生成一个根组件，该组件不会复用，也就不存在共享 <code>data</code> 的情况了。</p>
<h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><ul>
<li>支持双向通信，实时性更强；</li>
<li>可以发送文本，也可以二进制文件；</li>
<li>协议标识符是 ws，加密后是 wss ；</li>
<li>较少的控制开销。连接创建后，ws 客户端、服务端进行数据交换时，协议控制的数据包头部较小。在不包含头部的情况下，服务端到客户端的包头只有 2~10 字节（取决于数据包长度），客户端到服务端的的话，需要加上额外的 4 字节的掩码。而 HTTP 协议每次通信都需要携带完整的头部；</li>
<li>支持扩展。ws 协议定义了扩展，用户可以扩展协议，或者实现自定义的子协议。（比如支持自定义压缩算法等）<br>无跨域问题。</li>
<li>实现比较简单，服务端库如 socket.io、ws ，可以很好的帮助我们入门。而客户端也只需要参照 api 实现即可。</li>
</ul>
<h2 id="vue-router-有哪几种导航钩子？"><a href="#vue-router-有哪几种导航钩子？" class="headerlink" title="vue-router 有哪几种导航钩子？"></a>vue-router 有哪几种导航钩子？</h2><p>三种。</p>
<p>第一种：是全局导航钩子：router.beforeEach(to,from,next)，作用：跳转前进行判断拦截。</p>
<p>第二种：组件内的钩子</p>
<pre><code class="javascript">beforeRouteEnter(to, from, next) &#123;
    // do someting
    // 在渲染该组件的对应路由被 confirm 前调用
    next (vm =&gt; &#123;
    // 这里通过 vm 来访问组件实例解决了没有 this 的问题
    &#125;)
&#125;,
beforeRouteUpdate(to, from, next) &#123;
    // do someting
    // 在当前路由改变，但是依然渲染该组件是调用
&#125;,
beforeRouteLeave(to, from ,next) &#123;
    // do someting
    // 导航离开该组件的对应路由时被调用
&#125;
</code></pre>
<p>第三种：单独路由独享组件</p>
<pre><code class="javascript">cont router = new VueRouter(&#123;
    routes: [
        &#123;
            path: &#39;/file&#39;,
            component: File,
            beforeEnter: (to, from ,next) =&gt; &#123;
                // do someting
            &#125;
        &#125;
    ]
&#125;);
</code></pre>
<h2 id="vue-loader-是什么？使用它的用途有哪些？"><a href="#vue-loader-是什么？使用它的用途有哪些？" class="headerlink" title="vue-loader 是什么？使用它的用途有哪些？"></a>vue-loader 是什么？使用它的用途有哪些？</h2><p>解析.vue 文件的一个加载器，跟 template/js/style 转换成 js 模块。<br>用途：js 可以写 es6、style 样式可以 scss 或 less、template 可以加 jade 等</p>
<h2 id="请简述下-Vuex-的原理和使用方法"><a href="#请简述下-Vuex-的原理和使用方法" class="headerlink" title="请简述下 Vuex 的原理和使用方法"></a>请简述下 Vuex 的原理和使用方法</h2><h2 id="相关知识链接"><a href="#相关知识链接" class="headerlink" title="相关知识链接"></a>相关知识链接</h2><ul>
<li><p><a href="https://github.com/mqyqingfeng/Blog/issues/2">JavaScirpt 深入之从原型到原型链</a></p>
</li>
<li><p><a href="https://github.com/mqyqingfeng/Blog/issues/3">JavaScript 深入之词法作用域和动态作用域</a></p>
</li>
<li><p><a href="https://juejin.im/post/58eee3eda0bb9f006a7eea12">JavaScript 深入之从 ECMAScript 规范解读 this</a></p>
</li>
<li><p><a href="https://segmentfault.com/a/1190000011145364">前端常见跨域解决方案（全）</a></p>
</li>
<li><p><a href="https://juejin.im/post/59eff1fb6fb9a044ff30a942">常见工具函数手写（节流，防抖，扁平，柯里化…）</a></p>
</li>
<li><p><a href="https://juejin.im/post/597724c26fb9a06bb75260e8">promise 用法：八段代码彻底掌握 Promise</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Vue</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
</search>
